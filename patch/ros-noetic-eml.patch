diff --git a/CMakeLists.txt ./CMakeLists.txt
new file mode 100644
index 0000000..01af686
--- /dev/null
+++ ./CMakeLists.txt
@@ -0,0 +1,63 @@
+# Copyright FMTC 2006-2008
+# Author: Klaas Gadeyne.  Copied stuff from <http://cmake.org/HTML/Examples.html>
+# Linux (PREEMPT_RT) port based on patch by RvdM (October, 5th, 2007)
+
+# The name of our project is "EML" (EtherCat Master Library).
+# CMakeLists files in this project can refer to the root source
+# directory of the project as ${EML_SOURCE_DIR} and
+# to the root binary directory of the project as ${EML_BINARY_DIR}.
+project (EML)
+
+OPTION( BUILD_FOR_ECOS "Build EML for the eCos OS" OFF)
+
+IF (BUILD_FOR_ECOS)
+   INCLUDE(UseEcos)
+   SET( ECOS_INSTALL_PATH "/path/to/ecos.ecc file" CACHE STRING "Where are your ecos installation directories (i.e. your ecos.ecc file)?" )
+   # ECOS_ADD_INCLUDE_DIRECTORIES()
+   INCLUDE_DIRECTORIES(${EML_SOURCE_DIR}/include/ethercat/arch-eCos)
+   INCLUDE_DIRECTORIES(${ECOS_INSTALL_PATH}/ecos/install/include/)
+   # FIXME: Build system only supports i386 for now...
+   ECOS_USE_I386_ELF_TOOLS()
+ENDIF (BUILD_FOR_ECOS)
+
+OPTION( BUILD_FOR_RTNET "Build EML using RTNET/Xenomai" OFF)
+
+IF (BUILD_FOR_RTNET)
+	SET(CMAKE_VERBOSE_MAKEFILE ON)
+	SET(RTNET_INSTALL_PATH "/usr/local/rtnet" CACHE STRING "Path of the RTnet installation directory")
+	SET(XENOMAI_INSTALL_PATH "/usr/xenomai" CACHE STRING "Path of the Xenomai installation directory")
+
+	INCLUDE_DIRECTORIES(${EML_SOURCE_DIR}/include/ethercat/arch-RTnet)
+	INCLUDE_DIRECTORIES(${RTNET_INSTALL_PATH}/include)
+	INCLUDE_DIRECTORIES(${XENOMAI_INSTALL_PATH}/include)
+	LINK_DIRECTORIES(${XENOMAI_INSTALL_PATH}/lib)
+
+	SET (XNPOSIX_USER_CFLAGS "`${XENOMAI_INSTALL_PATH}/bin/xeno-config --posix-cflags`")
+	EXEC_PROGRAM ("${XENOMAI_INSTALL_PATH}/bin/xeno-config --posix-ldflags"
+	  OUTPUT_VARIABLE XNPOSIX_USER_LDFLAGS)
+ENDIF (BUILD_FOR_RTNET)
+
+OPTION( BUILD_FOR_POSIX "Build for POSIX (Only tested on Linux/PREEMPT_RT for now)" ON)
+
+IF (BUILD_FOR_POSIX)
+        SET (POSIX_USER_LDFLAGS "-lpthread -lrt")
+
+	INCLUDE_DIRECTORIES(${EML_SOURCE_DIR}/include/ethercat/arch-RTnet)
+
+ENDIF (BUILD_FOR_POSIX)
+
+# Make sure the compiler can find include files from our library.
+include_directories (${EML_SOURCE_DIR}/include)
+
+# This simply branches into the listed subdirectories Recurse into the
+# "src" and "test" subdirectories.  This does not actually cause
+# another cmake executable to run.  The same process will walk through
+# the project's entire directory structure.
+add_subdirectory (src)
+add_subdirectory (tests)
+
+# FIXME KG What's the f*cking difference with SUBDIRS, as used in the
+# ecos examples?
+# SUBDIRS(src tests)
+
+
diff --git a/ethercatmaster.cdl ./ethercatmaster.cdl
new file mode 100644
index 0000000..34e38bb
--- /dev/null
+++ ./ethercatmaster.cdl
@@ -0,0 +1,197 @@
+#====================================================================
+#
+#      ethercatmaster.cdl
+#
+#      EtherCAT Master stack configuration data
+#
+# ====================================================================
+#===========================================================================
+#	This file is part of "EtherCAT Master Library".
+#	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+#	B-1030 Brussels, Belgium.
+#
+#	EtherCAT Master Library is free software; you can redistribute it
+#	and/or modify it under the terms of the GNU General Public License
+#	as published by the Free Software Foundation; either version 2 or
+#	(at your option) any later version.
+#
+#	EtherCAT Master Code is distributed in the hope that it will be
+#	useful, but WITHOUT ANY WARRANTY; without even the implied
+#	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+#	PURPOSE. See the GNU General Public License for more details.
+#
+#	You should have received a copy of the GNU General Public License
+#	along with the EtherCAT Master Library; if not, write to the Free
+#	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+#	02111-1307 USA.
+#
+#	EtherCAT, the EtherCAT trade name and logo are the intellectual
+#	property of, and protected by Beckhoff. You can use "EtherCAT
+#	Master Library" for creating and/or selling or otherwise
+#	distributing an EtherCAT network master under the terms of the
+#	EtherCAT Master License.
+#
+#	You should have received a copy of the EtherCAT Master License
+#	along with the EtherCAT Master Library; if not, write to Beckhoff
+#	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+# ===========================================================================
+
+# ===========================================================================
+# FIXME 
+# - Dependencies on other packages need to be fixed
+#
+# ====================================================================
+
+######DESCRIPTIONBEGIN####
+#
+# Author(s):	  Bob Koninckx, Klaas Gadeyne
+# Contributors:   
+# Date:           2005-04-06
+#
+#####DESCRIPTIONEND####
+#
+# ====================================================================
+
+cdl_package CYGPKG_NET_ETHERCATMASTER {
+	display         "EtherCAT Master"
+	description	"EtherCAT Master protocol stack"	
+
+	compile	-library=libextras.a ecos/support.cxx \
+                         ecos/init.cxx
+
+        cdl_option CYGNUM_ETHERCATMASTER_LOG_LEVEL {
+                display      "EtherCAT Master log level"
+                flavor       data
+                legal_values {0 1 2 3 4}
+                default_value 0
+                description  { "Verbosity of logging information messages. Log level
+                                0 prevents anything from being logged. Level 1 will
+                                only show fatal errors, level 2 shows all errors. Level
+                                3 adds warnings, end, level 4 finally also shows mere
+                                informational messages." }
+        }
+
+        cdl_option CYGNUM_ETHERCATMASTER_DELIVERY_STACK_SIZE {            
+            display          "Delivery thread stack size"
+            flavor           data
+            default_value    16384
+            description      "
+               The EtherCAT ethernet device driver implements a delivery thread
+               which responds to incoming packets and sends out queued packets
+               as soon as the device is available again. This option determines
+               the stack size of this delivery thread."
+        }
+
+        cdl_option CYGNUM_ETHERCATMASTER_DELIVERY_PRIORITY {
+            display          "Delivery thread priority"
+            flavor           data
+            default_value    8
+            legal_values     0 to 31
+            description      "
+               The EtherCAT ethernet device driver implements a delivery thread
+               which responds to incoming packets and sends out queued packets
+               as soon as the device is available again. This option determines
+               the priority of this delivery thread."
+        }
+
+	cdl_component CYGPKG_ETHERCATMASTER_DLL {
+		display     "Datalink layer subsystem"
+                flavor      none
+		requires    CYGPKG_IO_ETH_DRIVERS
+		description "Configuration for the Data Link Layer Subsystem"
+		compile     dll/ethercat_dll.cxx \
+                            dll/ethercat_telegram.cxx \
+			    dll/ethercat_frame.cxx \
+			    dll/ethercat_device_addressed_telegram.cxx \
+			    dll/ethercat_logical_addressed_telegram.cxx \
+			    dll/ethercat_slave_memory.cxx 
+		
+		cdl_option CYGDAT_ETHERCATMASTER_ETH_DEVICE {
+			display         "Ethernet device"
+			flavor          data
+			default_value	{"\"eth0\""}
+			description     "Ethernet device to be used by the EtherCAT master"
+		}
+
+	       	cdl_option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY {            
+		   display          "Timeout value"
+		   flavor           data
+		   default_value    20000000
+		   description      "
+                       Due to its implementation where slaves process
+		       the EtherCAT frames on-the-fly,  EtherCAT frames
+		       should return to the master 'instantaneously'.
+		       Due to hardware problems (e.g. disconnecting a
+		       slave from the logical ring,  sometimes frames
+		       don't get back.  For this reason, a the rx part
+		       implements a timeout after which it gives up.
+		       This option determines the value of this
+		       timeout, expressed in nanoseconds."
+		}
+
+	       cdl_option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY_TICKS {            
+		   display          "Timeout value in ticks"
+		   flavor           data
+		   calculated       ((CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+		}
+	}
+
+	cdl_component CYGPKG_ETHERCATMASTER_AL {
+		display     "Application layer subsystem"
+                flavor      none
+		requires    CYGPKG_ETHERCATMASTER_DLL
+		description "Configuration for the Application Link Subsystem"
+		compile     al/ethercat_slave_conf.cxx \
+			    al/ethercat_FSM.cxx \
+			    al/ethercat_slave_handler.cxx \
+			    al/ethercat_AL.cxx \
+			    al/ethercat_mbx.cxx \
+			    al/ethercat_router.cxx \
+			    al/ethercat_process_data.cxx \
+		            al/ethercat_master.cxx
+			    		    
+	        cdl_option CYGNUM_ETHERCATMASTER_ROUTE_STACK_SIZE {            
+		    display          "Route thread stack size"
+		    flavor           data
+		    default_value    16384
+		    description      "
+                        The EtherCAT ethernet device driver implements a
+                        periodic route thread which is used to check if any
+	                of the EtherCAT slaves has posted something in its
+	                mailbox.  This option determines the stack size of this
+	                thread."
+	       }
+
+	       cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PRIORITY {            
+		   display          "Route thread priority"
+		   flavor           data
+		   default_value    10
+		   legal_values     0 to 31
+		   description      "
+                       The EtherCAT ethernet device driver implements a period
+                       route thread which is used to check if any of the
+	               EtherCAT slaves has posted something in its mailbox.
+	               This option determines the thread priority of this
+                       thread."
+	       }
+
+	       cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD {            
+		   display          "Route thread period"
+		   flavor           data
+		   default_value    100000000
+		   description      "
+                       The EtherCAT ethernet device driver implements a period
+                       route thread which is used to check if any of the
+	               EtherCAT slaves has posted something in its mailbox.
+	               This option determines the period of this thread (and
+                       thus the responsiveness of ROUTE commands)
+		       expressed in nanoseconds."
+		}
+
+	       cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD_TICKS {            
+		   display          "Route thread period in ticks"
+		   flavor           data
+		   calculated       ((CYGNUM_ETHERCATMASTER_ROUTE_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+		}
+	}
+}
diff --git a/include/al/ethercat_AL.h ./include/al/ethercat_AL.h
new file mode 100644
index 0000000..338bcf3
--- /dev/null
+++ ./include/al/ethercat_AL.h
@@ -0,0 +1,184 @@
+// $Id: ethercat_AL.h,v 1.15 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_al__
+#define __ethercat_al__
+
+#include "ethercat/ethercat_defs.h"
+
+// forward declaration
+class EtherCAT_DataLinkLayer;
+class EtherCAT_SlaveHandler;
+class EtherCAT_SlaveDb;
+class EC_FixedStationAddress;
+
+/// Convert ringpos2adp in case of autoincrement addressing;
+/** @param ringpos Position in the ring (counting starts from 0)
+    @return adp
+*/
+inline EC_UINT ringpos2adp(EC_UINT ringpos)
+{
+  return (EC_UINT) (0x0000 - ringpos);
+}
+
+/// Convert adp2ringpos in case of autoincrement addressing;
+/** @param adp Auto increment address
+    @return ringpos
+*/
+inline EC_UINT adp2ringpos(EC_UINT adp)
+{
+  return (EC_UINT) (0x0000 - adp);
+}
+
+/// EtherCAT "logic"
+/** @todo search better name for this
+ */
+class EC_Logic
+{
+ public: 
+  /// this class is a singleton
+  static EC_Logic * instance();
+  virtual ~EC_Logic(){};
+  /// Get current idx
+  EC_USINT get_idx();
+  /// Get wkc (normally always zero, not truly necessary)
+  EC_UINT get_wkc();
+
+ private:
+  /// Constructor
+  EC_Logic();
+  /// Instance
+  static EC_Logic * m_instance;
+  /// Working Counter
+  const EC_UINT m_wkc;
+  /// Index (Increased with each frame the master sends)
+  EC_USINT m_idx;
+};
+
+inline EC_USINT
+EC_Logic::get_idx(){ return m_idx++;}
+inline EC_UINT
+EC_Logic::get_wkc(){ return m_wkc;}
+
+/// EtherCAT Master Application Layer
+class EtherCAT_AL
+{
+  friend class EtherCAT_Router;
+  
+ public:
+  /// This class is a singleton
+  static EtherCAT_AL * instance();
+  
+  /// Destructor
+  virtual ~EtherCAT_AL();
+
+  /// Get pointer to slaveHandler
+  /** @return pointer to the slaveHandler if it exist, or NULL
+      otherwise
+      @todo As implemented right now, this is an O(N) operation.  Try
+      to use some kind of mapping/hash table...
+  */
+  EtherCAT_SlaveHandler * get_slave_handler(EC_FixedStationAddress station_address);
+
+  /// Get the number of slaves
+  /** @return the number of slaves
+   */
+  unsigned int get_num_slaves(){ return m_num_slaves;}
+
+  /// Check the AL is ready (init was succesful)
+  /** @return true if ready
+  */
+
+  bool isReady();
+
+ protected:
+  /// Constructor (protected)
+  EtherCAT_AL();
+
+  /// Init of EtherCAT network. 
+  /** Counts and identifies the number of slaves in the network, and
+      resets the slaves configuration.
+      @return true if success
+  */
+  bool init(void);
+
+  /// Scan the slave network, create the necessary slave Handlers
+  /** @return true if succes
+      @todo if 2 slaves have the same product code and revision, they
+      will get the same address!!
+  */
+  bool scan_slaves(void);
+
+  /// Reset slaves
+  /** @return true if success
+  */
+  bool reset_slaves(void);
+
+  /// Put all slaves in their init state
+  /** @return true if success
+  */
+  bool put_slaves_in_init(void);
+
+ private:
+  /// Instance 
+  static EtherCAT_AL * m_instance;
+  /// DLL Instance
+  EtherCAT_DataLinkLayer * m_dll_instance;
+  /// Using commonly idx
+  EC_Logic * m_logic_instance;
+
+  /// Pointer to the slave Handlers
+  EtherCAT_SlaveHandler ** m_slave_handler;
+
+  /// Pointer to the slave database
+  EtherCAT_SlaveDb * m_slave_db;
+  
+  /// Get information from the SII (in Autoincrement mode)
+  /** @param slave_adp address pointer of the slave to read in
+      autoincrement mode
+      @param address address of the EEPROM that should be read
+      @param a_buffer buffer to put the data in
+      @return reading succeeded?
+  */
+  bool read_SII(EC_UINT slave_adp, EC_UDINT address, unsigned char * a_buffer);
+  
+  /// Number of slaves in the setup
+  unsigned int m_num_slaves;
+
+  /// Set is init is succesful
+  bool m_ready;
+};
+
+
+
+#endif
diff --git a/include/al/ethercat_FSM.h ./include/al/ethercat_FSM.h
new file mode 100644
index 0000000..dd9fc70
--- /dev/null
+++ ./include/al/ethercat_FSM.h
@@ -0,0 +1,196 @@
+// $Id: ethercat_FSM.h,v 1.16 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_fsm__
+#define __ethercat_fsm__
+
+/* Note, this class is supposed to be programmed according to the
+   FSM design Pattern.
+*/
+
+// forward declarations
+class EtherCAT_AL;
+class EC_Logic;
+class EtherCAT_SlaveHandler;
+class EtherCAT_DataLinkLayer;
+class EtherCAT_Router;
+class EtherCAT_PD_Buffer;
+
+// FIXME how to do forward declaration of typedef enum?, with "extern"
+// keyword?
+#include "dll/ethercat_slave_memory.h"
+
+/// EtherCAT State Machine Operations
+class EC_ESM_Ops 
+{
+ protected:
+  /// Start MBX communication
+  bool start_mbx_comm();
+  /// Stop MBX communication
+  bool stop_mbx_comm();
+  /// Start Input update
+  bool start_input_update();
+  /// Stop Input update
+  bool stop_input_update();
+  /// Start Output update
+  bool start_output_update();
+  /// Stop Output update
+  bool stop_output_update();
+
+  virtual ~EC_ESM_Ops(){};
+ protected:
+  /// Constructor
+  /** @param a_SH pointer to slave handler
+   */
+  EC_ESM_Ops(EtherCAT_SlaveHandler * a_SH);
+  
+  EtherCAT_DataLinkLayer * m_dll_instance;
+  EC_Logic * m_logic_instance;
+  EtherCAT_SlaveHandler * m_SH;
+  EtherCAT_Router * m_router_instance;
+  EtherCAT_PD_Buffer * m_pdbuf_instance;
+
+  /// Change state of Slave
+  /** @return true if succeeded
+      @pre The station address of the slave is set (this function uses
+      npwr telegrams!
+  */
+  bool set_state(EC_State a_state);
+};
+
+// More forward declarations :-)
+class EC_ESM;
+class EC_ESM_InitState;
+class EC_ESM_PreOpState;
+class EC_ESM_SafeOpState;
+class EC_ESM_OpState;
+
+/// ESM State Interface class
+/** @todo The bootstrap state is currently not implemented
+ */
+class EC_ESM_State
+{
+  friend class EC_ESM;
+  
+ public:
+  virtual ~EC_ESM_State(){};
+  /// Change the state of an EtherCAT state machine
+  /** @param a_ESM pointer to the EtherCAT state machine
+      @param a_state to which state?  Possibilities are
+      - EC_INIT_STATE = 0x01,
+      - EC_PREOP_STATE = 0x02,
+      - EC_BOOTSTRAP_STATE = 0x03,
+      - EC_SAFEOP_STATE = 0x04,
+      - EC_OP_STATE = 0x08
+  */
+  virtual bool to_state(EC_ESM * a_ESM, EC_State a_state) = 0;  
+  virtual EC_State get_state( ) const = 0;
+ protected:
+  static EC_ESM_InitState initState;
+  static EC_ESM_PreOpState preopState;
+  static EC_ESM_SafeOpState safeopState;
+  static EC_ESM_OpState opState;
+};
+
+/// EtherCAT State Machine
+/** @todo Unexpected transitions in the state of the slave (via slaves
+    application, only for complex slaves) are not dealt with for
+    now...  This should probably be fixed using a special mailbox msg or a polling
+    mechanism but AFAIS this is undocumented in the spec (see
+    8.2.4.4.6 Stop output update)...
+*/
+class EC_ESM : public EC_ESM_Ops
+{
+  friend class EC_ESM_State;
+  friend class EC_ESM_InitState;
+  friend class EC_ESM_PreOpState;
+  friend class EC_ESM_SafeOpState;
+  friend class EC_ESM_OpState;
+
+ public:
+  /// State Transitions
+  /** @param a_state state to go to. Possibilities are
+      - EC_INIT_STATE = 0x01,
+      - EC_PREOP_STATE = 0x02,
+      - EC_BOOTSTRAP_STATE = 0x03,
+      - EC_SAFEOP_STATE = 0x04,
+      - EC_OP_STATE = 0x08
+  */
+  bool to_state(EC_State a_state){ return (m_esm_state->to_state(this,a_state)); }
+  
+  EC_State get_state() { return m_esm_state->get_state(); } 
+
+  virtual ~EC_ESM(){};
+  
+ protected:
+  /// Set the internal state
+  void setState(EC_ESM_State * a_esm_state){ m_esm_state = a_esm_state; }
+
+  /// Constructor
+  /** @param a_SH pointer to Slave Handler this FSM concerns
+   */
+  EC_ESM(EtherCAT_SlaveHandler * a_SH);
+
+ private:
+  EC_ESM_State * m_esm_state;
+};
+
+class EC_ESM_InitState : public EC_ESM_State
+{
+ public:
+  virtual EC_State get_state( ) const;
+  virtual bool to_state(EC_ESM * a_ESM, EC_State a_state);
+};
+
+class EC_ESM_PreOpState : public EC_ESM_State
+{
+ public:
+  virtual EC_State get_state( ) const;
+  virtual bool to_state(EC_ESM * a_ESM, EC_State a_state);
+};
+
+class EC_ESM_SafeOpState : public EC_ESM_State
+{
+ public:
+  virtual EC_State get_state( ) const;
+  virtual bool to_state(EC_ESM * a_ESM, EC_State a_state);
+};
+
+class EC_ESM_OpState : public EC_ESM_State
+{
+ public:
+  virtual EC_State get_state( ) const;
+  virtual bool to_state(EC_ESM * a_ESM, EC_State a_state);
+};
+
+#endif // __ethercat_fsm__
diff --git a/include/al/ethercat_master.h ./include/al/ethercat_master.h
new file mode 100644
index 0000000..ab57d15
--- /dev/null
+++ ./include/al/ethercat_master.h
@@ -0,0 +1,100 @@
+// $Id: ethercat_master.h,v 1.25 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_master__
+#define __ethercat_master__
+
+// Forward declarations
+class EtherCAT_AL;
+class EtherCAT_SlaveHandler;
+class EtherCAT_Router;
+class EtherCAT_PD_Buffer;
+class EC_Logic;
+class EtherCAT_DataLinkLayer;
+
+#include "al/ethercat_mbx.h"
+#include "al/ethercat_process_data.h"
+#include "dll/ethercat_slave_memory.h"
+
+/// EtherCAT Master instance
+class EtherCAT_Master
+{
+ public:
+  /// This class is a singleton
+  static EtherCAT_Master * instance();
+  /// Destructor
+  virtual ~EtherCAT_Master();
+
+  /// Get Slave Handler
+  /** @return Pointer to slavehandler if found in the network, or NULL
+      otherwise 
+  */
+  EtherCAT_SlaveHandler * get_slave_handler(EC_FixedStationAddress address);
+
+  /// Send Process data
+  /** @param datalen number of bytes that should be set
+      @param data pointer to data array.  Data is read, transmitted,
+      and (if the operation succeeded) the received data is put in the 
+      data array.  This happens synchronously with the method call.
+      @return true if msg got true
+  */
+  bool txandrx_PD(size_t datalen,
+		  unsigned char * data);
+
+ protected:
+  /// Constructor (protected)
+  EtherCAT_Master();
+
+ private:
+  /// Master instance
+  static EtherCAT_Master * m_instance;
+  /// Pointer to m_AL_instance
+  EtherCAT_AL * m_al_instance;
+  /// Pointer to router instance
+  EtherCAT_Router * m_router_instance;
+  /// Pointer to process data buffer instance
+  EtherCAT_PD_Buffer * m_pdbuf_instance;
+
+  /* If master also has slave functionality, it has its own mailbox
+     and its own address, so slaves can post msgs to it.
+  EtherCAT_Mbx m_mbx;
+  EC_FixedStationAddress m_address;
+  */
+
+  /// Pointer to logic instance
+  EC_Logic * m_logic_instance;
+  /// Pointer to DLL instance
+  EtherCAT_DataLinkLayer * m_dll_instance;
+};
+
+#endif
diff --git a/include/al/ethercat_mbx.h ./include/al/ethercat_mbx.h
new file mode 100644
index 0000000..72d4636
--- /dev/null
+++ ./include/al/ethercat_mbx.h
@@ -0,0 +1,264 @@
+// $Id: ethercat_mbx.h,v 1.14 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_mbx__
+#define __ethercat_mbx__
+
+#include "ethercat/ethercat_defs.h"
+#include "dll/ethercat_slave_memory.h"
+
+typedef enum {
+  EC_AoE = 0x01, // ADS over EtherCAT
+  EC_EoE = 0x02, // Ethernet over EtherCAT
+  EC_CoE = 0x03, // CANOpen over EtherCAT
+  EC_FoE = 0x04, // File Access over EtherCAT
+} ECMbxMsgType;
+
+/// EtherCAT Mbx Message type
+class EC_MbxMsgType
+{
+ public:
+  /// Constructor
+  /** @param type Message type:  Possibilities include
+      - EC_AoE (ADS over EtherCAT),
+      - EC_EoE (Ethernet over EtherCAT)
+      - EC_CoE (CANOpen over EtherCAT)
+      - EC_FoE (File Access over EtherCAT)
+  */
+  EC_MbxMsgType(ECMbxMsgType type = EC_CoE) : msg_type(type){};
+  virtual ~EC_MbxMsgType(){};
+  /// Cast operator
+  operator EC_USINT() const {return msg_type;}
+ private:
+  EC_USINT msg_type;
+};
+
+/// EtherCAT Mbx Message Priority
+class EC_MbxMsgPriority
+{
+ public:
+  /// Constructor
+  /** @param priority priority of the msg (from 0 to 3 is allowed,
+      with 3 the max Priority)
+  */
+  EC_MbxMsgPriority(EC_USINT priority = 0x00)
+    {
+      if(priority < 4)
+	msg_priority = priority;
+      else {
+	ec_log(EC_LOG_WARNING, "EC_MbxMsgPriority: Max Priority is 0x03, using 0x03\n");
+	msg_priority = 0x03;
+      }
+    }
+  virtual ~EC_MbxMsgPriority(){};
+  /// Cast operator
+  operator EC_USINT() const {return msg_priority;}
+ private:
+  EC_USINT msg_priority;
+};
+
+// Header size is 6 bytes
+static const size_t EC_MBXMSG_HDR_SIZE = 6;
+
+/// EtherCAT MbxMsg header
+class EC_MbxMsgHdr : public EC_DataStruct
+{
+  friend class EtherCAT_Router;
+  
+ public:
+  /// Constructor
+  /** @param a_length Length of the MbxMsg
+      @param a_address 
+      - For Master/Slave and Slave/Master communication: Address of
+      destination.
+      - For slave to slave communication (routing by Master).  Slave
+        puts station address of destination (it must therefore now this
+	address!) so master knows where to send it.  Master (in the
+	router) alters address field so destination slave knows where
+	the message came from.
+      @param a_priority Priority of this message
+      @param a_type Type of this Message (higher level protocol)
+  */
+  EC_MbxMsgHdr(EC_UINT a_length, 
+		EC_FixedStationAddress a_address,
+		EC_MbxMsgPriority a_priority,
+		EC_MbxMsgType a_type)
+    : EC_DataStruct(EC_MBXMSG_HDR_SIZE),
+    m_length(a_length), m_address(a_address), 
+    m_priority(a_priority), m_type(a_type){};
+  
+  /// Constructor from data array
+  EC_MbxMsgHdr(const unsigned char * a_buffer);
+  virtual ~EC_MbxMsgHdr(){};
+
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+ public:
+  EC_UINT  m_length;
+  EC_FixedStationAddress m_address;
+  // EC_USINT  m_channel; 6 bits unused for now...;
+  EC_MbxMsgPriority  m_priority;
+  EC_MbxMsgType      m_type;
+  // EC_UINT reserved : 4;
+};
+
+/// EtherCAT Mailbox Message
+class EtherCAT_MbxMsg
+{
+  friend class EtherCAT_Router;
+  
+ public:
+  /// Constructor
+  EtherCAT_MbxMsg(EC_MbxMsgHdr a_hdr, unsigned char * a_MbxMsgdata)
+    : m_hdr(a_hdr), m_MbxMsgdata(a_MbxMsgdata){}
+  EtherCAT_MbxMsg(EC_UINT a_length, EC_UINT a_address,
+		  EC_MbxMsgPriority a_priority,
+		  EC_MbxMsgType a_type,
+		  unsigned char * a_MbxMsgdata)
+    : m_hdr(a_length,a_address,a_priority,a_type), m_MbxMsgdata(a_MbxMsgdata){}
+  EtherCAT_MbxMsg(const unsigned char * a_buffer);
+
+  virtual ~EtherCAT_MbxMsg(){};
+
+  /// Dump msg to buffer for sending...
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+ protected:
+  /// MbxMsg header
+  EC_MbxMsgHdr m_hdr;
+  /// MbxMsg data
+  const unsigned char * m_MbxMsgdata;
+
+  virtual unsigned char * dump_data(unsigned char * a_buffer) const;
+};
+
+/// EtherCAT Mailbox
+class EtherCAT_Mbx
+{
+ public:
+  /// Write a message to the mailbox
+  bool write(EtherCAT_MbxMsg * a_msg);
+  /// Read a message from the mailbox
+  bool read(EtherCAT_MbxMsg * a_msg);  
+
+  EtherCAT_Mbx(){};
+  virtual ~EtherCAT_Mbx(){};
+ protected:
+};
+
+// ==================================================
+// CANopen over EtherCAT
+// ==================================================
+
+typedef enum {
+  CANopen_Emergency = 0x01,
+  CANopen_SDORequest = 0x02,
+  CANopen_SDOResponse = 0x03,
+  CANopen_txPDO = 0x04,
+  CANopen_rxPDO = 0x05,
+  CANopen_txPDORemoteReq = 0x06,
+  CANopen_rxPDORemoteReq = 0x07,
+  CANopen_SDOInformation = 0x08,
+} CANopenService;
+
+/// CANOpen Service
+class CANopen_Service
+{
+ public:
+  /// Constructor
+  /** @param a_service CanOpen Service.  Possibilities are
+      - CANopen_Emergency, 
+      - CANopen_SDORequest, 
+      - CANopen_SDOResponse,
+      - CANopen_txPDO, 
+      - CANopen_rxPDO, 
+      - CANopen_txPDORemoteReq,
+      - CANopen_rxPDORemoteReq, 
+      - CANopen_SDOInformation
+   */
+  CANopen_Service(CANopenService a_service = CANopen_Emergency)
+    : m_service(a_service){}
+
+  virtual ~CANopen_Service(){};
+  /// Cast operator
+  operator EC_USINT() const { return m_service; }
+
+ private:
+  CANopenService m_service;
+};
+
+static const size_t EC_MBXMSG_COE_HDR_SIZE = 2;
+
+/// CANopen over EtherCAT Mailbox Message header
+class EC_CoE_Hdr : public EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param a_service CanOpen Service
+  */
+  EC_CoE_Hdr(CANopen_Service a_service = CANopen_Emergency) :
+    EC_DataStruct(EC_MBXMSG_COE_HDR_SIZE),
+    m_service(a_service){};
+  EC_CoE_Hdr(const unsigned char * a_buffer);
+  virtual ~EC_CoE_Hdr(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+ private:
+  // FIXME meaning of these is nog clear from spec
+  // Number Low: 8 bits depending on CANopen service
+  // Number High: 1 bit depending on CANopen service
+  CANopen_Service m_service;
+};
+
+/// CANopen over EtherCAT Mailbox Message
+class EtherCAT_CoE_MbxMsg : public EtherCAT_MbxMsg
+{
+ public:
+  EtherCAT_CoE_MbxMsg(EC_MbxMsgHdr a_hdr, 
+		      EC_CoE_Hdr a_CoE_hdr,
+		      unsigned char * a_MbxMsgdata)
+    : EtherCAT_MbxMsg(a_hdr,a_MbxMsgdata), m_CoE_Hdr(a_CoE_hdr){}
+  EtherCAT_CoE_MbxMsg(EC_UINT a_length, EC_UINT a_address,
+		      EC_MbxMsgPriority a_priority,
+		      EC_MbxMsgType a_type,
+		      CANopen_Service a_service,
+		      unsigned char * a_MbxMsgdata)
+    : EtherCAT_MbxMsg(a_length,a_address,a_priority,a_type,a_MbxMsgdata), m_CoE_Hdr(a_service){}
+  EtherCAT_CoE_MbxMsg(unsigned char * a_buffer);
+
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+ protected:
+  EC_CoE_Hdr m_CoE_Hdr;
+};
+
+#endif // __ethercat_mbx__
diff --git a/include/al/ethercat_process_data.h ./include/al/ethercat_process_data.h
new file mode 100644
index 0000000..85de58d
--- /dev/null
+++ ./include/al/ethercat_process_data.h
@@ -0,0 +1,102 @@
+// $Id: ethercat_process_data.h,v 1.8 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_pd__
+#define __ethercat_pd__
+
+// forward declarations
+class EC_Logic;
+class EtherCAT_DataLinkLayer;
+
+#include "dll/ethercat_logical_addressed_telegram.h"
+#include "dll/ethercat_frame.h"
+
+/// EtherCAT Process Data buffer
+/** @note The current implementation starts passing PD as soon as *one* of the
+    slaves indicated it arrived in its safe-operational state by using
+    the EtherCAT_PD_Buffer::start() method.  The advantage is that an application could remain running.
+    If a slave follows the spec, it won't process PD unless it is in
+    its SafeOp or Op state, so this should harm...
+    Nevertheless, changing this behaviour into full spec compliance
+    only requires changing 2 lines of code.  See the .cxx file.
+*/
+class EtherCAT_PD_Buffer
+{
+  friend class EC_ESM_Ops;
+  
+ public:
+  /// Singleton
+  static EtherCAT_PD_Buffer * instance();
+
+  /// Send some process data
+  /** @param datalen number of bytes that should be set
+      @param data pointer to data array.  Data is read, transmitted,
+      and (if the operation succeeded) the received data is put in the
+      data array
+      @return true if msg got true
+  */
+  bool txandrx(size_t datalen, unsigned char * data);
+
+ protected:  
+  /// Start transmitting process data
+  void start();
+  /// Stop transmitting process data
+  void stop();
+
+  /// Constructor
+  EtherCAT_PD_Buffer();
+  virtual ~EtherCAT_PD_Buffer();
+  
+ private:
+  /// Pointer to EC_Logic
+  EC_Logic * m_logic_instance;
+  /// Pointer to DLL instance
+  EtherCAT_DataLinkLayer * m_dll_instance;
+  /// This class is a singleton
+  static EtherCAT_PD_Buffer * m_instance;
+
+  /// See note in class definition.
+  unsigned int m_is_running;
+
+  /// Process data can be divided over MAX_CHUCKS packets 
+  /// of upto CHUNK_SIZE bytes
+  static const unsigned MAX_CHUNKS=4;
+  static const unsigned CHUNK_SIZE=1486;
+
+  /// Telegram(s) to be sent
+  LRW_Telegram *m_lrw_telegram[MAX_CHUNKS];
+  /// EtherCAT frame(s) to be sent
+  EC_Ethernet_Frame *m_lrw_frame[MAX_CHUNKS];
+};
+
+#endif
diff --git a/include/al/ethercat_router.h ./include/al/ethercat_router.h
new file mode 100644
index 0000000..2983ceb
--- /dev/null
+++ ./include/al/ethercat_router.h
@@ -0,0 +1,109 @@
+// $Id: ethercat_router.h,v 1.14 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_router__
+#define __ethercat_router__
+
+// forward declaration
+class EtherCAT_AL;
+class EC_Logic;
+class EtherCAT_DataLinkLayer;
+class EtherCAT_SlaveHandler;
+class EtherCAT_MbxMsg;
+
+/// EtherCAT Router component
+class EtherCAT_Router
+{
+ public:
+  /// Singleton
+  static EtherCAT_Router * instance();
+  virtual ~EtherCAT_Router();
+
+  /// Start routing
+  void start();
+  /// Stop routing
+  void stop();
+  /// Router running?
+  bool is_running() const { return (EtherCAT_Router::m_is_running != 0); }
+
+  /// Actual routing code
+  /** @todo  This method should not be public, but since it is used in
+      a C-function and I don't know how I could declare a C-function
+      to be a friend of a class...
+      @todo  The current implementation simply polls the sync manager
+      data area of each slave and checks if wkc is incremented.
+      Another solution is to configure FMMU's of each slave and query
+      the slaves with one logical EtherCAT msg.  This has the
+      advantage of only using one message per slave, but it
+      "sacrifices" an extra FMMU per slave, which might not always be
+      possible.  In that case, the master would---during the
+      start_mbx_communication() call of slaves---configure an FMMU of
+      the slave which listens to the written bit of sync manager 0.
+   */
+  void route(void) const;  
+ protected:
+  EtherCAT_Router();
+  
+ private:
+  /// Pointer to AL instance
+  EtherCAT_AL * m_al_instance;
+  /// Pointer to EC_Logic
+  EC_Logic * m_logic_instance;
+  /// Pointer to DLL instance
+  EtherCAT_DataLinkLayer * m_dll_instance;
+  
+  static EtherCAT_Router * m_instance;
+  /// Usage counter
+  unsigned int m_is_running;
+
+  /// Check and deliver post from slave
+  /** Check if slave posted something in its mailbox and if positive,
+      deliver msgs to destination.
+      @param sh Slave Handler to query
+      @return true if nothing went wrong (i.e. nothing was posted, or
+      no error occurred during routing
+  */
+  bool check_mbx(const EtherCAT_SlaveHandler * sh) const;
+  
+  /// Post a msg from a certain slave
+  /** @param msg mbx_msg to be posted
+      @param from_sh "poster" of the msg (The EtherCAT protocol does
+      not provide a From: header in its messages)
+      @return true if everything went fine
+   */
+  bool post_mbxmsg(EtherCAT_MbxMsg * msg, 
+		   const EtherCAT_SlaveHandler * from_sh) const;
+
+};
+
+#endif
diff --git a/include/al/ethercat_slave_conf.h ./include/al/ethercat_slave_conf.h
new file mode 100644
index 0000000..730a904
--- /dev/null
+++ ./include/al/ethercat_slave_conf.h
@@ -0,0 +1,234 @@
+// $Id: ethercat_slave_conf.h,v 1.14 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_slave_conf__
+#define __ethercat_slave_conf__
+
+#include "ethercat/ethercat_defs.h"
+#include "dll/ethercat_slave_memory.h"
+
+/// FMMU Configuration of a slave
+class EtherCAT_FMMU_Config
+{
+ public:
+  /// Constructor
+  /** @param a_num_used_fmmus the number of used FMMUs for this slave
+      (configuration)
+   */
+  EtherCAT_FMMU_Config(unsigned int a_num_used_fmmus);
+  virtual ~EtherCAT_FMMU_Config();
+
+  /// Returns the number of used FMMUs
+  /** @return the number of used FMMUs
+   */
+  unsigned int get_num_used_fmmus() const {return m_num_used_fmmus;}
+
+  /// Operator []
+  /** @param i which FMMU
+      @return ref to the FMMU
+  */
+  EC_FMMU & operator[](unsigned int i);
+  /// Operator [] (const version)
+  /** @param i which FMMU
+      @return ref to the FMMU
+  */
+  const EC_FMMU & operator[](unsigned int i) const;
+
+ protected:
+  EC_FMMU * fmmus;
+  unsigned int m_num_used_fmmus;
+};
+
+/// Process Data Configuration
+/** This class contains the configuration of the Sync Managers used
+    for the process data transmission
+*/
+class EtherCAT_PD_Config
+{
+ public:
+  /// Constructor
+  /** @param a_num_used_sms The number of used Sync Managers for
+      transmitting process data
+  */
+  EtherCAT_PD_Config(unsigned int a_num_used_sms);
+  virtual ~EtherCAT_PD_Config();
+
+  /// Retrieve the number of used Sync Managers
+  /** @return the number of used Sync Managers of this config
+   */
+  unsigned int get_num_used_sms() const {return m_num_used_sms;}
+
+  /// Get a sync Manager configuration
+  /** @param i which Sync Manager 
+      @return ref to the Sync Manager
+  */
+  EC_SyncMan & operator[](unsigned int i);
+  /// Get a sync Manager configuration (const version)
+  /** @param i which Sync Manager 
+      @return ref to the Sync Manager
+  */
+  const EC_SyncMan & operator[](unsigned int i) const;
+
+ protected:
+  /// Pointer to the Sync Manager array
+  EC_SyncMan * sms;
+  /// Number of used Sync Managers
+  unsigned int m_num_used_sms;
+};
+
+/// Mailbox Configuration (Sync Manager 0 and 1)
+typedef struct
+{
+  /// Sync Manager 0: For Master to slave communication
+  EC_SyncMan SM0;
+  /// Sync Manager 1: For Slave to Master communication
+  EC_SyncMan SM1;
+} EtherCAT_MbxConfig;
+
+/// Configuration of EtherCAT Slave
+/** @todo Build this class by parsing (xml-)configuration file
+ */
+class EtherCAT_SlaveConfig
+{
+ public:
+  /// Constructor
+  /** @param a_product_code product code of the slave
+      @param a_revision revision of the slave
+      @param a_station_address address of the station as given in
+      config file
+      @param a_fmmu_config pointer to configuration of fmmus as
+      created when parsing config file
+      @param a_pd_config pointer to configuration of SM for process
+      data
+      @param a_mbx_config MBX configuration if this slave is complex.
+      Default argument is NULL for simple slaves
+      @note  CanOpen stuff for complex slaves such as the PDO Mapping, the
+      Sync Manager PDO assign objects and the startup objects are not
+      implemented (yet)
+      See p. 106 and 162 of spec.
+      // EtherCAT_PDO_Mapping m_pdo_mapping;
+      // EtherCAT_SM_PDO_Assign m_sm_pdo_assign;
+      // EtherCAT_Startup_Objects m_startup_objects;
+  */
+  EtherCAT_SlaveConfig(EC_UDINT a_product_code,
+		       EC_UDINT a_revision,
+		       EC_FixedStationAddress a_station_address,
+		       EtherCAT_FMMU_Config * a_fmmu_config,
+		       EtherCAT_PD_Config * a_pd_config,
+		       EtherCAT_MbxConfig * a_mbx_config = NULL);
+  
+  virtual ~EtherCAT_SlaveConfig();
+
+ public:
+  /// Is this a complex slave?
+  bool is_complex(void) const { return m_complex; };
+  /// Get product code
+  EC_UDINT get_product_code() const { return m_product_code; };
+  /// Get revision
+  EC_UDINT get_revision() const { return m_revision; };
+  /// Get station address
+  EC_FixedStationAddress get_station_address() const {return m_station_address; };
+  /// Get FMMU config to be written when going to preop
+  const EtherCAT_FMMU_Config * get_fmmu_config() const {return m_fmmu_config; };
+  void set_fmmu_config(EtherCAT_FMMU_Config *new_config) { m_fmmu_config = new_config; };
+  /// Get PD Configuration (SMS)
+  const EtherCAT_PD_Config * get_pd_config() const {return m_pd_config; };
+  void set_pd_config(EtherCAT_PD_Config *new_config) { m_pd_config = new_config; };
+  /// Get configuration of Sync Man channel 0 and 1 for MBX
+  /** @return pointer to config in case of complex slave, or NULL for
+      a simple slave
+  */
+  const EtherCAT_MbxConfig * get_mbx_config() const { return m_mbx_config; };
+  void set_mbx_config(EtherCAT_MbxConfig *new_config);
+  /// Check if the SlaveConfig is already used
+  bool is_used() { return used; };
+  /// The SlaveConfig is now used
+  void set_used() { used = true; };
+
+ protected:
+  /// Product code
+  EC_UDINT m_product_code;
+  /// Revision
+  EC_UDINT m_revision;
+  /// Station address
+  EC_FixedStationAddress m_station_address;
+  /// FMMU config to be written when going to preop
+  EtherCAT_FMMU_Config * m_fmmu_config;
+  /// PD Configuration (SMS)
+  EtherCAT_PD_Config * m_pd_config;  /// Position in the EtherCAT logical Ring
+  /// Configuration of Sync Man channel 0 and 1 for MBX
+  EtherCAT_MbxConfig * m_mbx_config;
+
+  bool m_complex;
+  
+  bool used;
+
+};
+
+/// Database of EtherCAT slave configurations
+/** @todo allow dynamic updating by adding of removing a slave
+    configuration
+*/
+class EtherCAT_SlaveDb
+{
+ public:
+  /// Singleton
+  static EtherCAT_SlaveDb * instance(unsigned int num_slaves = 0);
+  
+  virtual ~EtherCAT_SlaveDb();
+
+  EtherCAT_SlaveConfig * operator[](unsigned int i);
+  const EtherCAT_SlaveConfig * operator[](unsigned int i) const;
+  void set_conf(EtherCAT_SlaveConfig * conf, unsigned int i);
+  
+  /// Find a configuration...
+  /** @param productcode product code
+      @param revision revision
+      @return Pointer to slave configuration if found, or NULL
+  otherwise)
+  */
+  const EtherCAT_SlaveConfig * find(EC_UDINT productcode,
+				    EC_UDINT revision) const;
+ protected:
+  /// Constructor
+  EtherCAT_SlaveDb(unsigned int num_slaves);
+
+ private:
+  static EtherCAT_SlaveDb * m_instance;
+  
+  EtherCAT_SlaveConfig ** m_sc;
+  unsigned int m_num_slaves;
+
+};
+
+#endif // __ethercat_slave_conf__
diff --git a/include/al/ethercat_slave_handler.h ./include/al/ethercat_slave_handler.h
new file mode 100644
index 0000000..f5a0a5b
--- /dev/null
+++ ./include/al/ethercat_slave_handler.h
@@ -0,0 +1,100 @@
+// $Id: ethercat_slave_handler.h,v 1.25 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_slave_handler__
+#define __ethercat_slave_handler__
+
+#include "al/ethercat_FSM.h"
+#include "al/ethercat_slave_conf.h"
+
+// forward declaration
+class EtherCAT_AL;
+
+/// EtherCAT Slave Handler
+class EtherCAT_SlaveHandler : public EC_ESM, public EtherCAT_SlaveConfig
+{
+  // Being friendly
+  friend class EC_ESM_Ops;
+  friend class EtherCAT_Router;
+  friend class EtherCAT_AL;
+  
+ public:
+  /// Constructor
+  /** @param a_ring_position position in the EtherCAT ring
+      @param a_product_code product code of the slave
+      @param a_revision revision of the slave
+      @param a_station_address address of the station as given in
+      config file
+      @param a_fmmu_config pointer to configuration of fmmus as
+      created when parsing config file
+      @param a_pd_config pointer to configuration of SM for process
+      data
+      @param a_mbx_config MBX configuration if this slave is complex.
+      Default argument is NULL for simple slaves
+  */
+  EtherCAT_SlaveHandler(EC_UINT a_ring_position,
+			EC_UDINT a_product_code,
+			EC_UDINT a_revision,
+                        EC_UDINT a_serial,
+			EC_FixedStationAddress a_station_address,
+			EtherCAT_FMMU_Config * a_fmmu_config,
+			EtherCAT_PD_Config * a_pd_config,
+			EtherCAT_MbxConfig * a_mbx_config = NULL);
+  /// Constructor using Slave Configuration
+  EtherCAT_SlaveHandler(EC_UINT a_ring_position,
+			const EtherCAT_SlaveConfig * a_sconf,
+                        EC_UDINT a_serial);
+  virtual ~EtherCAT_SlaveHandler();
+
+  /// Get position in the EtherCAT logical ring
+  EC_UINT get_ring_position() const {return m_ring_position; };
+  /// Get serial
+  EC_UDINT get_serial() const { return m_serial; };
+
+  /// Returns and increments sequence number used for duplication mailbox write dectition
+  EC_USINT get_mbx_counter();
+ protected:
+
+  /// Position in the EtherCAT logical Ring
+  EC_UINT m_ring_position;
+
+  /// Serial
+  EC_UDINT m_serial;
+
+  /// Sequence number for duplicate mailbox write detection
+  EC_USINT m_mbx_counter;
+};
+
+
+#endif //  __ethercat_slave_handler__
+
diff --git a/include/dll/ethercat_device_addressed_telegram.h ./include/dll/ethercat_device_addressed_telegram.h
new file mode 100644
index 0000000..cdc96dc
--- /dev/null
+++ ./include/dll/ethercat_device_addressed_telegram.h
@@ -0,0 +1,305 @@
+// $Id: ethercat_device_addressed_telegram.h,v 1.11 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_device_addressed_telegram_h__
+#define __ethercat_device_addressed_telegram_h__
+
+#include "ethercat_telegram.h"
+
+/// EtherCAT telegram for all _device addressing_ modes
+/** EtherCAT telegram for all _device addressing_ modes, including
+    Position Addressing Modes (e.g.~Auto Increment Physical Read--APRD),
+    Node Addressing modes (e.g.~Node addressed Physical Read--NPRD)
+    and Broadcast Adressing modes (e.g.~Broadcast read)
+    
+*/
+class Device_Addressing_Telegram : public EC_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp device address
+      @param a_ado address offset withing device
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data
+  */
+  Device_Addressing_Telegram(EC_USINT a_idx=0x00, 
+			     EC_UINT a_adp =0x0000, 
+			     EC_UINT a_ado =0x0000,
+			     EC_UINT a_wkc =0x0000,
+			     EC_UINT a_datalen=0x0000, 
+			     const unsigned char * a_data=NULL);
+
+  virtual                ~Device_Addressing_Telegram();
+
+  /// Set address pointer
+  void                    set_adp(EC_UINT a_adp) { m_adp = a_adp; }
+  /// Set address offset
+  void                    set_ado(EC_UINT a_ado) { m_ado = a_ado; }
+  /// Get address pointer
+  EC_UINT                 get_adp() const { return m_adp;}
+  /// Get address offset
+  EC_UINT                 get_ado() const { return m_ado;}
+  
+ protected:
+  virtual unsigned char * dump_header_head(unsigned char * a_buffer) const;
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const = 0;
+  
+  virtual const unsigned char * build_header_head(const unsigned char * a_buffer);
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer) = 0;
+  
+ private:
+  EC_UINT                 m_adp;
+  EC_UINT                 m_ado;
+};
+
+/// Auto Increment Physical Read Telegram (APRD)
+class APRD_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp auto increment address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be read: Is actually not used, can be initialised at all zeros
+      @note remove a_data parameter, since is it merely modified by the
+      slave (the result of the read op)??
+  */
+  APRD_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  /// Construct telegram from received bytestream...
+  // APRD_Telegram(const unsigned char * a_telegram);
+
+  virtual                ~APRD_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Auto Increment Physical Write Telegram (APWR)
+class APWR_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp auto increment address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  APWR_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~APWR_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Auto Increment Physical Read and Write Telegram (APRW)
+class APRW_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp auto increment address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be read and written
+  */
+  APRW_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~APRW_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Broadcast Write Telegram (BWR)
+class BWR_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  BWR_Telegram(EC_USINT a_idx, EC_UINT a_ado,
+	       EC_UINT a_wkc, EC_UINT a_datalen, 
+	       const unsigned char * a_data);
+			    
+  virtual                ~BWR_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Broadcast Read Telegram (BRD)
+class BRD_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be read
+  */
+  BRD_Telegram(EC_USINT a_idx, EC_UINT a_ado,
+	       EC_UINT a_wkc, EC_UINT a_datalen, 
+	       const unsigned char * a_data);
+			    
+  virtual                ~BRD_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+
+/// Node Addressed Physical Write Telegram (NPWR)
+/** @note older versions of the spec and the ethereal plugin use FPWR
+    for this type
+*/
+class NPWR_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp slave address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  NPWR_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~NPWR_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Node Addressed Physical Read Write Telegram (NPRW)
+/** @note older versions of the spec and the ethereal plugin use FPRW
+    for this type
+*/
+class NPRW_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp slave address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  NPRW_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~NPRW_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Node Addressed Physical Read Telegram (NPRD)
+/** @note older versions of the spec and the ethereal plugin use FPWR
+    for this type
+*/
+class NPRD_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp slave address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  NPRD_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~NPRD_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Auto Increment Physical Read Multiple Write Telegram (ARMW)
+class ARMW_Telegram : public Device_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adp auto increment address
+      @param a_ado physical memory address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be read/written
+  */
+  ARMW_Telegram(EC_USINT a_idx, EC_UINT a_adp, 
+		EC_UINT a_ado,EC_UINT a_wkc,
+		EC_UINT a_datalen, 
+		const unsigned char * a_data);
+			    
+  virtual                ~ARMW_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+
+#endif // __ethercat_device_addressed_telegram_h__
diff --git a/include/dll/ethercat_dll.h ./include/dll/ethercat_dll.h
new file mode 100644
index 0000000..2733181
--- /dev/null
+++ ./include/dll/ethercat_dll.h
@@ -0,0 +1,90 @@
+// $Id: ethercat_dll.h,v 1.22 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_dll__
+#define __ethercat_dll__
+
+// Forward declarations
+struct netif;
+class EtherCAT_Frame;
+
+/// Abstract representation of the EtherCAT DLL
+class EtherCAT_DataLinkLayer
+{
+  public:
+  /// This class is a singleton
+  /** @todo Pass destination MAC address instead of defaulting to
+      broadcast?
+  */
+  static EtherCAT_DataLinkLayer * instance(void);
+
+  /// Attach the DLL to a networking interface
+  /** @param netif pointer to the NIC
+   */
+  void                attach(struct netif * netif);
+
+  /// transmit and receive EtherCAT frame (blocking call!)  
+  /** @param a_frame ethercat frame to be sent
+   *  NOTE that txandrx will retry sending lost frames.
+  */
+  bool                txandrx(EtherCAT_Frame * a_frame);
+
+  /// transmit an EtherCAT frame (non-blocking call)
+  /** @param a_frame ethercat frame to be sent
+   *  @return positive or zero handle on success, negative value for error 
+   *  Successfull tx MUST be followed by rx call.
+   */
+  int tx(EtherCAT_Frame * a_frame);
+
+  /// receive an EtherCAT frame previously sent by tx() (blocking call!)
+  /** @param a_frame ethercat frame to be sent
+   *  @param a_handle handle previously returned by tx()
+   *  @return false for error/dropped packet
+   */
+  bool rx(EtherCAT_Frame * a_frame, int a_handle);
+
+  /// Destructor
+  /** @todo some kind of smart pointer concept necessary for all these
+      singletons.  For EtherCAT master on ecos not really an issue...
+  */
+  virtual            ~EtherCAT_DataLinkLayer();
+
+  protected:
+                        EtherCAT_DataLinkLayer();
+
+  private:
+    static EtherCAT_DataLinkLayer * m_instance;
+    struct netif *                  m_if;
+};
+
+#endif // __ethercat_dll__
diff --git a/include/dll/ethercat_frame.h ./include/dll/ethercat_frame.h
new file mode 100644
index 0000000..a7b7328
--- /dev/null
+++ ./include/dll/ethercat_frame.h
@@ -0,0 +1,158 @@
+// $Id: ethercat_frame.h,v 1.21 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_frame_h__
+#define __ethercat_frame_h__
+
+#include "dll/ethercat_telegram.h"
+#include "ethercat/netif.h"
+
+/** "Dump" an EtherCAT frame into an array of bytes (for
+    transmitting).
+    @param frame pointer to the frame to be dumped
+    @param buffer pointer to an array of unsigned chars that can be
+    put into an ethernet frame
+    @param bufferlength the maximum length that the frame may have
+    @return the length of the buffer expressed as a number of bytes,
+    if smaller than bufferlength, 0 otherwise
+*/
+externC int framedump(const struct EtherCAT_Frame * frame, 
+		      unsigned char * buffer, 
+		      size_t bufferlength);
+
+/** Build an EtherCAT frame from an array of bytes (for receiving).
+    @param frame pointer to the frame where data can be put in
+    @param buffer pointer to an array of unsigned chars that contain
+    the necessary info
+    @return zero on succes, -1 otherwise
+*/
+externC int framebuild(struct EtherCAT_Frame * frame, 
+		       const unsigned char * buffer);
+
+/// EtherCAT Frame Interface (we need a C interface)
+/** Due to the fact that this is a C-interface, this class does not
+    herit from EC_Datastruct, although it has the same needs
+*/
+typedef struct EtherCAT_Frame 
+{
+  /// Return the length of the whole frame
+  virtual size_t length(void) const = 0;
+  
+  /// Dump the contents of a frame into a byte array
+  virtual unsigned char *   dump(unsigned char * a_buffer) const = 0;
+
+  /// Build and check a frame from a byte array
+  /** @param a_buffer the byte array
+      @return 0 if succesful, -1 otherwise
+  */
+  virtual int build(const unsigned char * a_buffer) = 0;
+
+  /// Get first telegram
+  virtual EC_Telegram * get_telegram() const = 0;
+  
+} ECFrame;
+
+/// EtherCAT Frame base class
+/** @todo This interface is not complete, eg. currently there is no
+    way to add/remove telegrams to a frame.  Note however that this
+    EtherCAT feature is rarely used AFAIS.
+*/
+class EC_Frame: public ECFrame
+{
+ public:
+  virtual ~EC_Frame();
+  
+  /// return the length of the whole frame
+  /** @return the length of the whole frame in bytes
+   */
+  size_t length(void) const  { return header_length() + body_length();}
+  
+  /// Dump the contents of a frame into an byte array
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+  /// Build and check frame starting from byte array
+  virtual int build(const unsigned char * a_buffer);
+    
+  /// Get first telegram
+  EC_Telegram * get_telegram() const { return m_telegram;}
+      
+ protected:
+  /// Constructor
+  EC_Frame();
+  EC_Frame(const EC_Frame & a_frame);
+  EC_Frame(EC_Telegram * a_telegram);
+
+  /// Pointer to the first EtherCAT
+  EC_Telegram * m_telegram;
+  
+  /// Dump the header
+  virtual unsigned char *    dump_header(unsigned char * a_buffer) const = 0;
+  /// Check if received header in byte array complies to the frame data
+  virtual bool check_header(const unsigned char * a_buffer) const = 0;
+
+  /// Return the length of the header
+  virtual size_t             header_length(void) const = 0;
+  /// Return the length of the body
+  virtual size_t body_length(void) const;
+
+};
+
+/// Ethercat Ethernet_mode frame
+static const size_t ETHERCAT_ETHERNET_FRAME_HEADER_SIZE = 2;
+
+
+/// Class representing EtherCAT Frames in "raw" ethernet mode
+class EC_Ethernet_Frame : public EC_Frame
+{
+ public:
+  /// Constructor
+  /** @param a_telegram pointer to the first telegram of the frame */
+  EC_Ethernet_Frame(EC_Telegram * a_telegram);
+  virtual ~EC_Ethernet_Frame(){};
+
+ protected:
+  virtual size_t            header_length(void) const 
+    { return ETHERCAT_ETHERNET_FRAME_HEADER_SIZE; }
+        
+  virtual unsigned char *   dump_header(unsigned char * a_buffer) const;
+
+  virtual bool check_header(const unsigned char * a_buffer) const;
+};
+
+
+/// Ethercat UDP_mode Frame
+// FIXME TO BE IMPLEMENTED
+// class EC_UDP_Frame : public EC_Ethernet_Frame
+// redefine virtual header_length() function and 
+
+#endif // __ethercat_frame_h__
diff --git a/include/dll/ethercat_logical_addressed_telegram.h ./include/dll/ethercat_logical_addressed_telegram.h
new file mode 100644
index 0000000..bc0ec04
--- /dev/null
+++ ./include/dll/ethercat_logical_addressed_telegram.h
@@ -0,0 +1,143 @@
+// $Id: ethercat_logical_addressed_telegram.h,v 1.8 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_logical_addressed_telegram_h__
+#define __ethercat_logical_addressed_telegram_h__
+
+#include "ethercat_telegram.h"
+
+/// EtherCAT telegram for all _logical addressing_ modes
+/** EtherCAT telegram for all _logical addressing_ modes, that is
+    logical read (LRD), logical write (LWR), and logical Read-Write (LRW)    
+*/
+class Logical_Addressing_Telegram : public EC_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adr logical address (4 bytes)
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data
+  */
+  Logical_Addressing_Telegram(EC_USINT a_idx=0x00, 
+			      EC_UDINT a_adr=0x00000000, 
+			      EC_UINT a_wkc=0x0000, 
+			      EC_UINT a_datalen=0x0000, 
+			      const unsigned char * a_data = NULL);
+
+  virtual                ~Logical_Addressing_Telegram();
+
+  /// Set address field
+  /** @param a_adr 4 byte logical address
+   */
+  void                    set_adr(EC_UDINT a_adr) { m_adr = a_adr; }
+  /// Get address field
+  /** @return 4 byte logical address
+   */
+  EC_UDINT                get_adr() const { return m_adr;}
+  
+ protected:
+  virtual unsigned char * dump_header_head(unsigned char * a_buffer) const;
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const = 0;
+  
+  virtual const unsigned char * build_header_head(const unsigned char * a_buffer);
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer) = 0;
+  
+ private:
+  EC_UDINT                 m_adr;
+};
+
+/// Logical Read Telegram
+class LRD_Telegram : public Logical_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adr logical address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be read
+  */
+  LRD_Telegram(EC_USINT a_idx, EC_UDINT a_adr,
+	       EC_UINT a_wkc, EC_UINT a_datalen,
+	       const unsigned char * a_data);
+			    
+  virtual                ~LRD_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Logical Write Telegram
+class LWR_Telegram : public Logical_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adr logical address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written
+  */
+  LWR_Telegram(EC_USINT a_idx, EC_UDINT a_adr,
+	       EC_UINT a_wkc, EC_UINT a_datalen,
+	       const unsigned char * a_data);
+			    
+  virtual                ~LWR_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+/// Logical Read Write Telegram
+class LRW_Telegram : public Logical_Addressing_Telegram {
+ public:
+  /// Constructor
+  /** @param a_idx index
+      @param a_adr logical address
+      @param a_wkc working counter
+      @param a_datalen data_length
+      @param a_data data to be written and read
+  */
+  LRW_Telegram(EC_USINT a_idx, EC_UDINT a_adr,
+	       EC_UINT a_wkc, EC_UINT a_datalen,
+	       const unsigned char * a_data);
+			    
+  virtual                ~LRW_Telegram();
+
+ protected:
+  virtual unsigned char * dump_command_field(unsigned char * a_buffer) const;
+  virtual const unsigned char * build_command_field(const unsigned char * a_buffer);
+};
+
+#endif // __ethercat_logical_addressed_telegram_h__
diff --git a/include/dll/ethercat_slave_memory.h ./include/dll/ethercat_slave_memory.h
new file mode 100644
index 0000000..71bf82a
--- /dev/null
+++ ./include/dll/ethercat_slave_memory.h
@@ -0,0 +1,648 @@
+// $Id: ethercat_slave_memory.h,v 1.25 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_slave_memory_h__
+#define __ethercat_slave_memory_h__
+
+#include "ethercat/ethercat_defs.h"
+#include "ethercat/ethercat_log.h"
+#include "ethercat/ethercat_datastruct.h"
+#include <stdio.h>
+#include <cassert>
+
+// Describes registers of EtherCAT slave controller
+static const size_t EC_DLInformationSize = 0xa; // 10 bytes
+
+// Product code and revision offset in SII Eeprom data 
+/* BIG FAT WARNING:  THIS VARIES FROM WHAT IS WRITTEN IN THE ETHERCAT
+   SPEC VERSION 1.0!!!
+*/
+static const EC_UDINT EC_ProductCodeAddressInSII = 0x0000000a;
+static const EC_UDINT EC_RevisionAddressInSII = 0x0000000c;
+static const EC_UDINT EC_SerialAddressInSII = 0x0000000e;
+
+typedef enum {
+  Type = 0,
+  Revision,
+  Build,
+  Num_FMMUs,
+  Num_Sync_Managers,
+  RAM_Size,
+  ECAT_Station_Address,
+  DLL_Control,
+  DLL_Status,
+  AL_Control,
+  AL_Status,
+  PDI_Control,
+  PDI_Conf_reg,
+  AL_Event,
+  RX_Error_Counter_Channel_A,
+  RX_Error_Counter_Channel_B,
+  Watchdog_Divider,
+  Watchdog_Time_PDI,
+  Watchdog_Time_Channel_0,
+  Watchdog_Time_Channel_1,
+  Watchdog_Time_Channel_2,
+  Watchdog_Time_Channel_3,
+  Watchdog_Time_Channel_4,
+  Watchdog_Time_Channel_5,
+  Watchdog_Time_Channel_6,
+  Watchdog_Time_Channel_7,
+  Watchdog_Time_Channel_8,
+  Watchdog_Time_Channel_9,
+  Watchdog_Time_Channel_10,
+  Watchdog_Time_Channel_11,
+  Watchdog_Time_Channel_12,
+  Watchdog_Time_Channel_13,
+  Watchdog_Time_Channel_14,
+  Watchdog_Time_Channel_15,
+  Watchdog_Channel_status,
+  SII_Size,
+  SII_ControlStatus,
+  SII_Address,
+  SII_Data,
+  FMMU_0,
+  FMMU_1,
+  FMMU_2,
+  FMMU_3,
+  FMMU_4,
+  FMMU_5,
+  FMMU_6,
+  FMMU_7,
+  FMMU_8,
+  FMMU_9,
+  FMMU_10,
+  FMMU_11,
+  FMMU_12,
+  FMMU_13,
+  FMMU_14,
+  FMMU_15,
+  Sync_Manager_0,
+  Sync_Manager_1,
+  Sync_Manager_2,
+  Sync_Manager_3,
+  Sync_Manager_4,
+  Sync_Manager_5,
+  Sync_Manager_6,
+  Sync_Manager_7,
+  Sync_Manager_8,
+  Sync_Manager_9,
+  Sync_Manager_10,
+  Sync_Manager_11,
+  Sync_Manager_12,
+  Sync_Manager_13,
+  Sync_Manager_14,
+  Sync_Manager_15,
+  NumRegisters,
+} ECAT_Slave_Registers;
+
+typedef enum {
+  EC_R = 0, // Read access only
+  EC_W = 1, // Write access only
+  EC_RW = 2 // RW accesc
+} ECAT_Register_Access;
+
+
+
+/// EtherCAT Slave Register data
+typedef struct
+{
+  /// Register name
+  const char * name; 
+  /// Register offset addres
+  const EC_UINT ado; 
+  /// Access of the master to the register (r, w, or r/w)
+  const ECAT_Register_Access ECAT_access;
+  /// Access of the slave to the register (r, w, or r/w)
+  const ECAT_Register_Access uC_access;
+  /// Size of the register area (expressed as number of bytes)
+  const EC_USINT size; 
+} ECAT_Slave_Register_Data;
+
+
+
+static const ECAT_Slave_Register_Data EC_Slave_RD[NumRegisters] = {
+  {"Type", 0x0000, EC_R, EC_R, 0x01},
+  {"Revision", 0x0001, EC_R, EC_R, 0x01},
+  {"Build",0x0002, EC_R, EC_R, 0x02},
+  {"Number of FMMUs",0x0004,EC_R, EC_R, 0x01},
+  {"Number of Sync Managers",0x0005,EC_R, EC_R, 0x01},
+  {"RAM Size",0x0006,EC_R, EC_R, 0x01},
+  {"EtherCAT Station Address",0x0010,EC_RW,EC_R,0x02},
+  {"DLL Control Register",0x0100,EC_RW,EC_R,0x02},
+  {"DLL Status Register",0x0110,EC_R,EC_R,0x02},
+  {"AL Control Register",0x0120,EC_RW,EC_R,0x02},
+  {"AL Status Register",0x0130,EC_R,EC_RW,0x02},
+  {"PDI Control Register",0x0140,EC_R,EC_R,0x02},
+  {"PDI Config Register",0x0150,EC_R,EC_R,0x05},
+  {"AL Event Register",0x0220,EC_R,EC_R,0x04},
+  {"RX Error Counter Channel A",0x0300,EC_RW,EC_R,0x02},
+  {"RX Error Counter Channel B",0x0302,EC_RW,EC_R,0x02},
+  {"Watchdog divider",0x0400,EC_RW,EC_R,0x02},
+  {"Watchdog Time PDI",0x0410,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 0",0x0420,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 1",0x0422,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 2",0x0424,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 3",0x0426,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 4",0x0428,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 5",0x042a,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 6",0x042c,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 7",0x042e,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 8",0x0430,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 9",0x0432,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 10",0x0434,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 11",0x0436,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 12",0x0438,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 13",0x043a,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 14",0x043c,EC_RW,EC_R,0x02},
+  {"Watchdog Time Channel 15",0x043e,EC_RW,EC_R,0x02},
+  {"Watchdog Channel status",0x0450,EC_R,EC_R,0x02},
+  {"SII Eeprom Size",0x0500,EC_R,EC_R,0x02},
+  {"SII Control/Status",0x0502,EC_RW,EC_R,0x02},
+  {"SII Address",0x0504,EC_RW,EC_R,0x04},
+  {"SII Data",0x0508,EC_RW,EC_R,0x04},
+  {"FMMU0",0x0600,EC_RW,EC_R,0x10}, 
+  {"FMMU1",0x0610,EC_RW,EC_R,0x10}, 
+  {"FMMU2",0x0620,EC_RW,EC_R,0x10}, 
+  {"FMMU3",0x0630,EC_RW,EC_R,0x10}, 
+  {"FMMU4",0x0640,EC_RW,EC_R,0x10}, 
+  {"FMMU5",0x0650,EC_RW,EC_R,0x10}, 
+  {"FMMU6",0x0660,EC_RW,EC_R,0x10}, 
+  {"FMMU7",0x0670,EC_RW,EC_R,0x10}, 
+  {"FMMU8",0x0680,EC_RW,EC_R,0x10}, 
+  {"FMMU9",0x0690,EC_RW,EC_R,0x10}, 
+  {"FMMU10",0x06A0,EC_RW,EC_R,0x10},
+  {"FMMU11",0x06B0,EC_RW,EC_R,0x10},
+  {"FMMU12",0x06C0,EC_RW,EC_R,0x10},
+  {"FMMU13",0x06D0,EC_RW,EC_R,0x10},
+  {"FMMU14",0x06E0,EC_RW,EC_R,0x10},
+  {"FMMU15",0x06F0,EC_RW,EC_R,0x10},
+  {"Sync Manager 0",0x0800,EC_RW,EC_R,0x08},
+  {"Sync Manager 1",0x0808,EC_RW,EC_R,0x08},
+  {"Sync Manager 2",0x0810,EC_RW,EC_R,0x08},
+  {"Sync Manager 3",0x0818,EC_RW,EC_R,0x08},
+  {"Sync Manager 4",0x0820,EC_RW,EC_R,0x08},
+  {"Sync Manager 5",0x0828,EC_RW,EC_R,0x08},
+  {"Sync Manager 6",0x0830,EC_RW,EC_R,0x08},
+  {"Sync Manager 7",0x0838,EC_RW,EC_R,0x08},
+  {"Sync Manager 8",0x0840,EC_RW,EC_R,0x08},
+  {"Sync Manager 9",0x0848,EC_RW,EC_R,0x08},
+  {"Sync Manager 10",0x0850,EC_RW,EC_R,0x08},
+  {"Sync Manager 11",0x0858,EC_RW,EC_R,0x08},
+  {"Sync Manager 12",0x0860,EC_RW,EC_R,0x08},
+  {"Sync Manager 13",0x0868,EC_RW,EC_R,0x08},
+  {"Sync Manager 14",0x0870,EC_RW,EC_R,0x08},
+  {"Sync Manager 15",0x0878,EC_RW,EC_R,0x08}
+};
+
+
+static inline int FMMUx(int channel)
+{
+  switch(channel) {
+  case 0 : return FMMU_0; break;
+  case 1 : return FMMU_1; break;
+  case 2 : return FMMU_2; break;
+  case 3 : return FMMU_3; break;
+  case 4 : return FMMU_4; break;
+  case 5 : return FMMU_5; break;
+  case 6 : return FMMU_6; break;
+  case 7 : return FMMU_7; break;
+  case 8 : return FMMU_8; break;
+  case 9 : return FMMU_9; break;
+  case 10 : return FMMU_10; break;
+  case 11 : return FMMU_11; break;
+  case 12 : return FMMU_12; break;
+  case 13 : return FMMU_13; break;
+  case 14 : return FMMU_14; break;
+  case 15 : return FMMU_15; break;
+  default:
+    ec_log(EC_LOG_ERROR, "FMMUx: No such channel %d\n",channel);
+    return -1;
+  }
+}
+
+static inline int Sync_Managerx(int channel)
+{
+  switch(channel) {
+  case 0 : return Sync_Manager_0; break;
+  case 1 : return Sync_Manager_1; break;
+  case 2 : return Sync_Manager_2; break;
+  case 3 : return Sync_Manager_3; break;
+  case 4 : return Sync_Manager_4; break;
+  case 5 : return Sync_Manager_5; break;
+  case 6 : return Sync_Manager_6; break;
+  case 7 : return Sync_Manager_7; break;
+  case 8 : return Sync_Manager_8; break;
+  case 9 : return Sync_Manager_9; break;
+  case 10 : return Sync_Manager_10; break;
+  case 11 : return Sync_Manager_11; break;
+  case 12 : return Sync_Manager_12; break;
+  case 13 : return Sync_Manager_13; break;
+  case 14 : return Sync_Manager_14; break;
+  case 15 : return Sync_Manager_15; break;
+  default:
+    ec_log(EC_LOG_ERROR, "Sync_Managerx: No such channel %d\n",channel);
+    return -1;
+  }
+}
+
+static inline int Watchdog_Time_Channelx(int channel)
+{
+  switch(channel) {
+  case 0 : return Watchdog_Time_Channel_0; break;
+  case 1 : return Watchdog_Time_Channel_1; break;
+  case 2 : return Watchdog_Time_Channel_2; break;
+  case 3 : return Watchdog_Time_Channel_3; break;
+  case 4 : return Watchdog_Time_Channel_4; break;
+  case 5 : return Watchdog_Time_Channel_5; break;
+  case 6 : return Watchdog_Time_Channel_6; break;
+  case 7 : return Watchdog_Time_Channel_7; break;
+  case 8 : return Watchdog_Time_Channel_8; break;
+  case 9 : return Watchdog_Time_Channel_9; break;
+  case 10 : return Watchdog_Time_Channel_10; break;
+  case 11 : return Watchdog_Time_Channel_11; break;
+  case 12 : return Watchdog_Time_Channel_12; break;
+  case 13 : return Watchdog_Time_Channel_13; break;
+  case 14 : return Watchdog_Time_Channel_14; break;
+  case 15 : return Watchdog_Time_Channel_15; break;
+  default:
+    ec_log(EC_LOG_ERROR, "Watchdog_Time_Channelx: No such channel %d\n",channel);
+    return -1;
+  }
+}
+
+/// EtherCAT Data Layer Information 
+class EC_DLInformation : public EC_DataStruct
+{
+ public:
+  EC_DLInformation(EC_USINT type,
+		   EC_USINT revision,
+		   EC_UINT build,
+		   EC_USINT no_of_supp_fmmu_channels,
+		   EC_USINT no_of_supp_syncman_channels,
+		   EC_USINT ram_size,
+		   bool fmmu_bit_operation_not_supp);
+  EC_DLInformation(const unsigned char * a_buffer);
+  virtual ~EC_DLInformation(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+  EC_USINT Type;
+  EC_USINT Revision;
+  EC_UINT Build;
+  EC_USINT NoOfSuppFmmuChannels;
+  EC_USINT NoOfSuppSyncManChannels;
+  EC_USINT RamSize;
+  // EC_USINT Reserved1;
+  bool FmmuBitOperationNotSupp;
+  // EC_UINT Reserved2;
+  // EC_USINT Reserved3;
+};
+
+/// EtherCAT Fixed Station Address
+class EC_FixedStationAddress : public EC_DataStruct
+{
+ public:
+  EC_FixedStationAddress(EC_UINT fixed_station_address = 0x0000) :
+    EC_DataStruct(EC_Slave_RD[ECAT_Station_Address].size), FixedStationAddress(fixed_station_address){};
+  virtual ~EC_FixedStationAddress(){};
+  EC_FixedStationAddress(const unsigned char * data) :
+    EC_DataStruct(EC_Slave_RD[ECAT_Station_Address].size) { nw2host(data,FixedStationAddress); }
+
+  virtual unsigned char * dump(unsigned char * a_buffer) const { return host2nw(a_buffer, FixedStationAddress); }
+
+  void operator = (const EC_FixedStationAddress & ad){
+    this->FixedStationAddress = ad.FixedStationAddress;
+  }
+  bool operator ==(const EC_FixedStationAddress & ad) const{
+    return (this->FixedStationAddress == ad.FixedStationAddress);
+  }
+  operator EC_UINT() const { return FixedStationAddress; }
+ private:
+  /// Fixed Station Address
+  EC_UINT FixedStationAddress;
+};
+ 
+/* class EC_DLControl : public EC_DataStruct */
+/* { */
+/*   // fixme todo   */
+/* }; */
+
+
+/* class EC_DLStatus : public EC_DataStruct */
+/* { */
+/* }; */
+
+// EtherCAT states
+typedef enum 
+{
+  EC_INIT_STATE = 0x01,
+  EC_PREOP_STATE = 0x02,
+  EC_BOOTSTRAP_STATE = 0x03,
+  EC_SAFEOP_STATE = 0x04,
+  EC_OP_STATE = 0x08
+} EC_State;
+
+/// AL Control register
+class EC_ALControl : public EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param state EtherCAT state:  Can be one of the following:
+      EC_INIT_STATE,  EC_PREOP_STATE, EC_BOOTSTRAP_STATE,
+      EC_SAFEOP_STATE, EC_OP_STATE 
+      @param ack Acknowledge
+      @note The bootstrap state is currently unimplemented
+   */
+  EC_ALControl(EC_State state = EC_INIT_STATE, 
+	       bool ack       =false);
+  /// Constructor: build from data array
+  EC_ALControl(const unsigned char * a_buffer);
+  virtual ~EC_ALControl(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+  EC_State State; // 4 bits
+  bool Acknowledge; // 1 bit
+  // EC_USINT ApplSpecific; // 8 bits
+};
+
+/// AL Status register
+class EC_ALStatus : public EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param state EtherCAT state:  Can be one of the following:
+      EC_INIT_STATE,  EC_PREOP_STATE, EC_BOOTSTRAP_STATE,
+      EC_SAFEOP_STATE, EC_OP_STATE 
+      @param change Change
+   */
+  EC_ALStatus(EC_State state = EC_INIT_STATE, 
+	      bool change    = false);
+  /// Constructor: build from data array
+  EC_ALStatus(const unsigned char * a_buffer);
+  virtual ~EC_ALStatus(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+
+  EC_State State; // 4 bits
+  bool Change; // 1 bit
+  // EC_USINT ApplSpecific; // 8 bits
+};
+
+/* class EC_PDIControl : public EC_DataStruct */
+/* { */
+/* }; */
+
+// fixme EC_PDIConfigurationMCI16
+// fixme EC_PDIConfigurationMCI16
+// fixme EC_ALEvent
+// fixme statistics and watchdogs
+
+/// Slave Information Interface Control/Status
+class EC_SIIControlStatus : public EC_DataStruct
+{
+ public:
+  /// Constructor (see spec for args)
+  EC_SIIControlStatus(bool eeprom_write_access = false,
+		      bool eeprom_address_algorithm = false,
+		      bool read_op = false,
+		      bool write_op = false,
+		      bool reload_op = false,
+		      bool write_error = false,
+		      bool busy = false);
+  /// Constructor: build from data array
+  EC_SIIControlStatus(const unsigned char * a_buffer);
+  virtual ~EC_SIIControlStatus(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+  
+  /// Write access?
+  bool EepromWriteAccess;
+  /// ?? FIXME meaning?
+  bool EepromAddressAlgorithm; 
+  /// Read Operation?
+  bool ReadOp;
+  /// Write Operation?
+  bool WriteOp;
+  /// Reload Operation?
+  bool ReloadOp; 
+  /// Write Error?
+  bool WriteError;
+  /// Eeprom busy?
+  bool Busy;
+  // Acknowledge Error
+  bool AcknowledgeError;
+};
+
+/// Class representing a bit position within a byte
+class EC_BitPos
+{
+public:
+  /// Constructor
+  /** @param a_int Bit position in the byte (an int from 0 to 7)
+   */
+  EC_BitPos(EC_USINT a_int = 0){
+    // There are only 8 bits in a byte...
+    assert(a_int < 8);
+    m_bitpos = a_int;
+  }
+  virtual ~EC_BitPos(){};
+  /// Cast operator
+  operator EC_USINT() const {return m_bitpos;}
+private:
+  EC_USINT m_bitpos;
+};
+
+/// EtherCAT FMMU
+class EC_FMMU : public EC_DataStruct
+{
+ public:
+  /// Constructor (see spec for params)
+  EC_FMMU(EC_UDINT  logical_start_address = 0x00000000,
+	  EC_UINT   length                = 0x0000,
+	  EC_BitPos logical_start_bit     = 0x00,
+	  EC_BitPos logical_end_bit       = 0x00,
+	  EC_UINT   physical_start_address= 0x0000,
+	  EC_BitPos physical_start_bit    = 0x00,
+	  bool      read_enable           = false,
+	  bool      write_enable          = false,
+	  bool      channel_enable        = false);
+  /// Constructor: build from data array
+  EC_FMMU(const unsigned char * a_buffer);
+  virtual ~EC_FMMU(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+  
+  EC_UDINT  LogicalStartAddress;
+  EC_UINT   Length;
+  EC_BitPos LogicalStartBit; 
+  // EC_USINT  Reserved1; // 5 bits
+  EC_BitPos LogicalEndBit;
+  // EC_UINT   Reserved2; // 5 bits;
+  EC_UINT   PhysicalStartAddress;
+  EC_BitPos PhysicalStartBit;
+  // EC_USINT  Reserved3; // 5 bits
+  bool ReadEnable;
+  bool WriteEnable;
+  // EC_USINT  Reserved4; // 6 bits
+  bool ChannelEnable;
+  // EC_USINT  Reserved5; // 7 bits
+  // EC_USINT Reserved6; // 1 byte
+  // EC_UINT  Reserved7; // 2 bytes
+};
+
+// ==================================================
+
+typedef enum
+{
+  EC_BUFFERED = 0x00,
+  EC_QUEUED = 0x02,
+} ECBufferType;
+
+/// Class representing queued or buffered Syncman buffertypes
+/** @see EC_SyncMan
+ */
+class EC_BufferType
+{
+ public:
+  /// Constructor
+  /** @param bt Buffertype (buffered (EC_BUFFERED) or queued (EC_QUEUED)
+   */
+  EC_BufferType(ECBufferType bt = EC_BUFFERED){
+    m_buffertype = (EC_USINT) bt;
+  }
+  virtual ~EC_BufferType(){};
+  /// Cast operator
+  operator EC_USINT() const {return m_buffertype;}
+private:
+  EC_USINT m_buffertype;
+};
+
+typedef enum
+{
+  EC_READ_FROM_MASTER = 0x00,
+  EC_WRITTEN_FROM_MASTER = 0x01,
+} ECDirection;
+
+/// Class representing read/write direction of Syncman buffer
+/** @see EC_SyncMan
+ */
+class EC_Direction
+{
+ public:
+  /// Constructor
+  /** @param dir R/W direction of Sync Manager Channel.  Possible
+      values are
+      - "Memory is read from Master" (EC_READ_FROM_MASTER) and 
+      - "Memory is written from Master" (EC_WRITTEN_FROM_MASTER) 
+  */
+  EC_Direction(ECDirection dir = EC_READ_FROM_MASTER){
+    m_direction = (EC_USINT) dir;
+  }
+  virtual ~EC_Direction(){};
+  /// Cast operator
+  operator EC_USINT() const {return m_direction;}
+private:
+  EC_USINT m_direction;
+};
+
+typedef enum {
+  EC_FIRST_BUFFER = 0x00,
+  EC_SECOND_BUFFER = 0x01,
+  EC_THIRD_BUFFER = 0x02,
+  EC_LOCKED_BUFFER = 0x03,
+} ECBufferedState;
+
+/// Class representing buffered state of a SyncMan
+/** @see EC_SyncMan
+ */
+class EC_BufferedState
+{
+ public:
+  /// Constructor
+  /** @param state Buffered state of the Sync Manager Channel.
+      Possible values are
+      - EC_FIRST_BUFFER, 
+      - EC_SECOND_BUFFER,
+      - EC_THIRD_BUFFER, 
+      - EC_LOCKED_BUFFER
+  */
+  EC_BufferedState(ECBufferedState state = EC_FIRST_BUFFER){
+    m_buffered_state = (EC_USINT) state;
+  }
+  virtual ~EC_BufferedState(){};
+  /// Cast operator
+  operator EC_USINT() const {return m_buffered_state;}
+private:
+  EC_USINT m_buffered_state;
+};
+
+static const bool EC_QUEUED_STATE_READ = false;
+static const bool EC_QUEUED_STATE_WRITTEN = true;
+
+/// EtherCAT Sync Manager
+class EC_SyncMan : public EC_DataStruct
+{
+ public:
+  /// Constructor (see spec for arguments)
+  EC_SyncMan(EC_UINT physical_start_address = 0x0000,
+	     EC_UINT length                 = 0x0000,
+	     EC_BufferType buffer_type      = EC_BUFFERED,
+	     EC_Direction direction         = EC_READ_FROM_MASTER,
+	     bool AL_event_enable           = false,
+	     bool watchdog_enable           = false,
+	     bool write_event               = false,
+	     bool read_event                = false,
+             bool watchdog_trigger          = false,
+	     bool queued_state              = EC_QUEUED_STATE_READ,
+	     EC_BufferedState buffered_state= EC_FIRST_BUFFER,
+	     bool ChannelEnable             = false);
+  /// Constructor: build from data array
+  EC_SyncMan(const unsigned char * a_buffer);
+  virtual ~EC_SyncMan(){};
+  virtual unsigned char * dump(unsigned char * a_buffer) const;
+  
+  EC_UINT PhysicalStartAddress;
+  EC_UINT Length;
+  EC_BufferType BufferType;
+  EC_Direction Direction;
+  bool ALEventEnable;
+  bool ECATEventEnable;
+  bool WatchdogEnable;
+  bool WriteEvent;
+  bool ReadEvent;
+  bool WatchdogTrigger;
+  bool QueuedState;
+  EC_BufferedState BufferedState;
+  bool ChannelEnable;
+};
+
+// fixme distributed clock stuff
+
+#endif // __ethercat_slave_memory_h__
diff --git a/include/dll/ethercat_telegram.h ./include/dll/ethercat_telegram.h
new file mode 100644
index 0000000..b496acd
--- /dev/null
+++ ./include/dll/ethercat_telegram.h
@@ -0,0 +1,131 @@
+// $Id: ethercat_telegram.h,v 1.28 2005/06/17 13:12:38 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_telegram_h__
+#define __ethercat_telegram_h__
+
+#include "ethercat/ethercat_defs.h"
+#include "ethercat/ethercat_datastruct.h"
+
+// Header size of telegram expressed as a number of bytes
+static const size_t ETHERCAT_TELEGRAM_HEADER_SIZE = 10;
+// Tail size of telegram expressed as a number of bytes
+static const size_t ETHERCAT_TELEGRAM_WKC_SIZE = 2;
+
+/// EtherCat Telegram Base class
+/** This class should never be used explicitly, only use the
+    interface.  Therefore its constructor is protected.  The names are
+    chosen according to the Ethercat spec.
+*/
+class EC_Telegram : public EC_DataStruct
+{
+ public:
+  virtual                ~EC_Telegram();
+
+  // redefine pure virtual
+  unsigned char *         dump(unsigned char * a_buffer) const;
+  /// Build and check telegram from data array
+  const unsigned char *   build(const unsigned char * a_buffer);
+
+  /// Set working counter
+  void                    set_wkc(EC_UINT a_wkc) { m_wkc = a_wkc; }
+  /// Set index
+  void                    set_idx(EC_USINT a_idx) { m_idx = a_idx; }
+  /// Get working counter
+  EC_UINT                 get_wkc(void) const { return m_wkc; }
+  /// Get index
+  EC_USINT                get_idx(void) const { return m_idx; }
+  /// Get pointer to data
+  const unsigned char *   get_data(void) const { return m_data; }
+  /// Set data
+  void                    set_data(const unsigned char * a_data){ m_data = a_data;}
+  /// Get data length
+  size_t                  get_datalen(void) const {return (length() - 
+							   ETHERCAT_TELEGRAM_HEADER_SIZE -
+							   ETHERCAT_TELEGRAM_WKC_SIZE);}
+  /// Set data length
+  void                    set_datalen(size_t len) { m_data_length = len  + 
+						      ETHERCAT_TELEGRAM_HEADER_SIZE +
+						      ETHERCAT_TELEGRAM_WKC_SIZE; }
+
+  /// attach telegram to this one - ordering is somewhat arbitrary
+  void attach(EC_Telegram *a_telegram);
+
+  /// Pointer to next telegram
+  EC_Telegram *   next;
+  /// Pointer to previous telegram
+  EC_Telegram *   previous;
+      
+  protected:
+  EC_Telegram(size_t a_datasize = 0, const unsigned char * a_data = NULL);
+  EC_Telegram(EC_USINT a_idx, EC_UINT a_wkc);
+  EC_Telegram(size_t a_datasize, const unsigned char * a_data,
+	      EC_USINT a_idx, EC_UINT a_wkc);
+
+  EC_Telegram(const EC_Telegram& a_telegram);
+
+  /// Dump first 6 bytes of the header (varying across different telegrams)
+  /** @param a_buffer Adress to start writing
+      @return Address to continu writing
+  */
+  virtual unsigned char * dump_header_head(unsigned char * a_buffer) const = 0;
+  /// Build and check first 6 bytes of the header (varying across
+  /// different telegrams)
+  /** @param a_buffer Adress to start writing
+      @return Address to continu writing
+  */
+  virtual const unsigned char * build_header_head(const unsigned char * a_buffer) = 0;
+
+  virtual bool            check_index(const unsigned char * buffer) const;
+  virtual bool            check_lennext(const unsigned char * buffer) const;
+
+ protected:
+  /// Pointer to data field
+  const unsigned char *   m_data;
+  // Length of data field
+  //  size_t                  m_datalength;
+  /// Index Field
+  EC_USINT                m_idx;
+  /// Working counter Field
+  EC_UINT                 m_wkc;
+  /// IRQ Field (currently unused)
+  static const EC_UINT          m_irq;
+
+  virtual size_t          header_length(void)const { return ETHERCAT_TELEGRAM_HEADER_SIZE; }
+  virtual size_t          tail_length(void)const { return ETHERCAT_TELEGRAM_WKC_SIZE; }
+
+ private:
+  virtual const unsigned char * build_body(const unsigned char * a_buffer);
+};
+
+#endif // __ethercat_telegram_h__
diff --git a/include/ethercat/arch-RTnet/ethercat/ethercat_datastruct.h ./include/ethercat/arch-RTnet/ethercat/ethercat_datastruct.h
new file mode 100644
index 0000000..1256969
--- /dev/null
+++ ./include/ethercat/arch-RTnet/ethercat/ethercat_datastruct.h
@@ -0,0 +1,72 @@
+// $Id: ethercat_datastruct.h,v 1.5 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// fixme include copyright notice
+
+#ifndef __ethercat_ds_h
+#define __ethercat_ds_h
+
+/// Base class for all EtherCAT register area data structs
+/** The main purpose of this class is to serialize and deserialize
+    data.
+*/
+class EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param a_data_length data length expressed as a number of bytes
+   */
+  EC_DataStruct(size_t a_data_length) : m_data_length(a_data_length){};
+
+  /// Destructor
+  virtual ~EC_DataStruct(){};
+
+  // default copy constructor will do...
+
+  /// Return length of data array expressed as a number of bytes
+  /** @return the number of bytes
+   */
+  size_t length() const {return m_data_length;} 
+
+  /// Dump the data struct into an array (EtherCAT Little Endian)
+  /** @param a_buffer where data should be dumped
+      @return pointer just beyond the array
+  */
+  virtual unsigned char * dump(unsigned char * a_buffer) const = 0;
+
+ protected:
+  /// Length of data array expressed as a number of bytes
+  size_t m_data_length;
+};
+
+#endif // __ethercat_ds_h
diff --git a/include/ethercat/arch-RTnet/ethercat/ethercat_defs.h ./include/ethercat/arch-RTnet/ethercat/ethercat_defs.h
new file mode 100644
index 0000000..04f4797
--- /dev/null
+++ ./include/ethercat/arch-RTnet/ethercat/ethercat_defs.h
@@ -0,0 +1,179 @@
+// $Id: ethercat_defs.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_defs_h__
+#define __ethercat_defs_h__
+
+// NOTE: Contrary to all logic ethercat data is transmitted in Little
+// Endian!
+
+#include <stdint.h>
+/*#ifdef __cplusplus
+extern "C" {
+#define __KERNEL__
+#endif
+#include <asm/types.h>
+#include <linux/byteorder/little_endian.h>
+#ifdef __cplusplus
+#undef __KERNEL__
+}
+#endif
+*/
+#include <string.h>
+
+typedef int8_t   EC_SINT;
+typedef uint8_t  EC_USINT;
+typedef int16_t  EC_INT;
+typedef uint16_t EC_UINT;
+typedef int32_t  EC_DINT;
+typedef uint32_t EC_UDINT;
+
+inline uint16_t le16_to_cpu(uint16_t data){return data;}
+inline uint16_t le16_to_cpu(int16_t data){return (uint16_t)data;}
+inline uint32_t le32_to_cpu(uint32_t data){return data;}
+inline uint32_t le32_to_cpu(int32_t data){return (uint32_t)data;}
+
+inline uint16_t cpu_to_le16(uint16_t data){return data;}
+inline uint16_t cpu_to_le16(int16_t data){return (uint16_t)data;}
+inline uint32_t cpu_to_le32(uint32_t data){return data;}
+inline uint32_t cpu_to_le32(int32_t data){return (uint32_t)data;}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_SINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_USINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_INT a_value) {
+  uint16_t tmp = cpu_to_le16(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UINT a_value) {
+  uint16_t tmp = cpu_to_le16(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_DINT a_value) {
+  uint32_t tmp = cpu_to_le32(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UDINT a_value) {
+  uint32_t tmp = cpu_to_le32(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, const unsigned char * a_data, size_t a_datalen) {
+  memcpy(a_buffer, a_data, a_datalen);
+  return a_buffer + a_datalen;
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_SINT& a_value) {
+  a_value = static_cast<EC_SINT>(*a_data);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_USINT& a_value) {
+  a_value=  static_cast<EC_USINT>(*a_data);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_INT& a_value) {
+  uint16_t tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = le16_to_cpu(tmp);
+
+  a_value = static_cast<EC_INT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UINT& a_value) {
+  uint16_t tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = le16_to_cpu(tmp);
+
+  a_value = tmp; //reinterpret_cast<EC_UINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_DINT& a_value) {
+  uint32_t tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = le32_to_cpu(tmp);
+
+  a_value = static_cast<EC_DINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UDINT& a_value) {
+  uint32_t tmp;
+  memcpy(&tmp, a_data,sizeof(tmp));
+  tmp = le32_to_cpu(tmp);
+
+  a_value = static_cast<EC_UDINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+/*
+inline const unsigned char * nw2host(const unsigned char * a_data, size_t a_datalen) {
+  return a_data + a_datalen;
+}
+
+
+inline const unsigned char * nw2host_int(const unsigned char * a_data, EC_UDINT& a_value) {
+  uint32_t tmp;
+  memcpy(&tmp, a_data,sizeof(tmp));
+  tmp = le32_to_cpu(tmp);
+
+  a_value = static_cast<EC_UDINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+
+inline const unsigned char * nw2host_arr(const unsigned char * a_data, size_t a_datalen) {
+  return a_data + a_datalen;
+}
+*/
+
+
+
+#endif // __ethercat_defs_h__
diff --git a/include/ethercat/arch-RTnet/ethercat/ethercat_log.h ./include/ethercat/arch-RTnet/ethercat/ethercat_log.h
new file mode 100644
index 0000000..6696d7a
--- /dev/null
+++ ./include/ethercat/arch-RTnet/ethercat/ethercat_log.h
@@ -0,0 +1,48 @@
+// $Id: ethercat_log.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_log_h__
+#define __ethercat_log_h__
+
+#include <stdio.h>
+
+#define EC_LOG_INFO      3
+#define EC_LOG_WARNING   2
+#define EC_LOG_ERROR     1
+#define EC_LOG_FATAL     0
+
+// Redefine this function if not using eCos...
+#define ec_log(level, args...) \
+  if (level <= EC_LOG_FATAL) fprintf(stderr, args)
+
+#endif // __ethercat_log_h__
diff --git a/include/ethercat/arch-RTnet/ethercat/ethercat_xenomai_drv.h ./include/ethercat/arch-RTnet/ethercat/ethercat_xenomai_drv.h
new file mode 100644
index 0000000..00a3d74
--- /dev/null
+++ ./include/ethercat/arch-RTnet/ethercat/ethercat_xenomai_drv.h
@@ -0,0 +1,50 @@
+// $Id:$
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+
+#ifndef ethercat_xenomai_drv_h
+#define ethercat_xenomai_drv_h
+#include <ethercat/netif.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+	int set_socket_timeout(struct netif* , int64_t ); // change the timeout (in ns)
+  	struct netif* init_ec(const char *);	// create an EtharCAT network interface
+	int close_socket(struct netif*);		// close the used socket
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
diff --git a/include/ethercat/arch-RTnet/ethercat/netif.h ./include/ethercat/arch-RTnet/ethercat/netif.h
new file mode 100644
index 0000000..1b7ea9b
--- /dev/null
+++ ./include/ethercat/arch-RTnet/ethercat/netif.h
@@ -0,0 +1,224 @@
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+#ifndef __netif_h__
+#define __netif_h__
+
+// Forward declarations
+struct EtherCAT_Frame;
+struct netif;
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#define ETHERCAT_DEVICE_NAME_MAX_LENGTH 256
+// Size of MAC adresses expressed as a number of bytes 
+#define MAC_ADDRESS_SIZE 6 
+
+// Function prototypes
+#ifdef __cplusplus
+#define externC extern "C"
+#else
+
+#define externC
+#endif
+
+
+typedef char BOOL;
+#define FALSE 0
+#define TRUE 1
+
+
+externC void if_attach(struct netif * netif);
+externC int framedump(const struct EtherCAT_Frame * frame, unsigned char * buffer, size_t bufferlength);
+externC int framebuild(struct EtherCAT_Frame * frame, const unsigned char * buffer);
+
+
+// Number of outstanding packets to keep track of 
+#define PKT_LIST_SIZE 128
+
+// Number of buffers to hold recieved packets
+#define BUF_LIST_SIZE 16
+
+// Should be < number of RX buffers
+#define MAX_UNCLAIMED_PACKETS (BUF_LIST_SIZE-1)
+
+
+// buffer to hold recieved packets
+struct pkt_buf {
+  // True if the buffer is being used
+  BOOL is_free;
+  // buffer for to store ethernet message
+  // more than enough to hold any type of message
+  unsigned char data[2000];
+};
+
+// record of packet that has been sent but.
+//  1. has not received reply
+//      .... OR ....
+//  2. has not been claimed by higher level software
+struct outstanding_pkt {
+  // whether this record is holding an outstanding packet or not
+  BOOL is_free;  
+
+  // pointer to received packet buffer
+  // If this is NULL if the packet has not been received
+  struct pkt_buf *buf;  
+
+  // The source MAC address is used to keep track of
+  // which packet belongs where
+  u_int8_t  ether_shost[MAC_ADDRESS_SIZE];
+
+  // EtherCAT_Frame that was use to generate the sent packet...
+  // The exact same frame must be used to pickup the packet
+  struct EtherCAT_Frame * frame;
+
+  // To allow synchronization between input thread and rx function
+  //pthread_mutex_t rx_mut;
+  //pthread_mutexattr_t rx_attr;
+  pthread_cond_t rx_cond;
+
+  // Temember when packet was sent
+  struct timespec tx_time;
+};
+
+struct netif_counters
+{
+  uint64_t sent;
+  uint64_t received;
+  uint64_t collected;
+  uint64_t dropped;
+  uint64_t tx_error;
+  uint64_t tx_net_down;
+  uint64_t tx_would_block;
+  uint64_t tx_no_bufs;
+  uint64_t tx_full;
+  uint64_t rx_runt_pkt;
+  uint64_t rx_not_ecat;
+  uint64_t rx_other_eml;
+  uint64_t rx_bad_index;
+  uint64_t rx_bad_seqnum;
+  uint64_t rx_dup_seqnum;
+  uint64_t rx_dup_pkt;
+  uint64_t rx_bad_order;
+  uint64_t rx_late_pkt;         // Count of all late packets
+  uint64_t sw_dropped;          // packets that were dropped by software (for testing purposes)
+  uint64_t rx_late_pkt_rtt_us;  // Round trip time (in microseconds) of last late packet arrival
+  uint64_t rx_late_pkt_rtt_us_sum; // Sum of rtt's of all late packets (for calculating average)
+};
+
+/// Generic ethercat interface towards lower level drivers. 
+/** It should be readily re-implemented for different OSes such as
+    RTAI, linux, ...     etc. (For the ease of porting the interface
+    is in C).
+*/
+struct netif {
+  /// Transmit and receive an EtherCAT frame
+  /** Implemented for ecos in low_level_txandrx() in 
+      packages/io/eth/current/src/ethercatmaster/eth_drv.c
+      and mapped in eth_drv_init()
+   */
+  BOOL (* txandrx)(struct EtherCAT_Frame * frame, struct netif * netif);
+
+  /// Transmit and receive an EtherCAT frame - only attempt to send
+  /// frame once
+  BOOL (* txandrx_once)(struct EtherCAT_Frame * frame, struct netif * netif);    
+
+
+  /// Transmit frame
+  /** Negative return value is an error code, positive and zero is a
+      handle 
+  */
+  int  (* tx)(struct EtherCAT_Frame * frame, struct netif * netif);
+
+
+  /// Recieve frame
+  /** May block, returns true if correct frame is recieved 
+   */
+  BOOL (* rx)(struct EtherCAT_Frame * frame, struct netif * netif, int handle);
+
+  /// Drop frame 
+  /** Like rx(), but does not fill in frame with result, useful for testing
+   */
+  BOOL (* drop)(struct EtherCAT_Frame * frame, struct netif * netif, int handle);
+
+  /// Recieve frame
+  /** Will not block, returns true if correct frame is recieved 
+   */
+  BOOL (* rx_nowait)(struct EtherCAT_Frame * frame, struct netif * netif, int handle);    
+
+  /// The MAC address
+  unsigned char hwaddr[MAC_ADDRESS_SIZE];
+  /// Filedescriptor of the socket
+  int socket_private;
+
+  /// Counters for certain types of events (packet drops, invalid packets, etc)
+  struct netif_counters counters;
+
+  /// Sequence number to put on next sent packet
+  unsigned tx_seqnum;
+
+  /// Secuence number of more recently recieved packet
+  unsigned rx_seqnum;
+
+  /// Outstanding pkt slot to use from next tx
+  unsigned next_pkt_index;
+
+  /// List of outstanding packets
+  /// (packets that have been tx'ed but not rx'ed)
+  struct outstanding_pkt pkt_list[PKT_LIST_SIZE];
+
+  // Number of tx'd packets that have not been rx'd yet
+  unsigned unclaimed_packets;
+
+  /// List of buffers used for packet reception 
+  struct pkt_buf buf_list[BUF_LIST_SIZE];
+  
+  // For thread safety: txandrx() can be called from multiple threads...
+  pthread_mutex_t txandrx_mut;
+  pthread_mutexattr_t txandrx_attr;
+
+  // For input thread -- if it is used
+  pthread_t input_thread;
+  volatile BOOL stop;
+  volatile BOOL is_stopped;
+
+  // Timeout for recieve in microseconds.
+  int timeout_us;
+
+  // private variable
+  void* private_data;
+};
+
+#endif // __netif_h__
diff --git a/include/ethercat/arch-eCos/ethercat/ethercat_datastruct.h ./include/ethercat/arch-eCos/ethercat/ethercat_datastruct.h
new file mode 100644
index 0000000..1256969
--- /dev/null
+++ ./include/ethercat/arch-eCos/ethercat/ethercat_datastruct.h
@@ -0,0 +1,72 @@
+// $Id: ethercat_datastruct.h,v 1.5 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// fixme include copyright notice
+
+#ifndef __ethercat_ds_h
+#define __ethercat_ds_h
+
+/// Base class for all EtherCAT register area data structs
+/** The main purpose of this class is to serialize and deserialize
+    data.
+*/
+class EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param a_data_length data length expressed as a number of bytes
+   */
+  EC_DataStruct(size_t a_data_length) : m_data_length(a_data_length){};
+
+  /// Destructor
+  virtual ~EC_DataStruct(){};
+
+  // default copy constructor will do...
+
+  /// Return length of data array expressed as a number of bytes
+  /** @return the number of bytes
+   */
+  size_t length() const {return m_data_length;} 
+
+  /// Dump the data struct into an array (EtherCAT Little Endian)
+  /** @param a_buffer where data should be dumped
+      @return pointer just beyond the array
+  */
+  virtual unsigned char * dump(unsigned char * a_buffer) const = 0;
+
+ protected:
+  /// Length of data array expressed as a number of bytes
+  size_t m_data_length;
+};
+
+#endif // __ethercat_ds_h
diff --git a/include/ethercat/arch-eCos/ethercat/ethercat_defs.h ./include/ethercat/arch-eCos/ethercat/ethercat_defs.h
new file mode 100644
index 0000000..ef54d66
--- /dev/null
+++ ./include/ethercat/arch-eCos/ethercat/ethercat_defs.h
@@ -0,0 +1,140 @@
+// $Id: ethercat_defs.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_defs_h__
+#define __ethercat_defs_h__
+
+// NOTE: Contrary to all logic ethercat data is transmitted in Little
+// Endian!
+
+#include <cyg/infra/cyg_type.h>
+#include <cyg/hal/hal_endian.h>
+#include <string.h>
+
+typedef cyg_int8   EC_SINT;
+typedef cyg_uint8  EC_USINT;
+typedef cyg_int16  EC_INT;
+typedef cyg_uint16 EC_UINT;
+typedef cyg_int32  EC_DINT;
+typedef cyg_uint32 EC_UDINT;
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_SINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_USINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_INT a_value) {
+  cyg_uint16 tmp = CYG_CPU_TO_LE16(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UINT a_value) {
+  cyg_uint16 tmp = CYG_CPU_TO_LE16(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_DINT a_value) {
+  cyg_uint32 tmp = CYG_CPU_TO_LE32(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UDINT a_value) {
+  cyg_uint32 tmp = CYG_CPU_TO_LE32(a_value);
+  memcpy(a_buffer, &tmp, sizeof(tmp));
+  return a_buffer + sizeof(tmp);
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, const unsigned char * a_data, size_t a_datalen) {
+  memcpy(a_buffer, a_data, a_datalen);
+  return a_buffer + a_datalen;
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_SINT& a_value) {
+  a_value = static_cast<EC_SINT>(*a_data);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_USINT& a_value) {
+  a_value=  static_cast<EC_USINT>(*a_data);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_INT& a_value) {
+  cyg_uint16 tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = CYG_LE16_TO_CPU(tmp);
+
+  a_value = static_cast<EC_INT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UINT& a_value) {
+  cyg_uint16 tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = CYG_LE16_TO_CPU(tmp);
+
+  a_value = static_cast<EC_UINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_DINT& a_value) {
+  cyg_uint32 tmp;
+  memcpy(&tmp, a_data, sizeof(tmp));
+  tmp = CYG_LE32_TO_CPU(tmp);
+
+  a_value = static_cast<EC_DINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UDINT& a_value) {
+  cyg_uint32 tmp;
+  memcpy(&tmp, a_data,sizeof(tmp));
+  tmp = CYG_LE32_TO_CPU(tmp);
+
+  a_value = static_cast<EC_UDINT>(tmp);
+  return a_data + sizeof(a_value);
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, size_t a_datalen) {
+  return a_data + a_datalen;
+}
+
+#endif // __ethercat_defs_h__
diff --git a/include/ethercat/arch-eCos/ethercat/ethercat_log.h ./include/ethercat/arch-eCos/ethercat/ethercat_log.h
new file mode 100644
index 0000000..6252d37
--- /dev/null
+++ ./include/ethercat/arch-eCos/ethercat/ethercat_log.h
@@ -0,0 +1,49 @@
+// $Id: ethercat_log.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_log_h__
+#define __ethercat_log_h__
+
+#include <pkgconf/net_ethercatmaster.h>
+#include <cyg/infra/diag.h>
+
+#define EC_LOG_INFO      3
+#define EC_LOG_WARNING   2
+#define EC_LOG_ERROR     1
+#define EC_LOG_FATAL     0
+
+// Redefine this function if not using eCos...
+#define ec_log(level, args...) \
+if(level < CYGNUM_ETHERCATMASTER_LOG_LEVEL) diag_printf(args)
+
+#endif // __ethercat_log_h__
diff --git a/include/ethercat/arch-eCos/ethercat/netif.h ./include/ethercat/arch-eCos/ethercat/netif.h
new file mode 100644
index 0000000..93999cf
--- /dev/null
+++ ./include/ethercat/arch-eCos/ethercat/netif.h
@@ -0,0 +1,83 @@
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+#ifndef __netif_h__
+#define __netif_h__
+
+// Forward declarations
+struct EtherCAT_Frame;
+struct netif;
+
+#include <stdlib.h>
+
+#define ETHERCAT_DEVICE_NAME_MAX_LENGTH 256
+// Size of MAC adresses expressed as a number of bytes 
+#define MAC_ADDRESS_SIZE 6 
+
+// Function prototypes
+externC void if_attach(struct netif * netif);
+externC int framedump(const struct EtherCAT_Frame * frame, unsigned char * buffer, size_t bufferlength);
+externC int framebuild(struct EtherCAT_Frame * frame, const unsigned char * buffer);
+
+/// Generic ethercat interface towards lower level drivers. 
+/** It should be readily re-implemented for different OSes such as
+    RTAI, linux, ...     etc. (For the ease of porting the interface
+    is in C).
+*/
+struct netif {
+  /// Transmit and receive an EtherCAT frame
+  /** Implemented for ecos in low_level_txandrx() in 
+      packages/io/eth/current/src/ethercatmaster/eth_drv.c
+      and mapped in eth_drv_init()
+   */
+  bool (* txandrx)(struct EtherCAT_Frame * frame, struct netif * netif);
+
+  /// Request for servicing from low level device driver
+  /** Implemented for ecos in ethercat_delivery_request() in
+      packages/net/ethercatmaster/current/src/ecos/support.cxx
+      and mapped in if_attach() 
+  */
+  void (* service_request_indication)(struct netif * netif);
+
+  /// The MAC address
+  unsigned char hwaddr[MAC_ADDRESS_SIZE];
+  /// Name of the device
+  char device_name[ETHERCAT_DEVICE_NAME_MAX_LENGTH];
+  /// Field to be set by the device driver
+  void * devicedriver_private;
+  /// Field to be set by the stack
+  void * stack_private;
+};
+
+#endif // __netif_h__
diff --git a/include/ethercat/arch-template/ethercat_defs.h ./include/ethercat/arch-template/ethercat_defs.h
new file mode 100644
index 0000000..1310bd2
--- /dev/null
+++ ./include/ethercat/arch-template/ethercat_defs.h
@@ -0,0 +1,92 @@
+// $Id: ethercat_defs.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_defs_h__
+#define __ethercat_defs_h__
+
+typedef your_short_int_type_here EC_SINT; // 8 bits, signed
+typedef ...  EC_USINT; // 8 bits, unsigned
+typedef ...  EC_INT; // 16 bits, signed
+typedef ... EC_UINT; // 16 bits, unsigned
+typedef ..  EC_DINT; // 32 bits, signed
+typedef ... EC_UDINT; // 32 bits, unsigned
+
+// NOTE: Contrary to all logic ethercat data is transmitted in Little
+// Endian!
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_SINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_USINT a_value) {
+  *a_buffer++ = static_cast<unsigned char>(a_value);
+  return a_buffer;
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_INT a_value) {
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UINT a_value) {
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_DINT a_value) {
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, EC_UDINT a_value) {
+}
+
+inline unsigned char * host2nw(unsigned char * a_buffer, const unsigned char * a_data, size_t a_datalen) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_SINT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_USINT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_INT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UINT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_DINT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, EC_UDINT& a_value) {
+}
+
+inline const unsigned char * nw2host(const unsigned char * a_data, size_t a_datalen) {
+}
+
+#endif // __ethercat_defs_h__
diff --git a/include/ethercat/arch-template/ethercat_log.h ./include/ethercat/arch-template/ethercat_log.h
new file mode 100644
index 0000000..02ce9a2
--- /dev/null
+++ ./include/ethercat/arch-template/ethercat_log.h
@@ -0,0 +1,48 @@
+// $Id: ethercat_log.h,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#ifndef __ethercat_log_h__
+#define __ethercat_log_h__
+
+#include <pkgconf/net_ethercatmaster.h>
+
+#define EC_LOG_INFO      3
+#define EC_LOG_WARNING   2
+#define EC_LOG_ERROR     1
+#define EC_LOG_FATAL     0
+
+// Redefine this function if you're not using eCos...
+#define ec_log(level, args...) \
+if(level < CYGNUM_ETHERCATMASTER_LOG_LEVEL) diag_printf(args)
+
+#endif // __ethercat_log_h__
diff --git a/include/ethercat/ethercat_datastruct.h ./include/ethercat/ethercat_datastruct.h
new file mode 100644
index 0000000..1256969
--- /dev/null
+++ ./include/ethercat/ethercat_datastruct.h
@@ -0,0 +1,72 @@
+// $Id: ethercat_datastruct.h,v 1.5 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// fixme include copyright notice
+
+#ifndef __ethercat_ds_h
+#define __ethercat_ds_h
+
+/// Base class for all EtherCAT register area data structs
+/** The main purpose of this class is to serialize and deserialize
+    data.
+*/
+class EC_DataStruct
+{
+ public:
+  /// Constructor
+  /** @param a_data_length data length expressed as a number of bytes
+   */
+  EC_DataStruct(size_t a_data_length) : m_data_length(a_data_length){};
+
+  /// Destructor
+  virtual ~EC_DataStruct(){};
+
+  // default copy constructor will do...
+
+  /// Return length of data array expressed as a number of bytes
+  /** @return the number of bytes
+   */
+  size_t length() const {return m_data_length;} 
+
+  /// Dump the data struct into an array (EtherCAT Little Endian)
+  /** @param a_buffer where data should be dumped
+      @return pointer just beyond the array
+  */
+  virtual unsigned char * dump(unsigned char * a_buffer) const = 0;
+
+ protected:
+  /// Length of data array expressed as a number of bytes
+  size_t m_data_length;
+};
+
+#endif // __ethercat_ds_h
diff --git a/include/ethercat/netif.h ./include/ethercat/netif.h
new file mode 100644
index 0000000..93999cf
--- /dev/null
+++ ./include/ethercat/netif.h
@@ -0,0 +1,83 @@
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+// $Id: netif.h,v 1.13 2006/02/20 15:57:33 kgad Exp $
+#ifndef __netif_h__
+#define __netif_h__
+
+// Forward declarations
+struct EtherCAT_Frame;
+struct netif;
+
+#include <stdlib.h>
+
+#define ETHERCAT_DEVICE_NAME_MAX_LENGTH 256
+// Size of MAC adresses expressed as a number of bytes 
+#define MAC_ADDRESS_SIZE 6 
+
+// Function prototypes
+externC void if_attach(struct netif * netif);
+externC int framedump(const struct EtherCAT_Frame * frame, unsigned char * buffer, size_t bufferlength);
+externC int framebuild(struct EtherCAT_Frame * frame, const unsigned char * buffer);
+
+/// Generic ethercat interface towards lower level drivers. 
+/** It should be readily re-implemented for different OSes such as
+    RTAI, linux, ...     etc. (For the ease of porting the interface
+    is in C).
+*/
+struct netif {
+  /// Transmit and receive an EtherCAT frame
+  /** Implemented for ecos in low_level_txandrx() in 
+      packages/io/eth/current/src/ethercatmaster/eth_drv.c
+      and mapped in eth_drv_init()
+   */
+  bool (* txandrx)(struct EtherCAT_Frame * frame, struct netif * netif);
+
+  /// Request for servicing from low level device driver
+  /** Implemented for ecos in ethercat_delivery_request() in
+      packages/net/ethercatmaster/current/src/ecos/support.cxx
+      and mapped in if_attach() 
+  */
+  void (* service_request_indication)(struct netif * netif);
+
+  /// The MAC address
+  unsigned char hwaddr[MAC_ADDRESS_SIZE];
+  /// Name of the device
+  char device_name[ETHERCAT_DEVICE_NAME_MAX_LENGTH];
+  /// Field to be set by the device driver
+  void * devicedriver_private;
+  /// Field to be set by the stack
+  void * stack_private;
+};
+
+#endif // __netif_h__
diff --git a/src/CMakeLists.txt ./src/CMakeLists.txt
new file mode 100644
index 0000000..21d05a6
--- /dev/null
+++ ./src/CMakeLists.txt
@@ -0,0 +1,96 @@
+FILE( GLOB SRCS al/[^.]*.cxx dll/[^.]*.cxx )
+SET (eml_SRCS ${SRCS})
+
+IF (BUILD_FOR_ECOS)
+  # Copied some stuff from ECOS_ADD_EXECUTABLE macro, since there is no
+  # ECOS_ADD_LIBRARY call
+  ADD_DEFINITIONS(-D__ECOS__=1 -D__ECOS=1)
+  SET(ECOS_DEFINITIONS -Wall -Wno-long-long -pipe -fno-builtin)
+
+  SET (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wstrict-prototypes")
+  SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Woverloaded-virtual -fno-rtti -Wctor-dtor-privacy -fno-strict-aliasing -fno-exceptions")
+  
+  # eCos only supports static libraries
+  add_library(eml ${eml_SRCS})
+  
+  # arch specific headers
+  FILE( GLOB ARCH_INCLS ${EML_SOURCE_DIR}/include/ethercat/arch-eCos/ethercat/[^.]*.h )
+  INSTALL_FILES( /include/ethercat/arch-eCos/ FILES ${ETHERCAT_INCLS})
+ENDIF (BUILD_FOR_ECOS)
+
+IF (BUILD_FOR_RTNET)
+  SET (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${XNPOSIX_USER_CFLAGS}")
+  SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
+
+  FILE( GLOB RTnet_SRCS arch/RTnet/[^.]*.c)
+  SET (eml_SRCS "${eml_SRCS};${RTnet_SRCS}")
+  
+  # Settings for building a static library (.a)
+  OPTION(BUILD_STATIC "Build EML as a static library." OFF)
+  IF ( BUILD_STATIC )
+    ADD_LIBRARY(eml-static STATIC ${eml_SRCS})
+    SET_TARGET_PROPERTIES(eml-static
+      PROPERTIES OUTPUT_NAME eml LINK_FLAGS "${XNPOSIX_USER_LDFLAGS}"
+      CLEAN_DIRECT_OUTPUT 1)
+    INSTALL_TARGETS(/lib eml-static)
+  ENDIF ( BUILD_STATIC )
+
+  # Settings for building a dynamic library (.so/.dll)
+  OPTION(BUILD_DYNAMIC "Build EML as a dynamic library (Default)." ON)
+  IF( BUILD_DYNAMIC)
+    ADD_LIBRARY(eml-dynamic SHARED ${eml_SRCS})
+    SET_TARGET_PROPERTIES(eml-dynamic
+      PROPERTIES OUTPUT_NAME eml LINK_FLAGS "${XNPOSIX_USER_LDFLAGS}"
+      CLEAN_DIRECT_OUTPUT 1)
+    INSTALL_TARGETS(/lib eml-dynamic)
+  ENDIF (BUILD_DYNAMIC)
+
+  # arch specific headers
+  FILE( GLOB ARCH_RTNET_INCLS ${EML_SOURCE_DIR}/include/ethercat/arch-RTnet/ethercat/[^.]*.h )
+  INSTALL_FILES( /include/ethercat/ FILES ${ARCH_RTNET_INCLS})
+
+ENDIF(BUILD_FOR_RTNET)
+
+IF (BUILD_FOR_POSIX)
+
+  FILE( GLOB posix_SRCS arch/posix/[^.]*.c)
+  SET (eml_SRCS "${eml_SRCS};${posix_SRCS}")
+  
+  # Settings for building a static library (.a)
+  OPTION(BUILD_STATIC "Build EML as a static library." OFF)
+  IF ( BUILD_STATIC )
+    ADD_LIBRARY(eml-static STATIC ${eml_SRCS})
+    SET_TARGET_PROPERTIES(eml-static
+      PROPERTIES OUTPUT_NAME eml LINK_FLAGS "${POSIX_USER_LDFLAGS}"
+      CLEAN_DIRECT_OUTPUT 1)
+    INSTALL_TARGETS(/lib eml-static)
+  ENDIF ( BUILD_STATIC )
+
+  # Settings for building a dynamic library (.so/.dll)
+  OPTION(BUILD_DYNAMIC "Build EML as a dynamic library (Default)." ON)
+  IF( BUILD_DYNAMIC)
+    ADD_LIBRARY(eml-dynamic SHARED ${eml_SRCS})
+    SET_TARGET_PROPERTIES(eml-dynamic
+      PROPERTIES OUTPUT_NAME eml LINK_FLAGS "${POSIX_USER_LDFLAGS}"
+      CLEAN_DIRECT_OUTPUT 1)
+    INSTALL_TARGETS(/lib eml-dynamic)
+  ENDIF (BUILD_DYNAMIC)
+
+  # arch specific headers
+  FILE( GLOB ARCH_POSIX_INCLS ${EML_SOURCE_DIR}/include/ethercat/arch-RTnet/ethercat/[^.]*.h )
+  INSTALL_FILES( /include/ethercat/ FILES ${ARCH_POSIX_INCLS})
+
+ENDIF(BUILD_FOR_POSIX)
+
+
+# Also install header files
+FILE( GLOB AL_INCLS ${EML_SOURCE_DIR}/include/al/[^.]*.h )
+INSTALL_FILES( /include/al/ FILES ${AL_INCLS})
+FILE( GLOB DLL_INCLS ${EML_SOURCE_DIR}/include/dll/[^.]*.h )
+INSTALL_FILES( /include/dll/ FILES ${DLL_INCLS})
+#FILE( GLOB ETHERCAT_INCLS ${EML_SOURCE_DIR}/include/ethercat/[^.]*.h )
+#INSTALL_FILES( /include/ethercat/ FILES ${ETHERCAT_INCLS})
+
+
+
+
diff --git a/src/al/ethercat_AL.cxx ./src/al/ethercat_AL.cxx
new file mode 100644
index 0000000..62ed578
--- /dev/null
+++ ./src/al/ethercat_AL.cxx
@@ -0,0 +1,424 @@
+// $Id: ethercat_AL.cxx,v 1.21 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "ethercat/ethercat_log.h"
+#include "al/ethercat_AL.h"
+#include "al/ethercat_slave_conf.h"
+#include "dll/ethercat_slave_memory.h"
+#include "al/ethercat_slave_handler.h"
+#include "dll/ethercat_dll.h"
+#include "dll/ethercat_telegram.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include "dll/ethercat_logical_addressed_telegram.h"
+#include <time.h>
+
+// ==================================================
+EC_Logic * EC_Logic::m_instance = NULL;
+
+EC_Logic::EC_Logic()
+  : m_wkc(0), m_idx(0){}
+
+
+EC_Logic *
+EC_Logic::instance()
+{
+  if (!m_instance) {
+    m_instance = new EC_Logic();
+  }
+  return m_instance;
+}
+
+// ==================================================
+
+EtherCAT_AL * EtherCAT_AL::m_instance = NULL;
+
+EtherCAT_AL *
+EtherCAT_AL::instance()
+{
+  if (!m_instance) {
+    m_instance = new EtherCAT_AL();
+  }
+  return m_instance;
+}
+
+EtherCAT_AL::EtherCAT_AL()
+  : m_num_slaves(0), m_ready(false)
+{
+  m_dll_instance = EtherCAT_DataLinkLayer::instance();
+  m_slave_db = EtherCAT_SlaveDb::instance();
+  m_logic_instance = EC_Logic::instance();
+
+  if (init() == false){
+    // Can't use exceptions, since not supported by eCOS f.i.
+    ec_log(EC_LOG_FATAL, "EtherCAT_AL:: Can't init network\n");
+  }
+  m_ready = true;
+}
+
+EtherCAT_AL::~EtherCAT_AL()
+{
+  for (unsigned int i = 0; i < m_num_slaves ; i++)
+    {
+      delete m_slave_handler[i];
+    }
+  delete[] m_slave_handler;
+}
+
+bool
+EtherCAT_AL::init(void)
+{
+  if (scan_slaves()){
+    if (reset_slaves()){
+      return put_slaves_in_init();
+    }
+    else{
+      ec_log(EC_LOG_FATAL, "Something went wrong while resetting slaves\n");
+      return false;
+    }
+  }
+  else{
+    ec_log(EC_LOG_FATAL, "Something went wrong while scanning network\n");
+    return false;
+  }
+}
+
+bool
+EtherCAT_AL::isReady() {
+	return m_ready;
+}
+
+bool
+EtherCAT_AL::scan_slaves(void)
+{
+  // Send APRD telegram to count number of slaves
+  unsigned char a[1] = { 0x00 };
+  APRD_Telegram counter_tg(m_logic_instance->get_idx(),0x0000,0x0000,
+			   m_logic_instance->get_wkc(),0x01,a);
+  EC_Ethernet_Frame counter_frame(&counter_tg);
+  bool succeed = m_dll_instance->txandrx(&counter_frame);
+  if (succeed == false){
+    ec_log(EC_LOG_FATAL,"Error sending counter frame\n");
+    return succeed;
+  }
+  // Init Number of slaves
+  m_num_slaves = counter_tg.get_adp();
+  ec_log(EC_LOG_INFO, "EtherCAT AL: Ring contains %d slaves\n",m_num_slaves);
+  m_slave_handler = new EtherCAT_SlaveHandler*[m_num_slaves];
+
+  // Initialise Slave Handlers, Reading productcode and revision from SII
+  EC_UINT adp = 0x0000;
+  EC_UDINT productcode = 0x00000000;
+  EC_UDINT revision = 0x00000000;
+  EC_UDINT serial = 0x00000000;
+  const EC_UINT SII_datalen = EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size + EC_Slave_RD[SII_Data].size;
+  unsigned char data[SII_datalen];
+  const EtherCAT_SlaveConfig * sconf;
+  for (unsigned i = 0; i < SII_datalen; i++)
+    data[i] = 0x00;
+  for (unsigned int i = 0; i < m_num_slaves; i++)
+    {
+      for (unsigned j = 0; j < EC_Slave_RD[SII_Data].size; j++)
+        data[j] = 0x00;
+      succeed = read_SII(adp,EC_ProductCodeAddressInSII,data);
+      if (!succeed){
+	  ec_log(EC_LOG_FATAL,"EC_AL::scan_slaves() Error reading Product code of slave %d\n",i);
+	  productcode = 0xbaddbadd;
+	  //return succeed;
+      }
+      else {
+	  nw2host(data+EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size,productcode);
+      }
+		struct timespec sleept;
+		sleept.tv_sec = 0;
+		sleept.tv_nsec = 10*1000*1000; //10ms
+		nanosleep( &sleept, 0);
+
+      for (unsigned j = 0; j < EC_Slave_RD[SII_Data].size; j++)
+			data[j] = 0x00;
+      succeed = read_SII(adp,EC_RevisionAddressInSII,data);
+      if (!succeed){
+	  ec_log(EC_LOG_FATAL,"EC_AL::scan_slaves() Error reading Revision of slave %d\n",i);
+	  revision = 0xbaddbadd;
+	  //return succeed;
+      }
+      else {
+	  nw2host(data+EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size,revision);
+      }
+		nanosleep( &sleept, 0);
+
+      for (unsigned j = 0; j < EC_Slave_RD[SII_Data].size; j++)
+        data[j] = 0x00;
+      succeed = read_SII(adp,EC_SerialAddressInSII,data);
+      if (!succeed){
+   ec_log(EC_LOG_FATAL,"EC_AL::scan_slaves() Error reading Serial of slave %d\n",i);
+   serial = 0xbaddbadd;
+   //return succeed;
+      }
+      else {
+   nw2host(data+EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size,serial);
+      }
+      nanosleep( &sleept, 0);
+
+      sconf = m_slave_db->find(productcode,revision);
+      if (sconf != NULL){
+	m_slave_handler[i] = new EtherCAT_SlaveHandler(adp2ringpos(adp),sconf,serial);
+	ec_log(EC_LOG_INFO, "AL creating SlaveHandler: pos=%d, adr=0x%x, Prod. Code=0x%x, rev=0x%x, Serial=%d\n", 
+	       adp2ringpos(adp),(EC_UINT) sconf->get_station_address(),productcode,revision,serial);
+      }
+      else { // No such slave found...
+	ec_log(EC_LOG_WARNING, "EC_AL Warning: No such slave in db, creating dummy slave\n");
+	// Create slave handler
+	m_slave_handler[i] = new EtherCAT_SlaveHandler(adp2ringpos(adp),productcode,revision,serial,(i+1),NULL,NULL);
+	ec_log(EC_LOG_INFO, "AL creating SlaveHandler: pos=%d, Product Code=0x%x, rev=0x%x, Serial=%d\n", 
+	       adp2ringpos(adp),productcode,revision,serial);
+      }
+      // prepare for querying next slave
+      adp--;
+    }
+  return true;
+}
+
+bool
+EtherCAT_AL::reset_slaves(void)
+{
+  // Reset FMMUs
+  ec_log(EC_LOG_INFO, "AL: resetting FMMUs\n");
+  EC_UINT ado = EC_Slave_RD[FMMU_0].ado;
+  // Whole FMMU area is 0x100...
+  static const EC_UINT BWR_data_len = 0x100;
+  unsigned char BWR_data[BWR_data_len] = { 0 };
+  BWR_Telegram bwr_telegram(m_logic_instance->get_idx(),ado,m_logic_instance->get_wkc(),BWR_data_len,BWR_data);
+  EC_Ethernet_Frame bwr_frame(&bwr_telegram);
+
+  bool succeed = m_dll_instance->txandrx(&bwr_frame);
+  if (succeed == false)
+    return false;
+  
+  // 3: Reset Sync Managers
+  ec_log(EC_LOG_INFO, "AL: resetting SMs\n");
+  // Whole SM area is also 0x100...
+  bwr_telegram.set_idx(m_logic_instance->get_idx());
+  ado = EC_Slave_RD[Sync_Manager_0].ado; 
+  bwr_telegram.set_ado(ado);
+  bwr_telegram.set_wkc(m_logic_instance->get_wkc());
+  return m_dll_instance->txandrx(&bwr_frame);
+}
+
+bool
+EtherCAT_AL::put_slaves_in_init(void)
+{
+	ec_log(EC_LOG_INFO, "AL: Setting all slaves in init mode\n");
+  // 6: Set device state to init
+	EC_ALControl al_control(EC_INIT_STATE,false);
+	unsigned char AL_Control_data[EC_Slave_RD[AL_Control].size];
+	al_control.dump(AL_Control_data);
+	EC_UINT ado = EC_Slave_RD[AL_Control].ado;
+	EC_UINT adp = 0x0000;
+	APWR_Telegram AL_control_telegram(m_logic_instance->get_idx(),adp,ado,
+												 m_logic_instance->get_wkc(),EC_Slave_RD[AL_Control].size,
+												 AL_Control_data);
+	EC_Ethernet_Frame AL_control_frame(&AL_control_telegram);
+
+  // 7: Check device state for init
+	static const EC_UINT AL_Status_Size = EC_Slave_RD[AL_Status].size;
+	unsigned char AL_Status_data[AL_Status_Size];
+        for (unsigned i=0; i<AL_Status_Size; ++i)
+          AL_Status_data[i] = 0;
+  /* Note: cannot initialize data array, since the compiler does not
+	recognize AL_Status_Size as being const :-(  An option would be
+	to include a for loop, but as this data is filled in by the slave,
+	no matter its value, I left it uninitialized for brievety (and
+	clarity?).
+  */
+	ado = EC_Slave_RD[AL_Status].ado;
+	APRD_Telegram AL_status_telegram(m_logic_instance->get_idx(),adp,ado,
+												m_logic_instance->get_wkc(),AL_Status_Size,AL_Status_data);
+	EC_Ethernet_Frame AL_status_frame(&AL_status_telegram);
+	EC_UINT ringpos = 0;
+	bool succeed = true;
+  
+	while ((ringpos < m_num_slaves) && (succeed == true))
+	{
+		succeed = m_dll_instance->txandrx(&AL_control_frame);
+		if (succeed == true)
+		{
+			struct timespec sleept;
+			sleept.tv_sec = 0;
+			sleept.tv_nsec = 10*1000*1000; //10ms
+			nanosleep( &sleept, 0);
+
+			succeed = m_dll_instance->txandrx(&AL_status_frame);
+			if (succeed == true)
+			{
+				EC_ALStatus status(AL_Status_data);
+				if (status.State != EC_INIT_STATE)
+				{
+					ec_log(EC_LOG_ERROR, "Error: EC slave %d not in init state, AL_status = %x\n",ringpos,status.State);
+					succeed = false;
+				}
+				ringpos++;
+				adp = ringpos2adp(ringpos);
+				AL_control_telegram.set_adp(adp);
+				AL_control_telegram.set_wkc(m_logic_instance->get_wkc());
+				AL_control_telegram.set_idx(m_logic_instance->get_idx());
+      
+				AL_status_telegram.set_adp(adp);
+				AL_status_telegram.set_wkc(m_logic_instance->get_wkc());
+				AL_status_telegram.set_idx(m_logic_instance->get_idx());
+			}
+			else 
+				ec_log(EC_LOG_ERROR, "EtherCAT_AL: Error sending AL_Status_frame for slave %d\n",ringpos);
+		}
+		else { 
+			ec_log(EC_LOG_ERROR, "EtherCAT_AL: Error sending AL_Control_frame for slave %d\n",ringpos);
+			struct timespec sleept;
+			sleept.tv_sec = 0;
+			sleept.tv_nsec = 10*1000*1000; //10ms
+			nanosleep( &sleept, 0);
+			succeed = true; // Keep trying, for god's sake
+		}
+
+	}
+	return succeed;
+}
+
+// 10 tries was not enough for the optimized version of the code
+static const unsigned int EC_SII_MAXTRIES = 100;
+
+bool
+EtherCAT_AL::read_SII(EC_UINT slave_adp,
+		      EC_UDINT address,
+		      unsigned char * a_buffer)
+{
+  bool succeed;
+
+  // Indicate we want to read from the E2PROM
+  const EC_UINT SII_control_datalen = EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size;
+  unsigned char SII_control_data[SII_control_datalen];
+  EC_SIIControlStatus siics(false,false,true,false,false,false,false);
+  unsigned char * ptr = siics.dump(SII_control_data);
+  host2nw(ptr,address);
+  APWR_Telegram SII_control_tg(m_logic_instance->get_idx(),
+			       slave_adp,EC_Slave_RD[SII_ControlStatus].ado,
+			       m_logic_instance->get_wkc(),
+			       SII_control_datalen,SII_control_data);
+  EC_Ethernet_Frame SII_control_frame(&SII_control_tg);
+  succeed = m_dll_instance->txandrx(&SII_control_frame);
+  if (!succeed){
+    ec_log(EC_LOG_ERROR,"EC_AL::read_SII() Error sending control frame\n");
+    return false;
+  }
+  // BIG FAT WARNING:  USING 2 TELEGRAMS FOR WRITING AS PROGRAMMED
+  // AFTER THIS COMMENT DOES NOT WORK,
+  // CONTRARY TO WHAT IS WRITTEN IN THE SPEC.  ALSO NOTE THAT THE USED
+  // ADDRESSES DO NOT CORRESPOND TO THOSE IN THE SPEC!!
+  /*
+  const EC_UINT SII_control_datalen = EC_Slave_RD[SII_ControlStatus].size;
+  unsigned char SII_control_data[SII_control_datalen];
+  EC_SIIControlStatus siics(false,false,true,false,false,false,false);
+  siics.dump(SII_control_data);
+  APWR_Telegram SII_control_tg(m_logic_instance->get_idx(),
+			       slave_adp,EC_Slave_RD[SII_ControlStatus].ado,
+			       m_logic_instance->get_wkc(),
+			       SII_control_datalen,SII_control_data);
+  EC_Ethernet_Frame SII_control_frame(&SII_control_tg);
+  succeed = m_dll_instance->txandrx(&SII_control_frame);
+  if (!succeed) return false;
+  
+  // Set the address we want to read from
+  const EC_UINT SII_address_datalen = EC_Slave_RD[SII_Address].size;
+  unsigned char SII_address_data[SII_control_datalen];
+  host2nw(SII_address_data,address);
+  APWR_Telegram SII_address_tg(m_logic_instance->get_idx(),
+			       slave_adp,EC_Slave_RD[SII_Address].ado,
+			       m_logic_instance->get_wkc(),
+			       SII_address_datalen,SII_address_data);
+  EC_Ethernet_Frame SII_address_frame(&SII_address_tg);
+  succeed = m_dll_instance->txandrx(&SII_address_frame);
+  if (!succeed) return false;
+  */
+
+  // The actual read
+  const EC_UINT SII_datalen = EC_Slave_RD[SII_ControlStatus].size + EC_Slave_RD[SII_Address].size + EC_Slave_RD[SII_Data].size;
+  APRD_Telegram SII_data_tg(m_logic_instance->get_idx(),
+			    slave_adp,EC_Slave_RD[SII_ControlStatus].ado,
+			    m_logic_instance->get_wkc(),
+			    SII_datalen,a_buffer);
+  EC_Ethernet_Frame SII_data_frame(&SII_data_tg);
+  unsigned int tries = 0;
+  while (tries < EC_SII_MAXTRIES){
+    SII_data_tg.set_adp(slave_adp);
+    SII_data_tg.set_wkc(m_logic_instance->get_wkc());
+    SII_data_tg.set_idx(m_logic_instance->get_idx());
+    succeed = m_dll_instance->txandrx(&SII_data_frame);
+    if (succeed == true){
+      // Check if EEPROM still busy
+      EC_SIIControlStatus siics(a_buffer);
+      if (siics.Busy){
+	ec_log(EC_LOG_WARNING, "EEPROM busy\n");
+	struct timespec sleept;
+	sleept.tv_sec = 0;
+	sleept.tv_nsec = 10*1000*1000; //10ms
+	nanosleep( &sleept, 0);
+	tries++;
+      }
+      else { 
+	if (siics.AcknowledgeError) {
+	  ec_log(EC_LOG_ERROR,"EC_AL::read_SII() Acknowledge error\n");
+	  return false;
+	}
+	return succeed;
+      }
+    }
+    tries++;
+  }
+  ec_log(EC_LOG_ERROR,"EC_AL::read_SII() Max tries exceeded\n");
+  return false;
+}
+
+
+EtherCAT_SlaveHandler *
+EtherCAT_AL::get_slave_handler(EC_FixedStationAddress station_address)
+{
+  unsigned int i = 0;
+  while(i < m_num_slaves){
+    if ( m_slave_handler[i]->get_station_address() == station_address)
+      return m_slave_handler[i];
+    else i++;
+  }
+  ec_log(EC_LOG_WARNING, "EtherCAT_AL: No such slave, returning NULL\n");
+  return NULL;
+}
+
+  
diff --git a/src/al/ethercat_FSM.cxx ./src/al/ethercat_FSM.cxx
new file mode 100644
index 0000000..2ee1339
--- /dev/null
+++ ./src/al/ethercat_FSM.cxx
@@ -0,0 +1,474 @@
+// $Id: ethercat_FSM.cxx,v 1.22 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_FSM.h"
+#include "al/ethercat_AL.h"
+#include "al/ethercat_slave_handler.h"
+#include "al/ethercat_router.h"
+#include "al/ethercat_process_data.h"
+#include "dll/ethercat_slave_memory.h"
+#include "dll/ethercat_dll.h"
+#include "dll/ethercat_telegram.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include <time.h>
+
+EC_ESM_InitState EC_ESM_State::initState;
+EC_ESM_PreOpState EC_ESM_State::preopState;
+EC_ESM_SafeOpState EC_ESM_State::safeopState;
+EC_ESM_OpState EC_ESM_State::opState;
+
+EC_ESM_Ops::EC_ESM_Ops(EtherCAT_SlaveHandler * a_SH)
+  : m_SH(a_SH)
+{
+  m_dll_instance = EtherCAT_DataLinkLayer::instance();
+  m_logic_instance = EC_Logic::instance();
+  m_router_instance = EtherCAT_Router::instance();
+  m_pdbuf_instance = EtherCAT_PD_Buffer::instance();
+};
+
+// Maximum number of tries setting the state
+static const unsigned int EC_ESM_OPS_MAX_RETRIES = 10;
+
+bool
+		EC_ESM_Ops::set_state(EC_State a_state)
+{
+	static const EC_UINT AL_Control_Size = EC_Slave_RD[AL_Control].size;
+	EC_ALControl al_control(a_state,false);
+	unsigned char AL_Control_data[AL_Control_Size];
+	al_control.dump(AL_Control_data);
+	NPWR_Telegram AL_control_telegram(m_logic_instance->get_idx(),
+												 m_SH->get_station_address(),
+												 EC_Slave_RD[AL_Control].ado,
+												 m_logic_instance->get_wkc(),
+												 AL_Control_Size,
+												 AL_Control_data);
+	EC_Ethernet_Frame AL_control_frame(&AL_control_telegram);
+
+	bool succeed;
+	unsigned int tries = 0;
+
+	while (tries < EC_ESM_OPS_MAX_RETRIES){
+		succeed = m_dll_instance->txandrx(&AL_control_frame);
+		if (succeed == true){
+			static const EC_UINT AL_Status_Size = EC_Slave_RD[AL_Status].size;
+			unsigned char AL_Status_data[AL_Status_Size];
+                        for (unsigned i=0; i<AL_Status_Size; ++i)
+                          AL_Status_data[i] = 0;
+			NPRD_Telegram AL_status_telegram(m_logic_instance->get_idx(),
+														m_SH->get_station_address(),
+														EC_Slave_RD[AL_Status].ado,
+														m_logic_instance->get_wkc(),AL_Status_Size,AL_Status_data);
+			EC_Ethernet_Frame AL_status_frame(&AL_status_telegram);
+			struct timespec sleept;
+			sleept.tv_sec = 0;
+			sleept.tv_nsec = 10*1000*1000; //10ms
+			nanosleep( &sleept, 0);
+			succeed = m_dll_instance->txandrx(&AL_status_frame);
+			if (succeed == true){
+				EC_ALStatus status(AL_Status_data);
+				if ((status.State == a_state ) && (status.Change == false))
+					return true;
+				else 
+					ec_log(EC_LOG_WARNING, "EC_ESM_Ops::set_state() Warning: State trans. failed (try %d), desired=%x, status=%x\n",tries,a_state,status.State);
+			}
+		}
+		else {
+			ec_log(EC_LOG_WARNING, "EC_ESM_Ops::set_state() Warning: Error sending control frame (try %d)\n", tries);
+			struct timespec sleept;
+			sleept.tv_sec = 0;
+			sleept.tv_nsec = 10*1000*1000; //10ms
+			nanosleep( &sleept, 0);
+		}
+
+    AL_control_telegram.set_idx(m_logic_instance->get_idx());
+    AL_control_telegram.set_wkc(m_logic_instance->get_wkc());
+    al_control.dump(AL_Control_data);
+    tries++;
+  }
+  // Should never get here...
+  ec_log(EC_LOG_ERROR, "EC_ESM_Ops::set_state() failed to set state after %d tries", EC_ESM_OPS_MAX_RETRIES);
+  return false;
+}
+
+bool
+EC_ESM_Ops::start_mbx_comm()
+{
+  // Checking the current state of FSM is problably not necessary, since
+  // this function can only be called from the appropriate state (at
+  // least in theory :-)
+
+  // FIXME Check PDI.  Or is this slave specific and should this be
+  // passed in via slave specific init commands? Configure all other
+  // DLL registers here...
+  
+  // Set station address
+  static const EC_UINT address_datalen = EC_Slave_RD[ECAT_Station_Address].size;
+  unsigned char address_data[address_datalen];
+  (m_SH->get_station_address()).dump(address_data);
+  APWR_Telegram address_tg(m_logic_instance->get_idx(),
+			   ringpos2adp(m_SH->get_ring_position()),
+			   EC_Slave_RD[ECAT_Station_Address].ado,
+			   (m_logic_instance->get_wkc()),
+			   address_datalen,
+			   address_data);
+  EC_Ethernet_Frame address_frame(&address_tg);
+  bool succeed = m_dll_instance->txandrx(&address_frame);
+  if (succeed == false){
+    ec_log(EC_LOG_ERROR, "Error setting Fixed Station Address\n");
+    return succeed;
+  }
+  struct timespec sleept;
+  sleept.tv_sec = 0;
+  sleept.tv_nsec = 10*1000*1000; //10ms
+  nanosleep( &sleept, 0);
+
+  // From here on, we can use NP telegrams
+
+  // MBX initialisation for complex slaves
+  if (m_SH->is_complex()){
+    // Write MBX configuration to slave
+    unsigned char mbx_conf_data[EC_Slave_RD[Sync_Manager_0].size];
+    (m_SH->get_mbx_config()->SM0).dump(mbx_conf_data);
+    NPWR_Telegram mbx_conf_tg(m_logic_instance->get_idx(),
+			      m_SH->get_station_address(),
+			      EC_Slave_RD[Sync_Manager_0].ado,
+			      m_logic_instance->get_wkc(),
+			      EC_Slave_RD[Sync_Manager_0].size,
+			      mbx_conf_data);
+    EC_Ethernet_Frame mbx_conf_frame(&mbx_conf_tg);
+    succeed = m_dll_instance->txandrx(&mbx_conf_frame);
+    if (succeed == false){
+      ec_log(EC_LOG_ERROR, "Error setting SM0 conf for mbx\n");
+      return succeed;
+    }
+	 nanosleep( &sleept, 0);
+
+    // Do the same for the second mbx
+    (m_SH->get_mbx_config()->SM1).dump(mbx_conf_data);
+    mbx_conf_tg.set_idx(m_logic_instance->get_idx());
+    mbx_conf_tg.set_ado(EC_Slave_RD[Sync_Manager_1].ado);
+    mbx_conf_tg.set_wkc(m_logic_instance->get_wkc());
+    succeed = m_dll_instance->txandrx(&mbx_conf_frame);
+    if (succeed == false){
+      ec_log(EC_LOG_ERROR, "Error setting SM1 conf for mbx\n");
+      return succeed;
+    }
+	 nanosleep( &sleept, 0);
+
+    // Start mbx communication via router...
+    m_router_instance->start();
+  }
+
+  // Set state to PREOP
+  return set_state(EC_PREOP_STATE);
+}
+
+bool
+EC_ESM_Ops::stop_mbx_comm()
+{
+  return set_state(EC_INIT_STATE);
+
+  if (m_SH->is_complex()){
+    // Stop mbx communication via router...
+    m_router_instance->stop();
+  }
+}
+
+
+bool
+EC_ESM_Ops::start_input_update()
+{
+  bool succeed = true;
+  
+  // Write FMMU channels
+  static const EC_UINT fmmu_data_len = EC_Slave_RD[FMMU_0].size;
+  unsigned char fmmu_data[fmmu_data_len];
+  EC_UINT adp = m_SH->get_station_address();
+  EC_UINT ado = 0x0000;
+  
+  NPWR_Telegram fmmu_tg(m_logic_instance->get_idx(),adp,ado,(m_logic_instance->get_wkc()),fmmu_data_len,fmmu_data);
+  EC_Ethernet_Frame fmmu_frame(&fmmu_tg);
+  unsigned int i = 0;
+  
+  assert(m_SH->get_fmmu_config() != NULL);
+  while ((succeed == true) && (i < m_SH->get_fmmu_config()->get_num_used_fmmus()))
+    {
+      (*(m_SH->get_fmmu_config()))[i].dump(fmmu_data);
+      ado =  EC_Slave_RD[FMMUx(i)].ado;
+      fmmu_tg.set_ado(ado);
+      succeed = m_dll_instance->txandrx(&fmmu_frame);
+
+      // increase idx and reset wkc
+      fmmu_tg.set_idx(m_logic_instance->get_idx());
+      fmmu_tg.set_wkc((m_logic_instance->get_wkc()));
+      i++;
+    }
+
+  if (succeed == false) 
+    {
+      ec_log(EC_LOG_ERROR, "error writing fmmu config\n");
+      return false;
+    }
+  
+  unsigned int j;
+  // Part two: write Sync Managers
+  if (m_SH->is_complex() == true) // write sync managers starting from 2
+    j = 2;
+  else // write sync managers starting from 0
+    j = 0;
+  
+  static const EC_UINT sm_data_len = EC_Slave_RD[Sync_Manager_0].size;
+  unsigned char sm_data[sm_data_len];
+  NPWR_Telegram sm_tg(m_logic_instance->get_idx(),adp,ado,(m_logic_instance->get_wkc()),sm_data_len,sm_data);
+  EC_Ethernet_Frame sm_frame(&sm_tg);
+  i=0;
+  while ((succeed == true) && (i < m_SH->get_pd_config()->get_num_used_sms()))
+    {
+      (*(m_SH->get_pd_config()))[i].dump(sm_data);
+      ado =  EC_Slave_RD[Sync_Managerx(j)].ado;
+      sm_tg.set_ado(ado);
+      succeed = m_dll_instance->txandrx(&sm_frame);
+
+      // increase idx and reset wkc
+      sm_tg.set_idx(m_logic_instance->get_idx());
+      sm_tg.set_wkc((m_logic_instance->get_wkc()));
+      i++;j++;
+    }
+  if (succeed == false) 
+    {
+      ec_log(EC_LOG_ERROR, "error writing SM config\n");
+      return false;
+    }
+  
+  // Note:  In case of complex slaves, check if SDO-Download services
+  // to be sent to slave and send them if necessary...
+
+  succeed = set_state(EC_SAFEOP_STATE);
+  if (succeed)
+    m_pdbuf_instance->start();
+    // Ask for start PD transmission in master
+  return succeed;
+
+}
+
+bool
+EC_ESM_Ops::stop_input_update()
+{
+  // Ask for stopping PD transmission in master
+  m_pdbuf_instance->stop();
+  return set_state(EC_PREOP_STATE);
+}
+
+bool
+EC_ESM_Ops::start_output_update()
+{
+  /* According to the spec (9.1.3.5 start output update (master)), make sure to
+     transmit "valid" output data to the slaves.  However, AFAIS, the
+     master cannot tell whether output data are valid or not.  That is
+     up to the slaves.  Moreover, in (9.1.2.5 start output update
+     (slave)), the slave has to receive the al control indication
+     first and then starts writing valid output data , so this is contrary to
+     what is told in the master.
+  */
+  return set_state(EC_OP_STATE);
+}
+
+bool
+EC_ESM_Ops::stop_output_update()
+{
+  return set_state(EC_SAFEOP_STATE);
+}
+// ==================================================
+
+EC_ESM::EC_ESM(EtherCAT_SlaveHandler * a_SH)
+  : EC_ESM_Ops(a_SH)
+    {
+      m_esm_state = &EC_ESM_State::initState;
+    }
+
+// ==================================================
+
+EC_State
+EC_ESM_InitState::get_state( ) const
+{
+  return EC_INIT_STATE;
+}
+
+bool
+EC_ESM_InitState::to_state(EC_ESM * a_ESM, EC_State a_state)
+{
+  bool succeed;
+  switch(a_state){
+  case EC_INIT_STATE: 
+    succeed = true;
+    break;
+  case EC_PREOP_STATE: 
+    succeed = a_ESM->start_mbx_comm();
+    if (succeed) a_ESM->setState(&preopState);
+    break;
+  case EC_SAFEOP_STATE:
+    succeed = a_ESM->start_mbx_comm();
+    if (succeed){
+      a_ESM->setState(&preopState);
+      succeed = a_ESM->to_state(EC_SAFEOP_STATE);
+    }
+    break;
+  case EC_OP_STATE:
+    succeed = a_ESM->start_mbx_comm();
+    if (succeed){
+      a_ESM->setState(&preopState);
+      succeed = a_ESM->to_state(EC_OP_STATE);
+    }
+    break;
+  default:
+    succeed = false; break;
+    // FIXME implement bootstrap state...
+  }
+  return succeed;
+}
+
+EC_State
+EC_ESM_PreOpState::get_state( ) const
+{
+  return EC_PREOP_STATE;
+}
+
+bool
+EC_ESM_PreOpState::to_state(EC_ESM * a_ESM, EC_State a_state)
+{
+  bool succeed;
+  switch(a_state){
+  case EC_INIT_STATE: 
+    succeed = a_ESM->stop_mbx_comm();
+    if (succeed) a_ESM->setState(&initState);
+    break;
+  case EC_PREOP_STATE: 
+    succeed = true;
+    break;
+  case EC_SAFEOP_STATE:
+    succeed = a_ESM->start_input_update();
+    if (succeed) a_ESM->setState(&safeopState);
+    break;
+  case EC_OP_STATE:
+    succeed = a_ESM->start_input_update();
+    if (succeed){
+      a_ESM->setState(&safeopState);
+      succeed = a_ESM->to_state(EC_OP_STATE);
+    }
+    break;
+  default:
+    succeed = false; break;
+    // FIXME implement bootstrap state...
+  }
+  return succeed;
+}
+
+EC_State
+EC_ESM_SafeOpState::get_state( ) const
+{
+  return EC_SAFEOP_STATE;
+}
+
+bool
+EC_ESM_SafeOpState::to_state(EC_ESM * a_ESM, EC_State a_state)
+{
+  bool succeed;
+  switch(a_state){
+  case EC_INIT_STATE: 
+    succeed = a_ESM->stop_input_update();
+    if (succeed){
+      succeed = a_ESM->stop_mbx_comm();
+      if (succeed) a_ESM->setState(&initState);
+    }
+    break;
+  case EC_PREOP_STATE: 
+      succeed = a_ESM->stop_input_update();
+      if (succeed) a_ESM->setState(&preopState);
+    break;
+  case EC_SAFEOP_STATE:
+    succeed = true;
+    break;
+  case EC_OP_STATE:
+    succeed = a_ESM->start_output_update();
+    if (succeed) a_ESM->setState(&opState);
+    break;
+  default:
+    succeed = false; break;
+    // FIXME implement bootstrap state...
+  }
+  return succeed;
+}
+
+EC_State
+EC_ESM_OpState::get_state( ) const
+{
+  return EC_OP_STATE;
+}
+
+
+bool
+EC_ESM_OpState::to_state(EC_ESM * a_ESM, EC_State a_state)
+{
+  bool succeed;
+  switch(a_state){
+  case EC_INIT_STATE: 
+    succeed = a_ESM->stop_output_update();
+    if (succeed){ 
+      succeed = a_ESM->stop_input_update();
+      if (succeed){
+	succeed = a_ESM->stop_mbx_comm();
+	if (succeed) a_ESM->setState(&initState);
+      }
+    }
+    break;
+  case EC_PREOP_STATE: 
+    succeed = a_ESM->stop_output_update();
+    if (succeed){ 
+      succeed = a_ESM->stop_input_update();
+      if (succeed) a_ESM->setState(&preopState);
+    }
+    break;
+  case EC_SAFEOP_STATE:
+    succeed = a_ESM->stop_output_update();
+    if (succeed) a_ESM->setState(&safeopState);
+    break;
+  case EC_OP_STATE:
+    succeed = true;
+    break;
+  default:
+    succeed = false; break;
+    // FIXME implement bootstrap state...
+  }
+  return succeed;
+}
diff --git a/src/al/ethercat_master.cxx ./src/al/ethercat_master.cxx
new file mode 100644
index 0000000..c94f9c7
--- /dev/null
+++ ./src/al/ethercat_master.cxx
@@ -0,0 +1,80 @@
+// $Id: ethercat_master.cxx,v 1.28 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_master.h"
+#include "al/ethercat_AL.h"
+#include "al/ethercat_router.h"
+#include "al/ethercat_slave_conf.h"
+#include "dll/ethercat_slave_memory.h"
+#include "dll/ethercat_dll.h"
+#include "dll/ethercat_telegram.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include "dll/ethercat_logical_addressed_telegram.h"
+
+EtherCAT_Master * EtherCAT_Master::m_instance = 0;
+
+EtherCAT_Master *
+EtherCAT_Master::instance()
+{
+  if (!m_instance) {
+    m_instance = new EtherCAT_Master();
+  }
+  return m_instance;
+}
+
+EtherCAT_Master::EtherCAT_Master()
+{
+  m_al_instance = EtherCAT_AL::instance();
+  m_router_instance = EtherCAT_Router::instance();
+  m_pdbuf_instance = EtherCAT_PD_Buffer::instance();
+}
+
+EtherCAT_Master::~EtherCAT_Master(){}
+
+EtherCAT_SlaveHandler *
+EtherCAT_Master::get_slave_handler(EC_FixedStationAddress address)
+{
+  return m_al_instance->get_slave_handler(address);
+}
+
+
+bool
+EtherCAT_Master::txandrx_PD(size_t datalen,
+			    unsigned char * data)
+{
+  return m_pdbuf_instance->txandrx(datalen,data);
+}
+
+
+
diff --git a/src/al/ethercat_mbx.cxx ./src/al/ethercat_mbx.cxx
new file mode 100644
index 0000000..7ceccb2
--- /dev/null
+++ ./src/al/ethercat_mbx.cxx
@@ -0,0 +1,130 @@
+// $Id: ethercat_mbx.cxx,v 1.8 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_mbx.h"
+#include <assert.h>
+
+EC_MbxMsgHdr::EC_MbxMsgHdr(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_MBXMSG_HDR_SIZE),m_address(a_buffer+sizeof(m_length))
+{
+  a_buffer = nw2host(a_buffer,m_length);
+  a_buffer += m_address.length();
+  EC_USINT priority;
+  a_buffer = nw2host(a_buffer,priority);
+  m_priority = priority >> 6; // bitshifting 6 bits
+  EC_USINT msg_type;
+  a_buffer = nw2host(a_buffer,msg_type);
+  msg_type &= 0x7; // Only last 3 bits should last
+  assert(msg_type <= EC_FoE);
+  m_type = (ECMbxMsgType) msg_type;
+}
+
+
+unsigned char * 
+EC_MbxMsgHdr::dump(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer,m_length);
+  a_buffer = m_address.dump(a_buffer);
+
+  EC_USINT priority = m_priority << 6;
+  a_buffer = host2nw(a_buffer,priority);
+
+  a_buffer = host2nw(a_buffer,m_type);
+  return a_buffer;
+}
+
+// ==================================================
+
+EtherCAT_MbxMsg::EtherCAT_MbxMsg(const unsigned char * a_buffer)
+  : m_hdr(a_buffer)
+{
+  a_buffer+=EC_MBXMSG_HDR_SIZE;
+  m_MbxMsgdata = a_buffer;
+}
+
+
+unsigned char * 
+EtherCAT_MbxMsg::dump_data(unsigned char * a_buffer) const
+{
+  memcpy(a_buffer,m_MbxMsgdata,m_hdr.m_length);
+  return (a_buffer + m_hdr.m_length);
+}
+
+unsigned char * 
+EtherCAT_MbxMsg::dump(unsigned char * a_buffer) const
+{
+  a_buffer = m_hdr.dump(a_buffer);
+  a_buffer = dump_data(a_buffer);
+  return a_buffer;
+}
+
+// ==================================================
+
+EC_CoE_Hdr::EC_CoE_Hdr(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_MBXMSG_COE_HDR_SIZE)
+{
+  EC_UINT hdr;
+  a_buffer = nw2host(a_buffer,hdr);
+  // FIXME Number Hi and Number Lo not yet implemented
+  hdr = hdr >> 12; hdr &= 0xf;
+  assert(hdr <= CANopen_SDOInformation);
+  m_service = (CANopenService) hdr;
+}
+
+unsigned char * 
+EC_CoE_Hdr::dump(unsigned char * a_buffer) const
+{
+  EC_UINT hdr = m_service;
+  a_buffer = host2nw(a_buffer,hdr);
+  return a_buffer;
+}
+
+// ==================================================
+
+EtherCAT_CoE_MbxMsg::EtherCAT_CoE_MbxMsg(unsigned char * a_buffer)
+  : EtherCAT_MbxMsg(a_buffer), m_CoE_Hdr(a_buffer + EC_MBXMSG_HDR_SIZE)
+{
+  a_buffer+=(EC_MBXMSG_COE_HDR_SIZE+EC_MBXMSG_HDR_SIZE);
+  m_MbxMsgdata = a_buffer;
+}
+
+
+unsigned char *
+EtherCAT_CoE_MbxMsg::dump(unsigned char * a_buffer) const
+{
+  a_buffer = m_hdr.dump(a_buffer);
+  a_buffer = m_CoE_Hdr.dump(a_buffer);
+  a_buffer = this->dump_data(a_buffer);
+  return a_buffer;
+}
+
diff --git a/src/al/ethercat_process_data.cxx ./src/al/ethercat_process_data.cxx
new file mode 100644
index 0000000..044f8ad
--- /dev/null
+++ ./src/al/ethercat_process_data.cxx
@@ -0,0 +1,159 @@
+// $Id: ethercat_process_data.cxx,v 1.10 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_process_data.h"
+#include "al/ethercat_slave_handler.h"
+#include "al/ethercat_AL.h"
+#include "al/ethercat_master.h"
+#include "dll/ethercat_dll.h"
+
+EtherCAT_PD_Buffer * EtherCAT_PD_Buffer::m_instance = 0;
+
+EtherCAT_PD_Buffer *
+EtherCAT_PD_Buffer::instance()
+{
+  if (!m_instance) {
+    m_instance = new EtherCAT_PD_Buffer();
+  }
+  return m_instance;
+}
+
+// al_instance cannot be initiated right now, since this results in a
+// circular instantiation al_instance calls router_instance etc.
+EtherCAT_PD_Buffer::EtherCAT_PD_Buffer()
+  : m_is_running(0)
+{
+  for (unsigned i=0;i<MAX_CHUNKS;++i) {
+    m_lrw_telegram[i] = new LRW_Telegram(0x00,0x00010000,0x00,0,NULL);
+    m_lrw_frame[i] = new EC_Ethernet_Frame(m_lrw_telegram[i]);
+  }
+
+  // get pointer to DLL and logic
+  m_dll_instance = EtherCAT_DataLinkLayer::instance();
+  m_logic_instance = EC_Logic::instance();
+}
+
+EtherCAT_PD_Buffer::~EtherCAT_PD_Buffer()
+{
+  for (unsigned i=0;i<MAX_CHUNKS;++i) {
+    delete m_lrw_telegram[i];
+    m_lrw_telegram[i] = NULL;
+    delete m_lrw_frame[i];
+    m_lrw_frame[i];
+  }
+}
+
+void 
+EtherCAT_PD_Buffer::start()
+{
+  ++m_is_running;
+}
+
+void 
+EtherCAT_PD_Buffer::stop()
+{ 
+  if (m_is_running > 0)
+    --m_is_running;
+  else
+    ec_log(EC_LOG_INFO, "EtherCAT_PD_Buffer already stopped...\n");
+}
+
+bool
+EtherCAT_PD_Buffer::txandrx(size_t datalen, unsigned char * data)
+{
+  //define MAX_CHUNKS 4
+  //define CHUNK_SIZE 1486
+
+  if (datalen>(CHUNK_SIZE*MAX_CHUNKS)) {
+    ec_log(EC_LOG_ERROR, "PD_Buffer: Too much data (%zd) to send in %d chunks of %d bytes\n", 
+           datalen, MAX_CHUNKS, CHUNK_SIZE);
+    return false;
+  }
+
+  int handles[MAX_CHUNKS];
+  for (unsigned i=0;i<MAX_CHUNKS;++i)
+    handles[i]=-1;
+
+  bool success = true;
+  if ( m_is_running != 0)
+    // In case only starting when all slaves in the appropriate state
+    // this becomes something like
+    // if ( EtherCAT_PD_Buffer::m_al_instance->get_num_slaves() == m_running)
+    {
+      int dst = 0x00010000;
+      unsigned index=0;
+      while (datalen > 0)
+      {
+        assert(index<MAX_CHUNKS);
+        size_t chunk_size = datalen <  CHUNK_SIZE ? datalen : CHUNK_SIZE;
+        LRW_Telegram* a_lrw_telegram(m_lrw_telegram[index]);
+        a_lrw_telegram->set_idx(m_logic_instance->get_idx());
+        a_lrw_telegram->set_wkc(m_logic_instance->get_wkc());
+        a_lrw_telegram->set_datalen(chunk_size);
+        a_lrw_telegram->set_data(data);
+        a_lrw_telegram->set_adr(dst);
+
+        int result = m_dll_instance->tx(m_lrw_frame[index]);
+        if (result < 0)
+        {
+          ec_log(EC_LOG_ERROR, "PD_Buffer: Error sending PD\n");
+          success = false;
+          break;
+        }
+        handles[index] = result;
+        datalen -= chunk_size;
+        data += chunk_size;
+        dst += chunk_size;
+        ++index;
+      }
+
+      // Receive every packet that was sent  
+      for(int i=index-1; i>=0; --i) {
+        if (handles[i] != -1) {
+          if (!m_dll_instance->rx(m_lrw_frame[i],handles[i])) {
+            ec_log(EC_LOG_ERROR, "PD_Buffer: Error receiving PD\n");
+            success = false;
+          }
+        }
+      }
+    }
+  
+  return success;
+}
+
+
+	  
+      
+
+
+
diff --git a/src/al/ethercat_router.cxx ./src/al/ethercat_router.cxx
new file mode 100644
index 0000000..d3ae091
--- /dev/null
+++ ./src/al/ethercat_router.cxx
@@ -0,0 +1,175 @@
+// $Id: ethercat_router.cxx,v 1.19 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_router.h"
+#include "al/ethercat_mbx.h"
+#include "al/ethercat_slave_handler.h"
+#include "al/ethercat_AL.h"
+#include "al/ethercat_master.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_dll.h"
+
+EtherCAT_Router * EtherCAT_Router::m_instance = 0;
+
+EtherCAT_Router *
+EtherCAT_Router::instance()
+{
+  if (!m_instance) {
+    m_instance = new EtherCAT_Router();
+  }
+  return m_instance;
+}
+
+// al_instance cannot be initiated right now, since this results in a
+// circular instantiation al_instance calls router_instance etc.
+EtherCAT_Router::EtherCAT_Router()
+  : m_al_instance(NULL), m_is_running(0)
+{
+  // get pointer to DLL and logic
+  m_dll_instance = EtherCAT_DataLinkLayer::instance();
+  m_logic_instance = EC_Logic::instance();
+}
+
+EtherCAT_Router::~EtherCAT_Router(){}
+
+void 
+EtherCAT_Router::start()
+{
+  // Only instantiate here...
+  m_al_instance = EtherCAT_AL::instance();
+  ++m_is_running;
+}
+
+void 
+EtherCAT_Router::stop()
+{ 
+  if (EtherCAT_Router::m_is_running > 0)
+    --EtherCAT_Router::m_is_running;
+  else
+    ec_log(EC_LOG_INFO, "EtherCAT_Router already stopped...\n");
+}
+
+void
+EtherCAT_Router::route() const
+{
+  if ( EtherCAT_Router::m_is_running != 0){
+    // ec_log(EC_LOG_INFO, "EtherCAT_Router::Routing\n");
+    EtherCAT_SlaveHandler * sh;
+    for (unsigned int i = 0; i < m_al_instance->get_num_slaves() ; i++){
+      sh = m_al_instance->m_slave_handler[i];
+      // don't use return value?
+      check_mbx(sh);
+    }
+  }
+}
+
+bool
+EtherCAT_Router::check_mbx(const EtherCAT_SlaveHandler * sh) const
+{
+  if (sh->is_complex()){
+    // SM0 is for M->S communication, SM1 for S->M
+    const EC_UINT datalen = sh->get_mbx_config()->SM1.Length;
+    unsigned char mbx_data[datalen];
+    NPRD_Telegram chk_mbx_tg(m_logic_instance->get_idx(),
+			     sh->get_station_address(),
+			     sh->get_mbx_config()->SM1.PhysicalStartAddress,
+			     m_logic_instance->get_wkc(),
+			     datalen,
+			     mbx_data);
+    EC_Ethernet_Frame chk_mbx_frame(&chk_mbx_tg);
+    if (m_dll_instance->txandrx(&chk_mbx_frame)){
+      // If slave posted something, wkc has increased
+      if (chk_mbx_tg.get_wkc() == 0x1){
+	EtherCAT_MbxMsg msg(chk_mbx_tg.get_data());
+	return (post_mbxmsg(&msg,sh));
+      }
+    }
+    else {
+      ec_log(EC_LOG_ERROR, "Router: Error checking mbx\n");
+      return false;
+    }
+  }
+  return true;
+}
+
+bool
+EtherCAT_Router::post_mbxmsg(EtherCAT_MbxMsg * msg, const EtherCAT_SlaveHandler * from_sh) const
+{
+  EC_FixedStationAddress dest_addr = msg->m_hdr.m_address;
+  EtherCAT_SlaveHandler * dest_sh = m_al_instance->get_slave_handler(dest_addr);
+  if (dest_sh->is_complex()){
+    // Check if MBX sizes correspond...
+    const EC_UINT datalen = dest_sh->get_mbx_config()->SM0.Length;
+    unsigned char mbx_data[datalen];
+    if (dest_sh->get_mbx_config()->SM0.Length == from_sh->get_mbx_config()->SM1.Length){
+      // Alter Header:  Include source instead of destination
+      msg->m_hdr.m_address = from_sh->get_station_address();
+      msg->dump(mbx_data);
+      NPWR_Telegram put_mbx_tg(m_logic_instance->get_idx(),
+			       dest_addr,
+			       from_sh->get_mbx_config()->SM0.PhysicalStartAddress,
+			       m_logic_instance->get_wkc(),
+			       dest_sh->get_mbx_config()->SM1.Length,
+			       mbx_data);
+      EC_Ethernet_Frame put_mbx_frame(&put_mbx_tg);
+      bool succeed = false;
+      // According to the spec, we have to keep trying until
+      // the slave accepts the command (could be \inf loop!).
+      while (succeed == false)
+	succeed = m_dll_instance->txandrx(&put_mbx_frame);
+      return succeed;
+    }
+    else{
+      ec_log(EC_LOG_ERROR, "Router::post_mbxmsg() error: SM sizes of source and destination do not match...!!\n");
+      return false;
+    }
+  }
+  else {
+    ec_log(EC_LOG_ERROR, "Router Error: Destination address of MbxMsg is not a complex slave!!\n");
+    return false;
+  }
+}
+
+/// C-interface to perform the routing
+externC void route_msgs(void)
+{
+  static EtherCAT_Router * EC_Router = EtherCAT_Router::instance();
+  EC_Router->route();
+  // ec_log(EC_LOG_INFO, "Routing Mbx msgs\n");
+}
+	  
+      
+
+
+
diff --git a/src/al/ethercat_slave_conf.cxx ./src/al/ethercat_slave_conf.cxx
new file mode 100644
index 0000000..c41e52b
--- /dev/null
+++ ./src/al/ethercat_slave_conf.cxx
@@ -0,0 +1,188 @@
+// $Id: ethercat_slave_conf.cxx,v 1.9 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_slave_conf.h"
+
+#include "dll/ethercat_slave_memory.h"
+#include "dll/ethercat_dll.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include "al/ethercat_master.h"
+
+EtherCAT_FMMU_Config::EtherCAT_FMMU_Config(unsigned int a_num_used_fmmus)
+  : m_num_used_fmmus(a_num_used_fmmus)
+{
+  fmmus = new EC_FMMU[m_num_used_fmmus];
+}
+
+EtherCAT_FMMU_Config::~EtherCAT_FMMU_Config()
+{
+  delete[] fmmus;
+}
+
+EC_FMMU &
+EtherCAT_FMMU_Config::operator[](unsigned int i)
+{
+  assert(i < m_num_used_fmmus);
+  return fmmus[i];
+}
+
+const EC_FMMU &
+EtherCAT_FMMU_Config::operator[](unsigned int i) const
+{
+  assert(i < m_num_used_fmmus);
+  return fmmus[i];
+}
+
+// ==================================================
+
+EtherCAT_PD_Config::EtherCAT_PD_Config(unsigned int a_num_used_sms)
+  : m_num_used_sms(a_num_used_sms)
+{
+  sms = new EC_SyncMan[m_num_used_sms];
+}
+
+EtherCAT_PD_Config::~EtherCAT_PD_Config()
+{
+  delete[] sms;
+}
+
+EC_SyncMan &
+EtherCAT_PD_Config::operator[](unsigned int i)
+{
+  assert(i < m_num_used_sms);
+  return sms[i];
+}
+
+const EC_SyncMan &
+EtherCAT_PD_Config::operator[](unsigned int i) const
+{
+  assert(i < m_num_used_sms);
+  return sms[i];
+}
+
+// ==================================================
+
+EtherCAT_SlaveConfig::EtherCAT_SlaveConfig(EC_UDINT a_product_code,
+					 EC_UDINT a_revision,
+					 EC_FixedStationAddress a_station_address,
+					 EtherCAT_FMMU_Config * a_fmmu_config,
+					 EtherCAT_PD_Config * a_pd_config,
+					 EtherCAT_MbxConfig * a_mbx_config)
+  : m_product_code(a_product_code), m_revision(a_revision), 
+    m_station_address(a_station_address), m_fmmu_config(a_fmmu_config),
+    m_pd_config(a_pd_config), m_mbx_config(a_mbx_config), used(false)
+{
+  if (m_mbx_config == NULL) 
+    m_complex = false;
+  else
+    m_complex = true;
+}
+
+void EtherCAT_SlaveConfig::set_mbx_config(EtherCAT_MbxConfig *new_config)
+{ 
+  m_mbx_config = new_config;
+  if (m_mbx_config == NULL) 
+    m_complex = false;
+  else
+    m_complex = true; 
+}
+
+EtherCAT_SlaveConfig::~EtherCAT_SlaveConfig(){}
+
+// ==================================================
+EtherCAT_SlaveDb * EtherCAT_SlaveDb::m_instance = NULL;
+
+EtherCAT_SlaveDb *
+EtherCAT_SlaveDb::instance(unsigned int num_slaves)
+{
+  if (!m_instance){
+    m_instance = new EtherCAT_SlaveDb(num_slaves);
+  }
+  return m_instance;
+}
+
+EtherCAT_SlaveDb::EtherCAT_SlaveDb(unsigned int num_slaves)
+  : m_num_slaves(num_slaves)
+{
+  m_sc = new EtherCAT_SlaveConfig*[num_slaves];
+}
+
+EtherCAT_SlaveDb::~EtherCAT_SlaveDb()
+{
+  delete[] m_sc;
+}
+
+EtherCAT_SlaveConfig * 
+EtherCAT_SlaveDb::operator[](unsigned int i)
+{
+  assert(i < m_num_slaves);
+  return m_sc[i];
+}
+
+const EtherCAT_SlaveConfig * 
+EtherCAT_SlaveDb::operator[](unsigned int i) const
+{
+  assert(i < m_num_slaves);
+  return m_sc[i];
+}
+
+void
+EtherCAT_SlaveDb::set_conf(EtherCAT_SlaveConfig * conf, 
+			    unsigned int i)
+{
+  assert(i < m_num_slaves);
+  m_sc[i] = conf;
+}
+
+const EtherCAT_SlaveConfig * 
+EtherCAT_SlaveDb::find(EC_UDINT productcode,
+		       EC_UDINT revision) const
+{
+  unsigned int i = 0;
+  while(i < m_num_slaves){
+	  if ( !m_sc[i]->is_used() && (m_sc[i]->get_product_code() == productcode) &&
+			(m_sc[i]->get_revision() == revision) ) {
+		  m_sc[i]->set_used();
+		  return m_sc[i];
+	  }
+    else i++;
+  }
+  ec_log(EC_LOG_WARNING, "EtherCAT_SlaveDb: No such Config, returning NULL!\n");
+  return NULL;
+}
+
+
+
+
+
diff --git a/src/al/ethercat_slave_handler.cxx ./src/al/ethercat_slave_handler.cxx
new file mode 100644
index 0000000..1ef9c25
--- /dev/null
+++ ./src/al/ethercat_slave_handler.cxx
@@ -0,0 +1,77 @@
+// $Id: ethercat_slave_handler.cxx,v 1.19 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "al/ethercat_slave_handler.h"
+#include <assert.h>
+
+EtherCAT_SlaveHandler::EtherCAT_SlaveHandler(EC_UINT a_ring_position,
+					     EC_UDINT a_product_code,
+					     EC_UDINT a_revision,
+					     EC_UDINT a_serial,
+					     EC_FixedStationAddress a_station_address,
+					     EtherCAT_FMMU_Config * a_fmmu_config,
+					     EtherCAT_PD_Config * a_pd_config,
+					     EtherCAT_MbxConfig * a_mbx_config)
+  : EC_ESM(this),
+    EtherCAT_SlaveConfig(a_product_code,
+			 a_revision,
+			 a_station_address,
+			 a_fmmu_config,
+			 a_pd_config,
+			 a_mbx_config),
+    m_ring_position(a_ring_position),
+    m_serial(a_serial),
+    m_mbx_counter(0)
+{}
+
+EtherCAT_SlaveHandler::EtherCAT_SlaveHandler(EC_UINT a_ring_position,
+					     const EtherCAT_SlaveConfig * a_sconf, EC_UDINT a_serial)
+  : EC_ESM(this),
+    EtherCAT_SlaveConfig(*a_sconf),
+    m_ring_position(a_ring_position),
+    m_serial(a_serial),
+    m_mbx_counter(0)
+{}
+
+EtherCAT_SlaveHandler::~EtherCAT_SlaveHandler(){}
+
+
+EC_USINT EtherCAT_SlaveHandler::get_mbx_counter()
+{
+  m_mbx_counter = 1+(m_mbx_counter % 7);
+  assert(m_mbx_counter>0);
+  assert(m_mbx_counter<=7);
+  return m_mbx_counter;
+}
+
+
diff --git a/src/arch/RTnet/ethercat_xenomai_drv.c ./src/arch/RTnet/ethercat_xenomai_drv.c
new file mode 100644
index 0000000..f9e0568
--- /dev/null
+++ ./src/arch/RTnet/ethercat_xenomai_drv.c
@@ -0,0 +1,266 @@
+// $Id:$
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+
+#include <string.h>
+#include <errno.h>
+#include <signal.h>
+#include <pthread.h>	
+#include <sys/ioctl.h>
+#include <netpacket/packet.h>
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <arpa/inet.h>
+
+#include <rtnet.h>
+
+#include <ethercat/netif.h>
+#include <ethercat/ethercat_log.h>
+#include <ethercat/ethercat_xenomai_drv.h>
+
+// Maximum tries to send and receive a message
+#define MAX_TRIES_TX 10
+// Timeout for receiving and transmitting messages is 100 us
+#define TIMEOUT_NSEC 1000 * 100
+// Maximum times the master may retry to create or close a socket
+#define MAX_TRIES_SOCKET 10
+// Ethernet Header is 14 bytes: 2 * MAC ADDRESS + 2 bytes for the type
+#define HEADER_SIZE 14
+#define MAX_ETH_DATA 1500
+
+int set_socket_timeout(struct netif* ni, int64_t timeout) {
+	return ioctl(ni->socket_private,RTNET_RTIOC_TIMEOUT,&timeout);
+}
+
+int init_socket(const char* interface) {
+	int sock;
+	int tries = 0;
+	struct sockaddr_ll addr;
+	struct ifreq ifr;
+
+	while (((sock = socket(PF_PACKET, SOCK_RAW, htons(0x88A4))) < 0) && tries < MAX_TRIES_SOCKET) {
+		sleep(1);
+		tries++;
+	}
+	
+	if(sock < 0) {
+		perror("Failed to create socket");
+		return -1;
+	}
+	
+	printf("Socket created: socket id: %d\n", sock);
+
+	int index_ioctl;
+	strncpy(ifr.ifr_name, interface, IFNAMSIZ);
+	if ((index_ioctl = ioctl(sock, SIOCGIFINDEX, &ifr)) < 0) {
+		perror("Cannot get interface index");
+		close(sock);
+		return -1;
+	}
+	printf("Got interface: index: %d\n", index_ioctl);
+	
+	int64_t timeout = TIMEOUT_NSEC;
+	if(ioctl(sock,RTNET_RTIOC_TIMEOUT,&timeout) < 0) {
+		perror("Cannot set timout");
+		printf("Continue without timeout\n");
+	}
+
+	addr.sll_family   = AF_PACKET;
+	addr.sll_protocol = htons(0x88A4);
+	addr.sll_ifindex  = ifr.ifr_ifindex;
+
+	if ((bind(sock, (struct sockaddr *)&addr, sizeof(addr))) < 0) {
+		perror("Cannot bind to local ip/port");
+		close(sock);
+		return -1;
+	}
+	
+	return sock;
+}
+
+int close_socket(struct netif *ni) {
+	int ret = close(ni->socket_private);
+	int tries = 1;
+	while(ret < 0 && tries < MAX_TRIES_SOCKET) {
+		ret = close(ni->socket_private);
+		tries++;
+		sleep(1);
+	}
+	if(ret < 0)
+		perror("Failed to close socket");
+	return ret;
+}
+
+struct eth_msg {
+	u_int8_t  ether_dhost[ETH_ALEN];      /* destination eth addr */
+	u_int8_t  ether_shost[ETH_ALEN];      /* source ether addr    */
+	u_int8_t  ether_type [2];                 /* packet type ID field */
+	unsigned char  data [MAX_ETH_DATA];
+};
+
+static bool low_level_output(struct EtherCAT_Frame * frame, struct netif * netif)
+{
+	bool result = false;
+	struct eth_msg msg_to_send;
+	int tel;
+	for(tel = 0; tel<MAX_ETH_DATA; tel++)
+		msg_to_send.data[tel] = 0x00;
+	int len_dump = framedump(frame, msg_to_send.data, MAX_ETH_DATA);
+	int msg_len = len_dump + ETH_ALEN + ETH_ALEN + 2;   
+	if(len_dump) { 
+		int sock = netif->socket_private;
+		// Destination address is broadcast MAC address
+		// FIXME Is this also valid for EtherCAT UDP ethernet frames?
+		memset(msg_to_send.ether_dhost, 0xFF, ETH_ALEN);
+		// Source address
+		for(tel = 0; tel<ETH_ALEN; tel++)
+			msg_to_send.ether_shost[tel] = (netif->hwaddr)[tel];
+		// Type is ethercat
+		msg_to_send.ether_type[0] = 0x88;
+		msg_to_send.ether_type[1] = 0xA4;
+	
+
+		// The actual send
+		int len_send = send(sock,(unsigned char *)&msg_to_send,msg_len  ,0);
+		if(len_send < 0)
+			ec_log(EC_LOG_FATAL, "low_level_output(): Cannot Send\n");
+		else
+			result = true;	      
+	}
+	else { // higher level protocol error. Attempt to map to much data in one ethernet frame
+		ec_log(EC_LOG_FATAL, "EtherCAT fatal: message buffer overflow\n");
+		// Release the message buffer again
+	}
+
+	return result;
+}
+
+
+static bool low_level_input(struct EtherCAT_Frame * frame, struct netif * netif) {
+
+	unsigned char buffer_receive[MAX_ETH_DATA + HEADER_SIZE];
+	struct eth_msg *msg_received = (struct eth_msg *)buffer_receive;
+	//Receive message from socket
+	int sock = netif->socket_private;
+
+  int len_recv;
+  int tries=0;
+  static const int MAX_TRIES=3; // Maximum number of tries for recieving packets
+
+  do {
+      ++tries;
+      len_recv = recv(sock,buffer_receive,sizeof(buffer_receive),0);
+      if(len_recv < 0) {
+          //perror("low_level_input: Cannot receive msg: ");
+          ec_log(EC_LOG_ERROR, "low_level_input: Cannot receive msg: %d\n",len_recv);
+          return false;
+      }
+             
+      if (len_recv <= sizeof(ETH_ALEN + ETH_ALEN + 2)) {
+          ec_log(EC_LOG_ERROR, "low_level_input: recieved runt packet: %d\n",len_recv);
+          continue;
+      }
+         
+      if ( (msg_received->ether_shost[4] != netif->hwaddr[4]) ) {
+          ec_log(EC_LOG_ERROR, "low_level_input: got incorrect sequence number: %d, expected %d\n",
+                 msg_received->ether_shost[4], netif->hwaddr[4]);
+          continue;
+      }
+      else {
+          break;
+      }       
+  } while(tries < MAX_TRIES);
+
+  if (tries >= MAX_TRIES) {
+      ec_log(EC_LOG_ERROR, "low_level_input: recieved too many bad packets: %d\n",len_recv);
+		return false;
+	}
+
+	if ( ((msg_received->ether_type[0]) != 0x88) || (msg_received->ether_type[1]) != 0xA4) {
+		ec_log(EC_LOG_ERROR, "low_level_input: No EtherCAT msg!\n");
+		return false;
+	}
+
+	// build Ethercat Frame
+	int succes = framebuild(frame,msg_received->data);
+	if (succes != 0){
+		// FIXME decent error handling here
+		ec_log(EC_LOG_ERROR, "low_level_input: framebuilding failed!\n");
+		return false;
+	}
+  
+	return true;
+}
+
+// For thread safety: txandrx() can be called from multiple threads...
+static pthread_mutex_t txandrx_mut;
+
+static bool ec_rtdm_txandrx(struct EtherCAT_Frame * frame, struct netif * netif) {
+	int tries = 0;
+	while (tries < MAX_TRIES_TX) {
+		pthread_mutex_lock (&txandrx_mut);
+    netif->hwaddr[4]++;
+		if (low_level_output(frame,netif)){
+			if (low_level_input(frame,netif)){
+				pthread_mutex_unlock(&txandrx_mut);
+				return true;
+			}
+			else{
+				ec_log(EC_LOG_ERROR, "low_level_txandrx: receiving failed\n");
+				pthread_mutex_unlock(&txandrx_mut);
+			}
+		}
+		else{
+			ec_log(EC_LOG_ERROR, "low_level_txandrx: sending failed\n");
+			pthread_mutex_unlock(&txandrx_mut);
+		}
+		tries++;
+	}
+	ec_log(EC_LOG_FATAL, "low_level_txandrx: failed: MAX_TRIES_TX: Giving up\n");
+	return false;
+}
+
+struct netif* init_ec(const char * interface) {
+	int sock = init_socket(interface);
+	if(sock < 0) {
+		ec_log(EC_LOG_FATAL,"Socket initialisation failed\n");
+		return 0;
+	}
+	struct netif* ni = (struct netif*)malloc(sizeof(struct netif));
+	ni->txandrx = ec_rtdm_txandrx;
+	ni->socket_private = sock;
+	//Mac-address
+	ni->hwaddr[0] = 0x00; ni->hwaddr[2] = 0x00; ni->hwaddr[4] = 0x00;
+	ni->hwaddr[1] = 0x00; ni->hwaddr[3] = 0x00; ni->hwaddr[5] = 0x00;
+	return ni;
+
+}
diff --git a/src/arch/posix/ethercat_posix_drv.c ./src/arch/posix/ethercat_posix_drv.c
new file mode 100644
index 0000000..f79ad61
--- /dev/null
+++ ./src/arch/posix/ethercat_posix_drv.c
@@ -0,0 +1,1087 @@
+// $Id:$
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+/*
+  Contributed by RvdM, October, 5th, 2007.
+  Purpose to use EML over PREEMPT_RT kernel
+  Based on rtnet/xenomai driver
+*/
+
+#include <errno.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <netpacket/packet.h>
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <arpa/inet.h>
+
+#include <assert.h>
+#include <string.h>
+
+#include <ethercat/netif.h>
+#include <ethercat/ethercat_log.h>
+
+#include <time.h>
+
+
+// Maximum tries to send and receive a message
+#define MAX_TRIES_TX 10
+// Timeout for receiving and transmitting messages is 2000 us
+// specifying 1000us or lower did not work on plain Linux.
+// recv() returned immediately with EWOULDBLOCK.
+// May/must be different for xgPREEMPT_RT kernels.
+#define TIMEOUT_USEC 20000
+
+// Socket timeout - so input_thread can exit
+#define SOCKET_TIMEOUT_USEC 10000
+
+// Maximum times the master may retry to create or close a socket
+#define MAX_TRIES_SOCKET 10
+// Ethernet Header is 14 bytes: 2 * MAC ADDRESS + 2 bytes for the type
+#define HEADER_SIZE 14
+#define MAX_ETH_DATA 1500
+
+#define NSEC_PER_SEC 1000000000
+
+// Size of buffer that holds message from strerror 
+#define ERRBUF_LEN 60
+
+static char* my_strerror(int errnum, char *buf, size_t buflen) 
+{
+  assert(buflen>0);
+  assert(buf!=NULL);
+  buf[0] = '\0';
+  if (strerror_r(errnum, buf, buflen) != 0) {
+    snprintf(buf, buflen, "N%d", errnum);
+  }
+  return buf;
+}
+
+static void my_usleep(uint32_t usec) 
+{
+  char errbuf[ERRBUF_LEN];
+  assert(usec<1000000);
+  struct timespec req, rem;
+  req.tv_sec = 0;
+  req.tv_nsec = usec*1000;
+  while (nanosleep(&req, &rem)!=0) { 
+    int error = errno;
+    ec_log(EC_LOG_ERROR, "%s : Error : %s\n", __func__, my_strerror(error,errbuf,sizeof(errbuf)));    
+    if (error != EINTR) {
+      break;
+    }
+    req = rem;
+  }
+  return;
+}
+
+// No longer set socket timeout, but insteads set timeout variable used by pthread_cond_timedwait.
+// Produces the simular semantics as setting socket timeout in non-threaded posix driver 
+// Timeout value it on microseconds
+int set_socket_timeout(struct netif* ni, int64_t timeout) {
+  if ((timeout*1000) >= NSEC_PER_SEC) 
+  {
+    ec_log(EC_LOG_FATAL, "%s: timeout is too large : %ld\n", __func__, timeout);    
+    assert(timeout*1000 < NSEC_PER_SEC);
+    return -1;
+  }
+  ni->timeout_us = timeout;
+  return 0;
+}
+
+
+
+static int init_socket(const char* interface) {
+	int sock;
+	int tries = 0;
+	struct sockaddr_ll addr;
+	struct ifreq ifr;
+
+        char errbuf[ERRBUF_LEN];
+        
+	while (((sock = socket(PF_PACKET, SOCK_RAW, htons(0x88A4))) < 0) && tries < MAX_TRIES_SOCKET) {
+          int error = errno;
+          fprintf(stderr, "Couldn't open raw socket for interface %s : %s\n", 
+                  interface, my_strerror(error,errbuf,sizeof(errbuf))); 
+		sleep(1);
+		tries++;
+	}
+	
+	if(sock < 0) {
+		perror("Failed to create socket");
+		return -1;
+	}
+	
+	//printf("Socket created: socket id: %d\n", sock);
+
+	int rv, index_ioctl;
+	strncpy(ifr.ifr_name, interface, IFNAMSIZ);
+	if ((rv = ioctl(sock, SIOCGIFFLAGS, &ifr)) < 0) {
+		perror("Cannot get interface flags");
+		close(sock);
+		return -1;
+  }
+  if (!(ifr.ifr_flags & IFF_UP)) {
+    fprintf(stderr, 
+            "Interface %s is not UP\n"
+            " try : ifup %s\n"
+            ,interface, interface);
+    return -1;
+  }
+
+  if ((index_ioctl = ioctl(sock, SIOCGIFINDEX, &ifr)) < 0) {
+		perror("Cannot get interface index");
+		close(sock);
+		return -1;
+	}
+	//printf("Got interface: index: %d for %s\n", index_ioctl, ifr.ifr_name);
+	
+	struct timeval tv;
+  tv.tv_sec  = ( SOCKET_TIMEOUT_USEC ) / 1000000;
+  tv.tv_usec = ( SOCKET_TIMEOUT_USEC ) % 1000000;
+	if ( setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (void*)&tv, sizeof(tv) ) != 0) {
+		perror("Aborting: Cannot set timeout");
+		return -1;
+	} else {
+    //printf("Input thread recv timeout has been set to %u usecs.\n", SOCKET_TIMEOUT_USEC);
+	}
+
+	memset(&addr,0,sizeof(addr));
+	addr.sll_family   = AF_PACKET;
+	addr.sll_protocol = htons(0x88A4);
+	addr.sll_ifindex  = ifr.ifr_ifindex;
+
+	if ((bind(sock, (struct sockaddr *)&addr, sizeof(addr))) < 0) {
+		perror("Cannot bind to local ip/port");
+		close(sock);
+		return -1;
+	}
+	
+	return sock;
+}
+
+int close_socket(struct netif *ni) {
+  assert(ni!=NULL);
+  char errbuf[ERRBUF_LEN];
+
+  // If sock is < 0, things have not been started
+  if (ni->socket_private < 0) {
+    ec_log(EC_LOG_ERROR, "%s: close called twice on netif\n", __func__);
+    return -1;
+  }
+
+  // First try stopping input thread
+  ec_log(EC_LOG_INFO, "%s : Stopping input thread...\n", __func__);
+  ni->stop = TRUE;
+  int tries = 0;
+  for (tries = 0; tries<10; ++tries) {
+    my_usleep(SOCKET_TIMEOUT_USEC);
+    if (ni->is_stopped) {
+      ec_log(EC_LOG_INFO, "%s : Input thread has stopped\n", __func__);
+      break;    
+    }
+  }
+
+  // Force input thread to exit
+  if (!ni->is_stopped) {
+    ec_log(EC_LOG_ERROR, "%s: input thread d/n stop, cancelling thread\n", __func__);
+    int error = pthread_cancel(ni->input_thread);
+    if (error!=0) {
+      ec_log(EC_LOG_ERROR, "%s: error cancelling input thread : %s\n", __func__, 
+             my_strerror(error,errbuf,sizeof(errbuf)));
+      return -1;
+    }
+    my_usleep(SOCKET_TIMEOUT_USEC);
+  }
+  
+	int ret = close(ni->socket_private);
+	tries = 1;
+	while(ret < 0 && tries < MAX_TRIES_SOCKET) {
+		ret = close(ni->socket_private);
+		tries++;
+		sleep(1);
+	}
+	if(ret < 0)
+		perror("Failed to close socket");
+
+  ni->socket_private = -1;
+  
+  if (ni->is_stopped) {
+    free(ni);
+  }
+
+	return ret;
+}
+
+struct eth_msg {
+	u_int8_t  ether_dhost[ETH_ALEN];      /* destination eth addr */
+	u_int8_t  ether_shost[ETH_ALEN];      /* source ether addr    */
+	u_int8_t  ether_type [2];                 /* packet type ID field */
+	unsigned char  data [MAX_ETH_DATA];
+};
+
+// Send packet, if successfull add handle to list of packet awaiting a response. 
+// Returns postive handle to packet list for success.
+// Returns negative value for errors
+// Assumes txandrx_mut is held when this function is called
+static int low_level_output(struct EtherCAT_Frame * frame, struct netif * netif)
+{
+  struct netif *ni = netif;
+  assert(ni!=NULL);
+  assert(pthread_mutex_lock(&ni->txandrx_mut) == EDEADLK);
+
+  char errbuf[ERRBUF_LEN];
+
+  // Is there a slot to send packet with?
+  if (ni->unclaimed_packets >= MAX_UNCLAIMED_PACKETS) {
+    // Maybe put a condition variable here is the future.
+    ec_log(EC_LOG_FATAL, "%s: too many outstanding packets : %d\n", 
+           __func__, ni->unclaimed_packets);
+    ++ni->counters.tx_full;    
+    return -1;    
+  }
+
+  // Find empty spot in list to store information about the sent packet
+  struct outstanding_pkt* pkt=NULL; 
+  unsigned pkt_index;  
+  { unsigned xx;
+    for (xx=0; xx<PKT_LIST_SIZE; ++xx) {
+      pkt_index = (ni->next_pkt_index + xx) % PKT_LIST_SIZE;
+      struct outstanding_pkt* i_pkt = &ni->pkt_list[pkt_index];
+      if (i_pkt->is_free) {
+        pkt=i_pkt;
+        break;
+      }
+    }
+  }
+
+  // Couldn't find empty slot
+  if (pkt==NULL) {
+    ec_log(EC_LOG_FATAL, "%s: outstanding packet list is full\n", __func__);
+    ++ni->counters.tx_full;
+    return -1;
+  }
+
+  // higher level protocol error. Attempt to map too much data in one ethernet frame
+	struct eth_msg msg_to_send;
+  memset(msg_to_send.data, 0x00, MAX_ETH_DATA);
+	int len_dump = framedump(frame, msg_to_send.data, MAX_ETH_DATA);
+  if(len_dump==0) {
+    ec_log(EC_LOG_FATAL, "%s: message buffer overflow\n", __func__);
+    ++ni->counters.tx_error;
+    return -1;
+  }
+
+  // Send packet
+	int msg_len = len_dump + ETH_ALEN + ETH_ALEN + 2;   
+  int sock = ni->socket_private;
+		// Destination address is broadcast MAC address
+		// FIXME Is this also valid for EtherCAT UDP ethernet frames?
+		memset(msg_to_send.ether_dhost, 0xFF, ETH_ALEN);
+  // Source address, last 3 bytes are used as markers
+  memcpy(msg_to_send.ether_shost, ni->hwaddr, ETH_ALEN);
+  assert(pkt_index<=0xFF);  
+  msg_to_send.ether_shost[3] = pkt_index;  
+  ni->tx_seqnum = (ni->tx_seqnum+1) & 0xFFFF;
+  msg_to_send.ether_shost[4] = ((ni->tx_seqnum) >> 8) & 0xFF;
+  msg_to_send.ether_shost[5] = ((ni->tx_seqnum) >> 0) & 0xFF;
+  
+  // EtherType is ethercat 
+		msg_to_send.ether_type[0] = 0x88;
+		msg_to_send.ether_type[1] = 0xA4;
+	
+
+  // Pad the packet so the data (src + dst + ethertype + payload) is at least 60 bytes
+  // This prevents wireshark from complianing about parsing errors
+  int pkt_len = (msg_len < 60) ? 60 : msg_len;
+
+  // Get send time 
+  if (clock_gettime(CLOCK_REALTIME, &pkt->tx_time) != 0) {
+    int error = errno;
+    ec_log(EC_LOG_FATAL, "%s: Could not get send_time : %s\n",
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+    ++ni->counters.tx_error;
+    return -1;
+  }
+  
+  // Send packet - sending should not block.
+  int len_send = send(sock,(unsigned char *)&msg_to_send, pkt_len, MSG_DONTWAIT);
+  if(len_send < 0) {
+    int error = errno;
+    if (error == ENETDOWN) {
+      ++ni->counters.tx_net_down;
+      if ((ni->counters.tx_net_down & 0xFFF) == 1) {
+        ec_log(EC_LOG_FATAL, "%s: %llu times : %s\n", 
+               __func__, (unsigned long long) ni->counters.tx_net_down, my_strerror(error,errbuf,sizeof(errbuf)));
+      }
+    } 
+    else if ((error == EWOULDBLOCK) || (error == EAGAIN)) 
+    {
+      // On some systems EAGAIN != EWOULDBLOCK and either error code can be returned
+      ++ni->counters.tx_would_block;
+      if ((ni->counters.tx_would_block & 0xFFF) == 1)
+      {
+        ec_log(EC_LOG_FATAL, "%s: %llu times : Cannot Send : would block\n", 
+               __func__, (unsigned long long) ni->counters.tx_would_block);
+      }
+    }
+    else if (error == ENOBUFS)
+    {
+      ++ni->counters.tx_no_bufs;
+      if ((ni->counters.tx_no_bufs & 0xFFF) == 1)
+      {
+        ec_log(EC_LOG_FATAL, "%s: %llu times : Cannot Send : %s\n", 
+               __func__, (unsigned long long) ni->counters.tx_no_bufs,
+               my_strerror(error,errbuf,sizeof(errbuf)));
+      }
+    } 
+    else {
+      static int last_error=0;
+      ++ni->counters.tx_error;
+      if ((error != last_error) || ((ni->counters.tx_error & 0xFFF) == 1))
+      {
+        ec_log(EC_LOG_FATAL, "%s: %llu times : Cannot Send : %s\n", 
+               __func__, (unsigned long long) ni->counters.tx_error, 
+               my_strerror(error,errbuf,sizeof(errbuf)));
+      }
+      last_error = error;
+    }
+    return -1;
+  }
+  if (len_send != pkt_len) {
+    ec_log(EC_LOG_FATAL, "%s: Incomplete send, sent %d or %d bytes\n", 
+           __func__, len_send, pkt_len);
+    ++ni->counters.tx_error;
+    return -1;
+	}
+
+  // Put packet in list of outstanding packets
+  ++ni->unclaimed_packets;
+  pkt->is_free = FALSE; 
+  pkt->frame = frame;
+  memcpy(pkt->ether_shost, msg_to_send.ether_shost, ETH_ALEN);
+
+  // Generate handle for sent packet
+  int handle = 0xFFFFFF &
+    ((pkt->ether_shost[3]<<16) | 
+     (pkt->ether_shost[4]<<8 ) | 
+     (pkt->ether_shost[5]<<0 ));
+  
+  // Start searching when picking next open packet slot
+  ni->next_pkt_index = (ni->next_pkt_index+1) % PKT_LIST_SIZE;
+
+  ++ni->counters.sent;
+  assert(handle >= 0);
+  return handle;
+}
+
+
+//  Last two bytes of src MAC address lets us determine seqnum of packet
+static unsigned parse_seqnum(u_int8_t ether_shost[MAC_ADDRESS_SIZE]) {
+  unsigned seqnum = 
+    ( ((unsigned) ether_shost[4]) << 8) | 
+    ( ((unsigned) ether_shost[5]) << 0) ; 
+  return seqnum;
+}
+
+
+enum input_retcode {RECOVERABLE_ERROR=0,UNRECOVERABLE_ERROR=-1,SUCCESS=1};
+
+// Receives packet and stores it in pkt_list
+// Returns 1 for success
+// Returns -1 for unrecoverable errors (socket problem, not enough input buffers)
+// Returns 0 for a timeout (no packet ready), or recoverable error (invalid packet received, bad packet format)
+// Assumes txandrx_mut is held when this function is called
+static enum input_retcode low_level_input(struct netif * ni)
+{
+  assert(ni!=NULL);
+  assert(pthread_mutex_lock(&ni->txandrx_mut) == EDEADLK);
+
+  char errbuf[ERRBUF_LEN];
+
+  // Find empty packet buffer to hold recieved packet
+	struct pkt_buf *buf = NULL;
+  {unsigned buf_index;
+    for (buf_index=0; buf_index<BUF_LIST_SIZE; ++buf_index) {
+      struct pkt_buf *i_buf = &ni->buf_list[buf_index];
+      if (i_buf->is_free) {
+        buf = i_buf;
+        break;
+      }
+    }
+  }
+  
+  if (buf==NULL) {
+    // No buffer to hold incoming packet      
+    ec_log(EC_LOG_FATAL, "%s : EtherCAT fatal: packet buffer list if full\n", __func__);
+    return UNRECOVERABLE_ERROR;
+  }
+  assert(sizeof(struct eth_msg) < sizeof(buf->data)); //Const assert?
+  struct eth_msg *msg_received = (struct eth_msg *) buf->data;
+
+  // Try to receive message from socket
+  // Don't hold mutex while blocking on recv, also mark buffer as
+  // non-free, so it is not used by a different rx call.
+  int sock = ni->socket_private;
+  buf->is_free = FALSE; 
+  pthread_mutex_unlock(&ni->txandrx_mut);
+  int len_recv = recv(sock,msg_received,sizeof(*msg_received),0);
+  pthread_mutex_lock(&ni->txandrx_mut);
+  buf->is_free = TRUE;
+
+	if(len_recv < 0) {
+    int error = errno;
+    if (error != EAGAIN) { // log error, for anthing other than a timeout
+      ec_log(EC_LOG_ERROR, "%s: Cannot receive msg: %s\n",
+             __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+      if (error == EINTR) {
+        return RECOVERABLE_ERROR;
+      } else {
+        return UNRECOVERABLE_ERROR;
+      }
+    }
+    return RECOVERABLE_ERROR;
+	}
+
+  if (len_recv <= sizeof(ETH_ALEN + ETH_ALEN + 2)) {
+    ec_log(EC_LOG_ERROR, "%s: recieved runt packet: %d\n",__func__,len_recv);
+    ++ni->counters.rx_runt_pkt;
+    return RECOVERABLE_ERROR; // we did receive a packet
+  }
+
+	if ( ((msg_received->ether_type[0]) != 0x88) || (msg_received->ether_type[1]) != 0xA4) {
+		ec_log(EC_LOG_ERROR, "%s: No EtherCAT msg!\n", __func__);
+    ++ni->counters.rx_not_ecat;
+    return RECOVERABLE_ERROR; // we did receive a packet
+  }
+
+  // Use 2nd and 3rd byte of source max address to identify instance of EML that sent this out
+  // Ignore packet with HW addresses from other EML libraries
+  if ((msg_received->ether_shost[1] != ni->hwaddr[1]) ||
+      (msg_received->ether_shost[2] != ni->hwaddr[2]) )
+  {
+    ++ni->counters.rx_other_eml;
+    if ((ni->counters.rx_other_eml & 0x3FF) == 1) {
+      ec_log(EC_LOG_WARNING, 
+             "%s: received %llu packets sent out from another EML instance\n",
+             __func__, (unsigned long long) ni->counters.rx_other_eml);
+    }
+    return RECOVERABLE_ERROR;
+  }
+  
+  // 3rd byte of source MAC address tells us where outstanding packet should be in queue
+  unsigned pkt_index = 0xFF & msg_received->ether_shost[3];
+  if (pkt_index >= PKT_LIST_SIZE) {
+    ec_log(EC_LOG_ERROR, "%s: packet doesn't belong in queue, bad index %d", __func__, pkt_index);  
+    ++ni->counters.rx_bad_index;
+    return RECOVERABLE_ERROR; 
+  }  
+  struct outstanding_pkt *pkt= &ni->pkt_list[pkt_index];
+
+  unsigned rx_seqnum = parse_seqnum(msg_received->ether_shost);
+
+  // Print warning if this packet is a repeat or is recieved out-of-order
+  //  This shouldn't happen with normal setup... It may be worthwhile
+  //  know about this odd situation if it occurs. 
+  int16_t diff = (rx_seqnum - ni->rx_seqnum) & 0xFFFF;
+  // diff == 1 : Good: this is the next expected packet..
+  // diff == 0 : Bad: seems like a duplicate packet has been recieved,
+  // diff <  1 : Bad: seems like an old got packets out-of-order, or old packet has been re-received
+  // diff >  1 : Ok: could mean previous <diff> packets have been
+  //             lost, and this is first to make it back successfully
+  if (diff == 0) {
+    ec_log(EC_LOG_ERROR, "low_level_input: error, got packet with duplicate seqnum %d\n", rx_seqnum);
+    ++ni->counters.rx_dup_seqnum;
+    // allow following checks to drop packet
+  } else if (diff < 0) {
+    // Newer packet has already been recieved, somehow packets got
+    // reordered.  This should not happen on a raw ethernet chain.
+    // Could occur if running ethercat over IP/UDP.
+    // Also, could be caused by buffering in OS.
+    ec_log(EC_LOG_ERROR, 
+           "low_level_input: warning : got packet in incorrect order: got %d, expected %d\n",
+           rx_seqnum, (ni->rx_seqnum+1) & 0xFFFF);
+    ++ni->counters.rx_bad_order;
+    // Don't drop packet might still be uncollected -- 
+    // Allow following to filter it out.
+  } 
+  
+  // Determine if received seqnum matches seqnum used when sending packet
+  unsigned tx_seqnum = parse_seqnum(pkt->ether_shost);
+  if (rx_seqnum != tx_seqnum) {    
+    ec_log(EC_LOG_ERROR, 
+           "low_level_input: got packet with invalid seqnum: got %d, expected %d\n"
+           "    next packet will be sent with seqnum %d\n"
+           "    last received packet had seqnum %d\n" 
+           , rx_seqnum, tx_seqnum, ni->tx_seqnum, ni->rx_seqnum);  
+    ++ni->counters.rx_bad_seqnum;
+    return RECOVERABLE_ERROR;
+  }
+  
+  // Make sure packet has not arrived already 
+  if ( (pkt->buf!=NULL) ) {
+    ec_log(EC_LOG_ERROR, "low_level_input: got duplicate packet?\n");  
+    ++ni->counters.rx_dup_pkt; 
+    return RECOVERABLE_ERROR;
+  }
+
+  // Record most recently received seqnum
+  ni->rx_seqnum = rx_seqnum;
+
+  // Make sure packet has not been collected with rx 
+  if ( (pkt->is_free==TRUE) ) {
+    ec_log(EC_LOG_ERROR, 
+           "%s: got packet that has already been collected with rx(), increase socket timeout?\n", __func__);  
+    ++ni->counters.rx_late_pkt;    
+    // Keep track of how long it actually took for the late packet to get back.
+    struct timespec rx_time;
+    if (clock_gettime(CLOCK_REALTIME, &rx_time) != 0) {
+      int error = errno;
+      ec_log(EC_LOG_FATAL, "%s: Could not get recv time for late packet : %s\n",
+             __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+    } else {
+      unsigned round_trip_time_us = 
+        (rx_time.tv_sec  - pkt->tx_time.tv_sec)  * 1000000 + 
+        (rx_time.tv_nsec - pkt->tx_time.tv_nsec) / 1000;
+      ni->counters.rx_late_pkt_rtt_us = round_trip_time_us;
+      ni->counters.rx_late_pkt_rtt_us_sum += round_trip_time_us;
+      ec_log(EC_LOG_ERROR, 
+             "%s: late packet arrived in %u us, timeout set to %u us\n",
+             __func__, round_trip_time_us, ni->timeout_us);        
+    }
+    return RECOVERABLE_ERROR;
+  }
+
+  // Packet passes all checks... mark outstanding packet as having
+  // received reply - mark buffer as being used.
+  buf->is_free=FALSE;
+  pkt->buf=buf;  
+
+  // Signal anybody waiting on sent packet
+  int error = pthread_cond_broadcast(&pkt->rx_cond);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL, "%s: cond broadcast : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));    
+    return UNRECOVERABLE_ERROR;    
+  }
+
+  ++ni->counters.received;
+  return SUCCESS;
+}
+
+
+// Thread that continuously polls input and puts it into queue
+void* low_level_input_thread_func(void* data) 
+{
+  char errbuf[ERRBUF_LEN];
+
+  // Increase priority of input thread
+  struct sched_param thread_param;
+  int policy = SCHED_FIFO;
+  thread_param.sched_priority = sched_get_priority_max(policy);
+  int error = pthread_setschedparam(pthread_self(), policy, &thread_param);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL, "%s : Setting thread sched : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));    
+  }
+
+  struct netif * ni = (struct netif *) data;
+  ec_log(EC_LOG_INFO, "INFO: Starting input thread\n");    
+  BOOL stop = FALSE;
+  while (stop==FALSE) {
+    error = pthread_mutex_lock(&ni->txandrx_mut);
+    assert(error==0);
+    stop = ni->stop;
+    if (low_level_input(ni)==UNRECOVERABLE_ERROR) {
+      ec_log(EC_LOG_FATAL, "%s : Unrecoverable error on input thread\n", __func__);
+      // Some unrecoverable error can be recovered with external conditions (ENETDOWN)
+      // However, don't spin on recv if it will immediately return an error code
+      //stop = TRUE;
+      my_usleep(10000);
+    }
+    error = pthread_mutex_unlock(&ni->txandrx_mut);    
+    assert(error==0);
+  }
+  ec_log(EC_LOG_INFO, "INFO: Input thread is exiting\n");    
+  ni->is_stopped=TRUE;
+  return NULL;
+}
+
+
+static void init_buf(struct pkt_buf *buf) {
+  buf->is_free = TRUE;
+}
+
+static BOOL init_pkt(struct outstanding_pkt *pkt) {
+  pkt->is_free = TRUE;
+  pkt->buf = NULL;
+  pkt->frame = NULL;
+  memset(pkt->ether_shost, 0, sizeof(pkt->ether_shost));
+
+  int error;
+  char errbuf[ERRBUF_LEN];
+
+  error = pthread_cond_init(&pkt->rx_cond,NULL);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL,"%s : Initializing rx condition var failed : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+// Tries lookup of packet from queue using handle
+// returns NULL if handle is stall/invalid, or pointer to outstanding pkt otherwise;
+// Assumes txandrx mutex is already held
+static struct outstanding_pkt *low_level_lookup(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  assert(frame!=NULL);
+  assert(ni!=NULL);
+  assert(pthread_mutex_lock(&ni->txandrx_mut) == EDEADLK);
+
+  // Make sure handle makes sense, also make sure it is not a negative number
+  if ( ((handle>>24) & 0xFF) != 0) {
+    ec_log(EC_LOG_ERROR, "low_level_lookup: called with invalid handle 0x%08X\n", handle);  
+    return NULL;
+  }
+
+  // Source MAC address packet should have
+  // First 3 bytes are sent by netif source MAC address
+  // Second 3 byte are encoded in handle.
+  u_int8_t ether_shost[ETH_ALEN];
+  memcpy(ether_shost, ni->hwaddr, ETH_ALEN);
+  ether_shost[3] = (handle>>16) & 0xFF;
+  ether_shost[4] = (handle>>8)  & 0xFF;
+  ether_shost[5] = (handle>>0)  & 0xFF;
+    
+  // 3th byte of source MAC address tells us where outstanding packet should be in queue    
+  unsigned pkt_index = 0xFF & ether_shost[3];
+  if (pkt_index >= PKT_LIST_SIZE) {
+    ec_log(EC_LOG_ERROR, "low_level_lookup: handle 0x%08X references bad pkt_index\n", handle, pkt_index);  
+    return NULL; //error
+  }
+  struct outstanding_pkt *pkt = &ni->pkt_list[pkt_index];
+
+  // Check frame stored for outstanding packet against frame that was passed in
+  if (pkt->frame != frame) {
+    ec_log(EC_LOG_ERROR, "low_level_lookup: handle frame d/n match passed in frame \n");  
+    return NULL; //error
+  }
+    
+  // Check MAC address encoded in handle against mac address packet was sent out with
+  if (memcmp(pkt->ether_shost, ether_shost, ETH_ALEN) != 0) {
+    ec_log(EC_LOG_ERROR, "low_level_lookup: tried collecting with stale handle \n");  
+    return NULL; //error
+  }
+    
+  // Make sure packet was not already collected
+  if (pkt->is_free!=FALSE) {
+    ec_log(EC_LOG_ERROR, "low_level_lookup: tried collecting with same handle twice \n");  
+    return NULL; //error
+  }
+
+  return pkt;
+}
+
+
+// Drop packet from queue of outstanding packets.
+// Returns FALSE if packet d/n seem to exist
+// Assumes txandrx mutex is already held
+BOOL low_level_release(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  assert(pthread_mutex_lock(&ni->txandrx_mut) == EDEADLK);
+  
+  // Lookup pointer to packet using handle
+  struct outstanding_pkt *pkt = low_level_lookup(frame, ni, handle);
+  if (pkt == NULL) {
+		return FALSE;
+	}
+
+  // Mark packet buffer as availible  
+  if (pkt->buf!=NULL) {
+    init_buf(pkt->buf);
+  }
+    
+  // Mark outstanding pkt as unused
+  pkt->is_free = TRUE;
+  pkt->buf = NULL;
+  pkt->frame = NULL;
+  // Don't clear source MAC address, to allow detection of packets
+  // that are received late, (rx was called before packet got back)
+
+  // One less outstanding packet
+  assert(ni->unclaimed_packets > 0);
+  --ni->unclaimed_packets;
+
+  // Packets are only released when they are not recieved
+  ++ni->counters.dropped;
+
+  return TRUE;
+}
+
+
+enum dequeue_retcode {DEQUEUE_SUCCESS=1,DEQUEUE_ERROR=-1,DEQUEUE_NOT_FOUND=0};
+
+// Tries retrieving packet from queue using handle
+// returns negative values for error, 0 if no packet is in queue, or postive value if packet is found
+// Assumes txandrx mutex is already held
+static int low_level_dequeue(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  assert(pthread_mutex_lock(&ni->txandrx_mut) == EDEADLK);
+
+  // Lookup pointer to packet using handle
+  struct outstanding_pkt *pkt = low_level_lookup(frame, ni, handle);
+  if (pkt == NULL) {
+    return DEQUEUE_ERROR;
+  }
+
+  // OK, handle is good...
+  // has response packet been received ?
+  if (pkt->buf==NULL) {
+    return DEQUEUE_NOT_FOUND; // packet has not been recieved
+  }
+  assert(pkt->buf->is_free == FALSE);
+    
+  // Response packet has been received...
+    
+  // Get pointer to ethernet packet payout
+  assert(sizeof(struct eth_msg) < sizeof(pkt->buf->data)); //Const assert?
+  struct eth_msg *msg_received = (struct eth_msg *) pkt->buf->data;
+
+  // Mark packet buffer as availible  
+  init_buf(pkt->buf);
+    
+  // Mare outstanding pkt as unused
+  init_pkt(pkt);
+    
+  int success = framebuild(frame,msg_received->data);
+  if (success != 0){
+		// FIXME decent error handling here
+		ec_log(EC_LOG_ERROR, "low_level_input: framebuilding failed!\n");
+     return DEQUEUE_ERROR;
+  }
+    
+  // One less unclaimed packet
+  assert(ni->unclaimed_packets > 0);
+  --ni->unclaimed_packets;
+
+  ++ni->counters.collected;
+  return DEQUEUE_SUCCESS; // Good
+}
+
+// Transmits a packet.  
+// Returns a negative value for errors, or positive integer handle
+//  handle and frame* should be used to get response with ec_posix_rx()
+static int ec_posix_tx(struct EtherCAT_Frame * frame, struct netif * ni) 
+{
+  assert(ni != NULL);
+
+  int error = pthread_mutex_lock (&ni->txandrx_mut);
+  assert(error==0);
+  int handle = low_level_output(frame,ni);
+  error = pthread_mutex_unlock (&ni->txandrx_mut);
+  assert(error==0);
+  return handle;
+}
+
+
+// Receives a packet that has been sent with ec_posix_tx()
+// Returns TRUE for success, FALSE for errors or timeout.
+static BOOL ec_posix_rx_common(struct EtherCAT_Frame * frame, struct netif * ni, int handle, BOOL mayblock) 
+{
+  assert(ni != NULL);
+  assert(frame != NULL);
+  char errbuf[ERRBUF_LEN];        
+
+  // Find rx mutex for outstanding packet
+  struct outstanding_pkt *pkt;
+  int error = pthread_mutex_lock(&ni->txandrx_mut);
+  assert(error==0);
+  if (error!=0) {
+    ec_log(EC_LOG_FATAL, "%s: error locking mutex : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+    return FALSE;
+  }
+  pkt = low_level_lookup(frame, ni, handle); 
+  
+  // Bad handle, double rx, etc...
+  if (pkt == NULL) {
+    pthread_mutex_unlock(&ni->txandrx_mut);
+    return FALSE;
+  }
+
+  // Try pulling result from queue
+  enum dequeue_retcode result = low_level_dequeue(frame, ni, handle);
+
+  // If this can block, try waiting for condition signal
+  if (mayblock) {    
+    // Wait until <timeout_us> after packet was sent
+    struct timespec timeout = pkt->tx_time;
+    timeout.tv_nsec += (ni->timeout_us * 1000);
+    if (timeout.tv_nsec >= NSEC_PER_SEC) {
+      timeout.tv_nsec -= NSEC_PER_SEC;
+      ++timeout.tv_sec;
+    }
+    assert(timeout.tv_nsec < NSEC_PER_SEC);
+    assert(timeout.tv_nsec >= 0);
+    
+    // Put loop around pthread_cond_timedwait to handle spurious wakeups
+    while (result == DEQUEUE_NOT_FOUND) {
+      // Wait on recv condition from input thread 
+      error = pthread_cond_timedwait(&pkt->rx_cond, &ni->txandrx_mut, &timeout);
+      if (error != 0) {
+        if (error == ETIMEDOUT) {
+          // Timeout 
+        } else {
+          ec_log(EC_LOG_FATAL, "%s: error waiting on timed condition : %s\n", 
+                 __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+        }
+        break;
+      } else {
+        result = low_level_dequeue(frame, ni, handle);      
+        // dequeue should always return 1 (since we know the packet is there) 
+        // ... unless there was a spurious wakeup. 
+        if (result == DEQUEUE_NOT_FOUND) {
+          ec_log(EC_LOG_FATAL, "%s: spurious wakeup : dequeue result=%d\n", 
+                 __func__, result);    
+        }
+      }
+    }
+  } //end if mayblock
+   
+  // If we didn't get the packet, release it's resources
+  if (result!=DEQUEUE_SUCCESS) {
+    low_level_release(frame, ni, handle);
+  }
+
+  error = pthread_mutex_unlock(&ni->txandrx_mut);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL, "%s: error unlocking mutex : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+  }
+  return (result==DEQUEUE_SUCCESS) ? TRUE : FALSE;
+}
+
+
+  
+// Drops a packet that has been sent with ec_posix_tx()
+// Returns true for success, false for errors
+static BOOL ec_posix_drop(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  assert(ni != NULL);
+  assert(frame != NULL);
+  char errbuf[ERRBUF_LEN];        
+  
+  // Find rx mutex for outstanding packet
+  struct outstanding_pkt *pkt;
+  int error = pthread_mutex_lock(&ni->txandrx_mut);
+  assert(error==0);
+  pkt = low_level_lookup(frame, ni, handle); 
+   
+  // Bad handle, double rx, etc...
+  if (pkt == NULL) {
+    pthread_mutex_unlock(&ni->txandrx_mut);
+    return FALSE; 
+  }
+ 
+  BOOL success = low_level_release(frame, ni, handle);
+ 
+  if (success) {
+    ++ni->counters.sw_dropped;
+  }    
+   
+  error = pthread_mutex_unlock(&ni->txandrx_mut);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL, "%s: error unlocking mutex : %s\n", 
+           __func__, my_strerror(error,errbuf,sizeof(errbuf)));
+  }
+ 
+  return success;
+}
+ 
+
+// Receives a packet that has been sent with ec_posix_tx()
+// Returns TRUE for success, FALSE for errors or timeout.
+static BOOL ec_posix_rx(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  return ec_posix_rx_common(frame, ni, handle, TRUE);
+}
+
+// Receives a packet that has been sent with ec_posix_tx(), doesn't wait
+// Returns TRUE for success, FALSE for errors or timeout.
+static BOOL ec_posix_rx_nowait(struct EtherCAT_Frame * frame, struct netif * ni, int handle) 
+{
+  return ec_posix_rx_common(frame, ni, handle, FALSE);
+}
+
+
+// Only attempt to send one packet 
+static BOOL ec_posix_txandrx_once(struct EtherCAT_Frame * frame, struct netif * ni) 
+{
+  assert(ni != NULL);
+
+  int handle = ec_posix_tx(frame, ni);
+  if (handle < 0) {
+    return FALSE;
+  }
+  BOOL result = ec_posix_rx(frame, ni, handle);
+  return result;
+}
+
+
+// Normal txandrx, try sending packet multiple times before giving up.
+static BOOL ec_rtdm_txandrx(struct EtherCAT_Frame * frame, struct netif * netif) {
+  struct netif *ni = netif;
+  assert(ni != NULL);
+  char errbuf[ERRBUF_LEN];
+
+	int tries = 0;
+	while (tries < MAX_TRIES_TX) {
+    BOOL success = ec_posix_txandrx_once(frame, ni);
+    if (success) {
+      if (tries > 0) {
+        ec_log(EC_LOG_ERROR, "low_level_txandrx: sending/receiving failed %d times\n", tries);
+			}
+      return TRUE;
+		}
+    int error = pthread_mutex_lock(&ni->txandrx_mut);
+    assert(error==0);
+    //++ni->retries;
+    error = pthread_mutex_unlock(&ni->txandrx_mut);
+    assert(error==0);
+		tries++;
+	}
+  ec_log(EC_LOG_FATAL, "low_level_txandrx: failed %d times: Giving up\n", MAX_TRIES_TX);
+	return FALSE;
+}
+
+
+struct netif* init_ec(const char * interface) {
+        char errbuf[ERRBUF_LEN];
+
+	int sock = init_socket(interface);
+	if(sock < 0) {
+		ec_log(EC_LOG_FATAL,"Socket initialisation failed\n");
+		return 0;
+	}
+
+	struct netif* ni = (struct netif*)malloc(sizeof(struct netif));
+  if (ni==NULL) {
+    ec_log(EC_LOG_FATAL,"Allocating netif struct failed\n");
+    return NULL;
+  }
+	int error = pthread_mutexattr_init(&ni->txandrx_attr);
+	if (error != 0) {
+	  ec_log(EC_LOG_FATAL,"Initializing txandrx mutex attr failed : %s\n", 
+                 my_strerror(error,errbuf,sizeof(errbuf)));
+	  free(ni);
+	  return NULL;
+	}
+
+	error = pthread_mutexattr_settype(&ni->txandrx_attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+	if (error != 0) {
+	  ec_log(EC_LOG_FATAL,"Setting type of mutex attr failed : %s\n", 
+                 my_strerror(error,errbuf,sizeof(errbuf)));
+	  free(ni);
+	  return NULL;
+	}
+
+	error = pthread_mutex_init(&ni->txandrx_mut, &ni->txandrx_attr);
+	if (error != 0) {
+	  ec_log(EC_LOG_FATAL,"Initializing txandrx mutex failed : %s\n", 
+                 my_strerror(error,errbuf,sizeof(errbuf)));
+	  free(ni);
+	  return NULL;
+	}
+
+	int index;
+	for (index=0; index<PKT_LIST_SIZE; ++index) {
+	  if (!init_pkt(&ni->pkt_list[index])) {
+			ec_log(EC_LOG_FATAL,"Initializing pkt %d failed\n", index);
+			free(ni);
+			return NULL;
+	  }
+	}
+
+	for (index=0; index<BUF_LIST_SIZE; ++index) {
+	  init_buf(&ni->buf_list[index]);
+	}
+  
+	ni->txandrx = ec_rtdm_txandrx;
+  ni->txandrx_once = ec_posix_txandrx_once;
+  ni->tx = ec_posix_tx;
+  ni->rx = ec_posix_rx;
+  ni->drop = ec_posix_drop;
+  ni->rx_nowait = ec_posix_rx_nowait;
+
+	ni->socket_private = sock;
+  memset(&ni->counters, 0, sizeof(ni->counters));
+  ni->next_pkt_index = 0;
+  ni->tx_seqnum = 0;
+  ni->rx_seqnum = 0xffff;
+
+  ni->timeout_us = TIMEOUT_USEC;
+
+  ni->unclaimed_packets = 0;
+
+  // To differentiate between different implemenations of EML library, 
+  // Use a random-ish value for 2nd and 3rd bytes src MAC address
+  struct timeval tv;
+  if (gettimeofday(&tv, NULL) != 0) {
+    ec_log(EC_LOG_ERROR,"Gettimeofday : %s\n", 
+           my_strerror(error,errbuf,sizeof(errbuf)));
+  }
+  int r = tv.tv_sec ^ tv.tv_usec;
+
+	//Mac-address
+	ni->hwaddr[0] = 0x00; ni->hwaddr[2] = r   ; ni->hwaddr[4] = 0x00;
+	ni->hwaddr[1] = r>>8; ni->hwaddr[3] = 0x00; ni->hwaddr[5] = 0x00;
+
+  // Start input thread
+  ni->stop = FALSE;
+  ni->is_stopped = FALSE;
+  error = pthread_create(&ni->input_thread, NULL, low_level_input_thread_func, ni);
+  if (error != 0) {
+    ec_log(EC_LOG_FATAL,"Starting input thread failed : %s\n", 
+           my_strerror(error,errbuf,sizeof(errbuf)));
+    free(ni);
+    return NULL;
+  }
+	return ni;
+
+}
diff --git a/src/dll/ethercat_device_addressed_telegram.cxx ./src/dll/ethercat_device_addressed_telegram.cxx
new file mode 100644
index 0000000..e4204b7
--- /dev/null
+++ ./src/dll/ethercat_device_addressed_telegram.cxx
@@ -0,0 +1,313 @@
+// $Id: ethercat_device_addressed_telegram.cxx,v 1.9 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include <assert.h>
+#include "dll/ethercat_device_addressed_telegram.h"
+// --------------------------------------------------
+// Device Addressing Telegram
+// --------------------------------------------------
+
+// Defining the different types of possible telegrams
+static const EC_USINT APRD = 0x01; // Autoincrement Physical read
+static const EC_USINT NPRD = 0x04; // Node addressed Physical read
+static const EC_USINT APWR = 0x02; // Autoincrement Physical write
+static const EC_USINT NPWR = 0x05; // Node addressed Physical write
+static const EC_USINT APRW = 0x03; // Autoincrement Physical read_write
+static const EC_USINT NPRW = 0x06; // Node addressed Physical read-write
+static const EC_USINT ARMW = 0x0d; // Autoincrement Physical write
+				   // Multiple write
+static const EC_USINT BRD  = 0x07; // Broadcast Read
+static const EC_USINT BWR  = 0x08; // Broadcast Write
+
+#define DA_TG Device_Addressing_Telegram
+DA_TG::DA_TG(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, 
+	     EC_UINT a_wkc, EC_UINT a_datalen, 
+	     const unsigned char * a_data)
+  : EC_Telegram(a_datalen, a_data, a_idx, a_wkc),
+    m_adp(a_adp),
+    m_ado(a_ado)
+{
+}
+
+DA_TG::~DA_TG(){}
+
+unsigned char * 
+DA_TG::dump_header_head(unsigned char * a_buffer) const
+{
+  a_buffer = this->dump_command_field(a_buffer);
+  a_buffer = host2nw(a_buffer, m_idx);
+  a_buffer = host2nw(a_buffer, m_adp);
+  a_buffer = host2nw(a_buffer, m_ado);
+  return a_buffer;
+}
+
+const unsigned char * DA_TG::build_header_head(const unsigned char * a_buffer)
+{
+  a_buffer = this->build_command_field(a_buffer);
+  
+  if (this->check_index(a_buffer) == true){
+    a_buffer++;
+    // Read ADP (could be altered)
+    a_buffer = nw2host(a_buffer, m_adp);
+    // Read ADO:  FIXME: could add check if this is not altered either
+    a_buffer = nw2host(a_buffer, m_ado);
+    // Leave pointer at the start of the data field
+    return a_buffer;
+  }
+  else return NULL;
+}
+
+// --------------------------------------------------
+// Auto Increment Physical Read Telegram
+// --------------------------------------------------
+APRD_Telegram::APRD_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+APRD_Telegram::~APRD_Telegram()
+{
+}
+
+unsigned char * 
+APRD_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, APRD);
+  return a_buffer;
+}
+
+const unsigned char * APRD_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == APRD);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Auto Increment Physical Write Telegram
+// --------------------------------------------------
+APWR_Telegram::APWR_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+APWR_Telegram::~APWR_Telegram(){}
+
+unsigned char * 
+APWR_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, APWR);
+  return a_buffer;
+}
+
+const unsigned char * APWR_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == APWR);
+  return ++a_buffer;
+}
+
+// --------------------------------------------------
+// Auto Increment Physical Read Write Telegram
+// --------------------------------------------------
+APRW_Telegram::APRW_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+APRW_Telegram::~APRW_Telegram(){}
+
+unsigned char * 
+APRW_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, APRW);
+  return a_buffer;
+}
+
+const unsigned char * APRW_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == APRW);
+  return ++a_buffer;
+}
+
+// --------------------------------------------------
+// Broadcast Write Telegram
+// --------------------------------------------------
+BWR_Telegram::BWR_Telegram(EC_USINT a_idx, EC_UINT a_ado, 
+			   EC_UINT a_wkc, EC_UINT a_datalen, 
+			   const unsigned char * a_data)
+  : DA_TG(a_idx, 0x0000, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+BWR_Telegram::~BWR_Telegram(){}
+
+unsigned char * 
+BWR_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, BWR);
+  return a_buffer;
+}
+
+const unsigned char * BWR_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == BWR);
+  return ++a_buffer;
+}
+
+// --------------------------------------------------
+// Broadcast Read Telegram
+// --------------------------------------------------
+BRD_Telegram::BRD_Telegram(EC_USINT a_idx, EC_UINT a_ado, 
+			   EC_UINT a_wkc, EC_UINT a_datalen, 
+			   const unsigned char * a_data)
+  : DA_TG(a_idx, 0x0000, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+BRD_Telegram::~BRD_Telegram(){}
+
+unsigned char * 
+BRD_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, BRD);
+  return a_buffer;
+}
+
+const unsigned char * BRD_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == BRD);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Node Addressed Physical Write Telegram
+// --------------------------------------------------
+NPWR_Telegram::NPWR_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+NPWR_Telegram::~NPWR_Telegram(){}
+
+unsigned char * 
+NPWR_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, NPWR);
+  return a_buffer;
+}
+
+const unsigned char * NPWR_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == NPWR);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Node Addressed Physical Read Telegram
+// --------------------------------------------------
+NPRD_Telegram::NPRD_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+NPRD_Telegram::~NPRD_Telegram(){}
+
+unsigned char * 
+NPRD_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, NPRD);
+  return a_buffer;
+}
+
+const unsigned char * NPRD_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == NPRD);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Node Addressed Physical Read Write Telegram
+// --------------------------------------------------
+NPRW_Telegram::NPRW_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+NPRW_Telegram::~NPRW_Telegram(){}
+
+unsigned char * 
+NPRW_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, NPRW);
+  return a_buffer;
+}
+
+const unsigned char * NPRW_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == NPRW);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Auto Increment Physical Read Multiple Write Telegram
+// --------------------------------------------------
+ARMW_Telegram::ARMW_Telegram(EC_USINT a_idx, EC_UINT a_adp, EC_UINT a_ado, EC_UINT a_wkc,
+			     EC_UINT a_datalen, const unsigned char * a_data)
+  : DA_TG(a_idx, a_adp, a_ado, a_wkc, a_datalen, a_data)
+{
+}
+
+ARMW_Telegram::~ARMW_Telegram(){}
+
+unsigned char * 
+ARMW_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, ARMW);
+  return a_buffer;
+}
+
+const unsigned char * ARMW_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == ARMW);
+  return ++a_buffer;
+}
diff --git a/src/dll/ethercat_dll.cxx ./src/dll/ethercat_dll.cxx
new file mode 100644
index 0000000..a4cc297
--- /dev/null
+++ ./src/dll/ethercat_dll.cxx
@@ -0,0 +1,97 @@
+// $Id: ethercat_dll.cxx,v 1.30 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include <string.h>
+#include "ethercat/ethercat_log.h"
+#include "dll/ethercat_dll.h"
+#include "dll/ethercat_frame.h"
+#include "dll/ethercat_device_addressed_telegram.h"
+#include "dll/ethercat_logical_addressed_telegram.h"
+#include "ethercat/netif.h"
+//#include "pkgconf/net_ethercatmaster.h"
+
+#include "unistd.h"
+
+
+
+EtherCAT_DataLinkLayer * EtherCAT_DataLinkLayer::m_instance = 0;
+
+EtherCAT_DataLinkLayer::EtherCAT_DataLinkLayer()
+  : m_if(0)
+{
+}
+
+EtherCAT_DataLinkLayer::~EtherCAT_DataLinkLayer()
+{
+}
+
+EtherCAT_DataLinkLayer * EtherCAT_DataLinkLayer::instance(void)
+{
+  if(!m_instance) {
+    m_instance = new EtherCAT_DataLinkLayer();
+  }
+
+  return m_instance;
+}
+
+bool EtherCAT_DataLinkLayer::txandrx(EtherCAT_Frame * a_frame)
+{
+  bool succeed = m_if->txandrx(a_frame, m_if);
+  if (!succeed)
+    ec_log(EC_LOG_INFO, "DLL::txandrx() Error\n");
+  return succeed;
+}
+
+int EtherCAT_DataLinkLayer::tx(EtherCAT_Frame * a_frame)
+{
+  int handle = m_if->tx(a_frame, m_if);
+  if (handle < 0)
+    ec_log(EC_LOG_INFO, "DLL::tx Error\n");
+  return handle;
+}
+
+bool EtherCAT_DataLinkLayer::rx(EtherCAT_Frame * a_frame, int a_handle)
+{
+  bool succeed = m_if->rx(a_frame, m_if, a_handle);
+  if (!succeed)
+    ec_log(EC_LOG_INFO, "DLL::rx Error\n");
+  return succeed;
+}
+
+void EtherCAT_DataLinkLayer::attach(struct netif * netif)
+{
+  m_if = netif;
+}
+
+
+
diff --git a/src/dll/ethercat_frame.cxx ./src/dll/ethercat_frame.cxx
new file mode 100644
index 0000000..a09f51a
--- /dev/null
+++ ./src/dll/ethercat_frame.cxx
@@ -0,0 +1,161 @@
+// $Id: ethercat_frame.cxx,v 1.18 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include "dll/ethercat_frame.h"
+#include "ethercat/ethercat_log.h"
+
+externC int framedump(const struct EtherCAT_Frame * frame, 
+		      unsigned char * buffer, 
+		      size_t bufferlength)
+{
+  EC_UINT length = 0;
+  if ( (length = frame->length()) <= bufferlength )
+    {
+      frame->dump(buffer);
+    }
+  else { return 0;}
+  return length;
+}
+
+externC int framebuild(struct EtherCAT_Frame * frame,
+		       const unsigned char * buffer)
+{
+  return (frame->build(buffer));
+}
+
+// --------------------------------------------------
+// EC_Frame
+// --------------------------------------------------
+
+EC_Frame::EC_Frame()
+  : m_telegram(NULL){};
+
+EC_Frame::EC_Frame(EC_Telegram * a_telegram)
+  : m_telegram(a_telegram){};
+
+EC_Frame::~EC_Frame()
+{
+}
+
+size_t
+EC_Frame::body_length(void) const
+{
+  int result = 0;
+  if (m_telegram)
+    {
+      EC_Telegram * tg = m_telegram;
+      result += tg->length();
+      while (tg->next != NULL)
+	{
+	  tg = tg->next;
+	  result += tg->length();
+	} 
+    }
+  return result;
+}
+
+unsigned char *
+EC_Frame::dump(unsigned char * a_buffer) const
+{
+  a_buffer = dump_header(a_buffer);
+  if (m_telegram){
+    EC_Telegram * tg = m_telegram;
+    a_buffer = tg->dump(a_buffer);
+    while (tg->next != NULL){
+      tg = tg->next;
+      a_buffer = tg->dump(a_buffer);
+    }
+  }
+  return a_buffer;
+}
+
+int
+EC_Frame::build(const unsigned char * a_buffer)
+{
+  if (this->check_header(a_buffer) == true)
+    {
+      a_buffer += ETHERCAT_ETHERNET_FRAME_HEADER_SIZE;
+      // a_buffer now points to the first telegram
+      // current telegram in frame, initialised to first telegram
+      EC_Telegram * tg = this->get_telegram();
+      while(tg) {
+	if ((a_buffer  = tg->build(a_buffer)) == NULL)
+	  return -1;
+	else
+	  tg = tg->next;
+      }
+      return 0;
+    }
+  else return -1;
+}
+
+// --------------------------------------------------
+// EC_Ethernet_Frame
+// --------------------------------------------------
+EC_Ethernet_Frame::EC_Ethernet_Frame(EC_Telegram * a_telegram)
+  : EC_Frame(a_telegram)
+{
+}
+
+
+unsigned char *
+EC_Ethernet_Frame::dump_header(unsigned char * a_buffer) const
+{
+  // Implementation: LSB = length, then Reserved, then MSB = type
+  EC_UINT tmp = 0x01; // Type = Ethercat command
+  tmp = tmp << 12;
+  tmp |= this->body_length();
+
+  a_buffer = host2nw(a_buffer, tmp);
+  return a_buffer;
+}
+
+bool
+EC_Ethernet_Frame::check_header(const unsigned char * a_buffer) const
+{
+  const unsigned char * dataptr = a_buffer;
+  EC_UINT frame_header;
+  dataptr=nw2host(dataptr,frame_header);
+  
+  EC_UINT ec_command = 0x1000;
+  if (ec_command == (frame_header & ec_command))
+    {
+      EC_UINT bodylength = 0x07ff;
+      if (this->body_length() == (size_t) (frame_header & bodylength))
+	return true;
+    }
+  ec_log(EC_LOG_ERROR, "building frame: checkheader failed\n");
+  return false;
+}
+
+
+
diff --git a/src/dll/ethercat_logical_addressed_telegram.cxx ./src/dll/ethercat_logical_addressed_telegram.cxx
new file mode 100644
index 0000000..eec2510
--- /dev/null
+++ ./src/dll/ethercat_logical_addressed_telegram.cxx
@@ -0,0 +1,164 @@
+// $Id: ethercat_logical_addressed_telegram.cxx,v 1.6 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include <assert.h>
+#include "dll/ethercat_logical_addressed_telegram.h"
+
+static const EC_USINT LRD  = 0x0a; // Logical Read
+static const EC_USINT LWR  = 0x0b; // Logical Write
+static const EC_USINT LRW  = 0x0c; // Logical Read-Write
+
+// --------------------------------------------------
+// Logical Addressing Telegram
+// --------------------------------------------------
+
+#define LA_TG Logical_Addressing_Telegram
+LA_TG::LA_TG(EC_USINT a_idx, EC_UDINT a_adr,
+	     EC_UINT a_wkc, EC_UINT a_datalen, 
+	     const unsigned char * a_data)
+  : EC_Telegram(a_datalen, a_data, a_idx, a_wkc),
+    m_adr(a_adr)
+{
+}
+
+LA_TG::~LA_TG(){}
+
+unsigned char * 
+LA_TG::dump_header_head(unsigned char * a_buffer) const
+{
+  a_buffer = this->dump_command_field(a_buffer);
+  a_buffer = host2nw(a_buffer, m_idx);
+  a_buffer = host2nw(a_buffer, m_adr);
+  return a_buffer;
+}
+
+const unsigned char * LA_TG::build_header_head(const unsigned char * a_buffer)
+{
+  a_buffer = this->build_command_field(a_buffer);
+  
+  if (this->check_index(a_buffer) == true){
+    a_buffer++;
+    // Read ADR (Fixme, check if not altered)
+    a_buffer = nw2host(a_buffer, m_adr);
+    // Leave pointer at the start of the data field
+    return a_buffer;
+  }
+  else return NULL;
+}
+
+// --------------------------------------------------
+// Logical Read Telegram
+// --------------------------------------------------
+LRD_Telegram::LRD_Telegram(EC_USINT a_idx,  EC_UDINT a_adr, 
+			   EC_UINT a_wkc, EC_UINT a_datalen, 
+			   const unsigned char * a_data)
+  : LA_TG(a_idx, a_adr, a_wkc, a_datalen, a_data)
+{
+}
+
+
+LRD_Telegram::~LRD_Telegram()
+{
+}
+
+unsigned char * 
+LRD_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, LRD);
+  return a_buffer;
+}
+
+const unsigned char * LRD_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == LRD);
+  return ++a_buffer;
+}
+
+// --------------------------------------------------
+// Logical Write Telegram
+// --------------------------------------------------
+LWR_Telegram::LWR_Telegram(EC_USINT a_idx,  EC_UDINT a_adr, 
+			   EC_UINT a_wkc, EC_UINT a_datalen, 
+			   const unsigned char * a_data)
+  : LA_TG(a_idx, a_adr, a_wkc, a_datalen, a_data)
+{
+}
+
+
+LWR_Telegram::~LWR_Telegram()
+{
+}
+
+unsigned char * 
+LWR_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, LWR);
+  return a_buffer;
+}
+
+const unsigned char * LWR_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == LWR);
+  return ++a_buffer;
+}
+
+
+// --------------------------------------------------
+// Logical Read Write Telegram
+// --------------------------------------------------
+LRW_Telegram::LRW_Telegram(EC_USINT a_idx,  EC_UDINT a_adr, 
+			   EC_UINT a_wkc, EC_UINT a_datalen, 
+			   const unsigned char * a_data)
+  : LA_TG(a_idx, a_adr, a_wkc, a_datalen, a_data)
+{
+}
+
+
+LRW_Telegram::~LRW_Telegram()
+{
+}
+
+unsigned char * 
+LRW_Telegram::dump_command_field(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer, LRW);
+  return a_buffer;
+}
+
+const unsigned char * LRW_Telegram::build_command_field(const unsigned char * a_buffer)
+{
+  assert(a_buffer[0] == LRW);
+  return ++a_buffer;
+}
+
+
diff --git a/src/dll/ethercat_slave_memory.cxx ./src/dll/ethercat_slave_memory.cxx
new file mode 100644
index 0000000..85777bd
--- /dev/null
+++ ./src/dll/ethercat_slave_memory.cxx
@@ -0,0 +1,281 @@
+// $Id: ethercat_slave_memory.cxx,v 1.10 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "dll/ethercat_slave_memory.h"
+
+EC_DLInformation::EC_DLInformation(EC_USINT type,
+				   EC_USINT revision,
+				   EC_UINT build,
+				   EC_USINT no_of_supp_fmmu_channels,
+				   EC_USINT no_of_supp_syncman_channels,
+				   EC_USINT ram_size,
+				   bool fmmu_bit_operation_not_supp)
+  : EC_DataStruct(EC_DLInformationSize),
+    Type(type),
+    Revision(revision),
+    Build(build),
+    NoOfSuppFmmuChannels(no_of_supp_fmmu_channels),
+    NoOfSuppSyncManChannels(no_of_supp_fmmu_channels),
+    RamSize(ram_size),
+    FmmuBitOperationNotSupp(fmmu_bit_operation_not_supp){};
+
+EC_DLInformation::EC_DLInformation(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_DLInformationSize)
+{
+  a_buffer = nw2host(a_buffer,Type);
+  a_buffer = nw2host(a_buffer,Revision);
+  a_buffer = nw2host(a_buffer,Build);
+  a_buffer = nw2host(a_buffer,NoOfSuppFmmuChannels);
+  a_buffer = nw2host(a_buffer,NoOfSuppSyncManChannels);
+  a_buffer = nw2host(a_buffer,RamSize);
+  EC_USINT reserved = 0x00;
+  a_buffer = nw2host(a_buffer,reserved);
+  EC_UINT fmmu_bit_op_not_supp = 0x0000;
+  a_buffer = nw2host(a_buffer,fmmu_bit_op_not_supp);
+  FmmuBitOperationNotSupp = bool (fmmu_bit_op_not_supp & 0x0001);
+}
+
+unsigned char * 
+EC_DLInformation::dump(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer,Type);
+  a_buffer = host2nw(a_buffer,Revision);
+  a_buffer = host2nw(a_buffer,Build);
+  a_buffer = host2nw(a_buffer,NoOfSuppFmmuChannels);
+  a_buffer = host2nw(a_buffer,NoOfSuppSyncManChannels);
+  a_buffer = host2nw(a_buffer,RamSize);
+  EC_USINT reserved = 0x00;
+  a_buffer = host2nw(a_buffer,reserved);
+  EC_UINT fmmu_bit_op_not_supp = (EC_UINT) FmmuBitOperationNotSupp;
+  a_buffer = host2nw(a_buffer,fmmu_bit_op_not_supp);
+  EC_UINT reservedword = 0x0000;
+  a_buffer = host2nw(a_buffer,reservedword);
+  return a_buffer;
+}
+// ==================================================
+
+EC_ALControl::EC_ALControl(EC_State state, bool ack)
+  : EC_DataStruct(EC_Slave_RD[AL_Control].size),
+    State(state),
+    Acknowledge(ack){};
+
+EC_ALControl::EC_ALControl(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_Slave_RD[AL_Control].size)
+{
+  ec_log(EC_LOG_ERROR, "Not implemented yet\n");
+}
+
+unsigned char * 
+EC_ALControl::dump(unsigned char * a_buffer) const
+{
+  EC_USINT firstbyte = State | ((EC_USINT) Acknowledge << 4);
+  a_buffer = host2nw(a_buffer,firstbyte);
+  EC_USINT applicationspecific = 0x00;
+  a_buffer = host2nw(a_buffer,applicationspecific);
+  return a_buffer;
+}
+
+// ==================================================
+
+EC_ALStatus::EC_ALStatus(EC_State state, bool change)
+  : EC_DataStruct(EC_Slave_RD[AL_Status].size),
+    State(state),
+    Change(change){};
+
+EC_ALStatus::EC_ALStatus(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_Slave_RD[AL_Status].size)
+{
+  EC_USINT firstbyte;
+  a_buffer = nw2host(a_buffer,firstbyte);
+  // FIXME This is not foolproof as long as EC_State is an enum.
+  State = (EC_State) (firstbyte & 0x0f); // 4 LSB bits represent state
+  Change = (bool) (firstbyte & 0x10); // 5the byte represents change
+}
+
+unsigned char * 
+EC_ALStatus::dump(unsigned char * a_buffer) const
+{
+  EC_USINT firstbyte = State | (((EC_USINT) Change) << 4);
+  a_buffer = host2nw(a_buffer,firstbyte);
+  EC_USINT applicationspecific = 0x00;
+  a_buffer = host2nw(a_buffer,applicationspecific);
+  return a_buffer;
+}
+// ==================================================
+
+EC_SIIControlStatus::EC_SIIControlStatus(bool eeprom_write_access,
+					 bool eeprom_address_algorithm ,
+					 bool read_op ,
+					 bool write_op ,
+					 bool reload_op ,
+					 bool write_error ,
+					 bool busy)
+  : EC_DataStruct(EC_Slave_RD[SII_ControlStatus].size),
+    EepromWriteAccess(eeprom_write_access),
+    EepromAddressAlgorithm(eeprom_address_algorithm),
+    ReadOp(read_op),
+    WriteOp(write_op),
+    ReloadOp(reload_op),
+    WriteError(write_error),
+    Busy(busy),
+    AcknowledgeError(false)
+{}
+
+EC_SIIControlStatus::EC_SIIControlStatus(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_Slave_RD[SII_ControlStatus].size)
+{
+  EC_UINT byte;
+  a_buffer = nw2host(a_buffer,byte);
+  EepromWriteAccess = (bool) (byte & 0x01);
+  EepromAddressAlgorithm = (bool) ((byte & 0x80) >> 7);
+  ReadOp = (bool) ((byte & 0x100) >> 8);
+  WriteOp = (bool) ((byte & 0x200) >> 9);
+  ReloadOp = (bool) ((byte & 0x400) >> 10);
+  AcknowledgeError = (bool) ((byte & 0x2000) >> 13);
+  WriteError = (bool) ((byte & 0x4000) >> 14);
+  Busy = (bool) ((byte & 0x8000) >> 15);
+}
+
+unsigned char *
+EC_SIIControlStatus::dump(unsigned char * a_buffer) const
+{
+  EC_UINT byte = 0x00;
+  byte |= (EC_UINT) EepromWriteAccess;
+  byte |= ((EC_UINT) EepromAddressAlgorithm ) << 7;
+  byte |= ((EC_UINT) ReadOp ) << 8;
+  byte |= ((EC_UINT) WriteOp ) << 9;
+  byte |= ((EC_UINT) ReloadOp) << 10;
+  byte |= ((EC_UINT) AcknowledgeError) << 13;
+  byte |= ((EC_UINT) WriteError) << 14;
+  byte |= ((EC_UINT) Busy) << 15;
+  return host2nw(a_buffer,byte);
+}
+
+// ==================================================
+EC_FMMU::EC_FMMU(EC_UDINT logical_start_address,
+		 EC_UINT length,
+		 EC_BitPos logical_start_bit,
+		 EC_BitPos logical_end_bit,
+		 EC_UINT physical_start_address,
+		 EC_BitPos physical_start_bit,
+		 bool read_enable,
+		 bool write_enable,
+		 bool channel_enable)
+  : EC_DataStruct(EC_Slave_RD[FMMU_0].size),
+    LogicalStartAddress(logical_start_address),
+    Length(length),
+    LogicalStartBit(logical_start_bit),
+    LogicalEndBit(logical_end_bit),
+    PhysicalStartAddress(physical_start_address),
+    PhysicalStartBit(physical_start_bit),
+    ReadEnable(read_enable),
+    WriteEnable(write_enable),
+    ChannelEnable(channel_enable){};
+
+EC_FMMU::EC_FMMU(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_Slave_RD[FMMU_0].size)
+{
+  ec_log(EC_LOG_ERROR, "Not implemented yet");
+}
+
+unsigned char *
+EC_FMMU::dump(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer,LogicalStartAddress);
+  a_buffer = host2nw(a_buffer,Length);
+  a_buffer = host2nw(a_buffer,(EC_USINT) LogicalStartBit);
+  a_buffer = host2nw(a_buffer,(EC_USINT) LogicalEndBit);
+  a_buffer = host2nw(a_buffer,PhysicalStartAddress);
+  a_buffer = host2nw(a_buffer,(EC_USINT) PhysicalStartBit);
+
+  EC_USINT rw = ReadEnable | (((EC_USINT) WriteEnable) << 1);
+  a_buffer = host2nw(a_buffer,rw);
+  a_buffer = host2nw(a_buffer,(EC_USINT) ChannelEnable);
+  EC_USINT reserved = 0x00;
+  a_buffer = host2nw(a_buffer,reserved);
+  a_buffer = host2nw(a_buffer,reserved);
+  a_buffer = host2nw(a_buffer,reserved);
+  return a_buffer;
+}
+
+// ==================================================
+
+EC_SyncMan::EC_SyncMan(EC_UINT physical_start_address,
+		       EC_UINT length,
+		       EC_BufferType buffer_type,
+		       EC_Direction direction,
+		       bool AL_event_enable,
+		       bool watchdog_enable,
+		       bool write_event,
+		       bool read_event,
+		       bool watchdog_trigger,
+		       bool queued_state,
+		       EC_BufferedState buffered_state,
+		       bool channel_enable)
+  : EC_DataStruct(EC_Slave_RD[Sync_Manager_0].size),
+    PhysicalStartAddress(physical_start_address),
+    Length(length),
+    BufferType(buffer_type),
+    Direction(direction),
+    ALEventEnable(AL_event_enable),
+    ECATEventEnable(false),
+    WatchdogEnable(watchdog_enable),
+    WriteEvent(write_event),
+    ReadEvent(read_event),
+    WatchdogTrigger(watchdog_trigger),
+    QueuedState(queued_state),
+    BufferedState(buffered_state),
+    ChannelEnable(channel_enable){};
+
+EC_SyncMan::EC_SyncMan(const unsigned char * a_buffer)
+  : EC_DataStruct(EC_Slave_RD[Sync_Manager_0].size)
+{
+  ec_log(EC_LOG_ERROR, "Not implemented yet\n");
+}
+
+unsigned char *
+EC_SyncMan::dump(unsigned char * a_buffer) const
+{
+  a_buffer = host2nw(a_buffer,PhysicalStartAddress);
+  a_buffer = host2nw(a_buffer,Length);
+  // fixme explicit cast necessary here?
+  EC_USINT thirdbyte = BufferType | (Direction << 2) | ((EC_USINT) ECATEventEnable << 4) | ((EC_USINT) ALEventEnable << 5) | ((EC_USINT) WatchdogEnable << 6);
+  a_buffer = host2nw(a_buffer,thirdbyte);
+  EC_USINT fourthbyte = (EC_USINT) WriteEvent | ((EC_USINT) ReadEvent << 1) | ((EC_USINT) WatchdogTrigger << 2) | ((EC_USINT) QueuedState << 3) | (BufferedState << 4);
+  a_buffer = host2nw(a_buffer,fourthbyte);
+  a_buffer = host2nw(a_buffer,(EC_UINT) ChannelEnable);
+  return a_buffer;
+}
+
+// ==================================================
+  
diff --git a/src/dll/ethercat_telegram.cxx ./src/dll/ethercat_telegram.cxx
new file mode 100644
index 0000000..f84c56e
--- /dev/null
+++ ./src/dll/ethercat_telegram.cxx
@@ -0,0 +1,203 @@
+// $Id: ethercat_telegram.cxx,v 1.28 2006/02/20 15:57:33 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+ 
+#include "dll/ethercat_telegram.h"
+#include "ethercat/ethercat_log.h"
+#include <assert.h>
+
+// Number of bits of the Reserved and NEXT field
+static const EC_UINT ETHERCAT_LEN_NUM_BITS = 11;
+static const EC_UINT ETHERCAT_RESERVED_NUM_BITS = 4;
+static const EC_UINT ETHERCAT_NEXT_NUM_BITS = 1;
+
+// --------------------------------------------------
+// Class Telegram
+// --------------------------------------------------
+EC_Telegram::EC_Telegram(size_t a_datasize, const unsigned char * a_data)
+  : EC_DataStruct(a_datasize + 
+		  ETHERCAT_TELEGRAM_HEADER_SIZE +
+		  ETHERCAT_TELEGRAM_WKC_SIZE),
+		  m_data(a_data), m_idx(0), m_wkc(0)
+{
+  this->next = NULL;
+  this->previous = NULL;
+}
+
+EC_Telegram::EC_Telegram(EC_USINT a_idx, EC_UINT a_wkc)
+  : EC_DataStruct(ETHERCAT_TELEGRAM_HEADER_SIZE +
+		  ETHERCAT_TELEGRAM_WKC_SIZE),
+    m_data(NULL),
+    m_idx(a_idx), m_wkc(a_wkc)
+{
+  this->next = NULL;
+  this->previous = NULL;
+}
+
+EC_Telegram::EC_Telegram(size_t a_datasize, const unsigned char * a_data, EC_USINT a_idx, EC_UINT a_wkc)
+  : EC_DataStruct(a_datasize + 
+		  ETHERCAT_TELEGRAM_HEADER_SIZE +
+		  ETHERCAT_TELEGRAM_WKC_SIZE),
+    m_data(a_data), m_idx(a_idx), m_wkc(a_wkc)
+{
+  this->next = NULL;
+  this->previous = NULL;
+}
+
+EC_Telegram::EC_Telegram(const EC_Telegram& a_telegram)
+  : EC_DataStruct(a_telegram), m_data(a_telegram.m_data)
+{
+  this->next = a_telegram.next;
+  this->previous = a_telegram.previous;
+  m_idx = a_telegram.get_idx();
+  m_wkc = a_telegram.get_wkc();
+}
+
+EC_Telegram::~EC_Telegram()
+{
+}
+
+unsigned char * EC_Telegram::dump(unsigned char * a_buffer) const
+{
+  // Dump first 6 bytes of header
+  a_buffer = dump_header_head(a_buffer);
+  // Dump remaining 4 bytes of header
+  EC_UINT tmp = get_datalen();
+  // Implementation: NEXT = MSB
+  if(this->next){
+    EC_UINT a_chained_int = 1;
+    a_chained_int = a_chained_int << (ETHERCAT_LEN_NUM_BITS + ETHERCAT_RESERVED_NUM_BITS);
+    tmp |= a_chained_int;
+  }
+  a_buffer = host2nw(a_buffer, tmp);
+  a_buffer = host2nw(a_buffer, m_irq);
+  // Dump data
+  memcpy(a_buffer, m_data, get_datalen());
+  a_buffer += get_datalen();
+  // Dump wkc
+  return host2nw(a_buffer, m_wkc);
+}
+
+const unsigned char * EC_Telegram::build(const unsigned char * buffer)
+{
+  // Build and check first 6 bytes of header
+  buffer = this->build_header_head(buffer);
+  if (buffer != NULL){
+    // Check 4 remaining bytes of header
+    if (check_lennext(buffer) == true)
+      buffer += sizeof(EC_UINT);
+    else return NULL;
+    // IRQ is currently not used
+    EC_UINT irq;
+    buffer = nw2host(buffer, irq);
+
+    // build body
+    buffer = this->build_body(buffer);
+    // build tail
+    buffer = nw2host(buffer,m_wkc);
+    return buffer;
+  }
+  else return NULL;
+}
+
+const unsigned char * EC_Telegram::build_body(const unsigned char * buffer)
+{
+  unsigned char * data = (unsigned char *) m_data;
+  memcpy(data,buffer,get_datalen());
+  return buffer + get_datalen();
+}
+
+// Check if the index is unaltered
+bool EC_Telegram::check_index(const unsigned char * buffer) const
+{
+  const unsigned char * tmpptr = buffer;
+  EC_USINT index;
+  tmpptr = nw2host(tmpptr,index);
+  if (index == m_idx)
+    return true;
+  else{
+    ec_log(EC_LOG_ERROR, "EC_Telegram::check_index(): Index field does not correspond with received data\n");
+    return false;
+  }
+}
+
+/** Check if the next field in the buffer indicates the same as the
+    next field of the telegram, and if the length also corresponds */
+bool EC_Telegram::check_lennext(const unsigned char * buffer) const
+{
+  // Unsigned int to verify if the byte sequence indicates a "next" telegram?
+  EC_UINT lennext = 0x0000;
+  EC_UINT len = 0x0000; EC_UINT nextbit = 0x0000;
+  
+  const unsigned char * tmpptr = buffer;
+  static const EC_UINT NEXT_BIT = 0x8000;
+  static const EC_UINT LEN_BIT = 0x07ff;
+  // Convert to host order
+  tmpptr = nw2host(tmpptr,lennext);
+  
+  // Extract next information.  The Next bit is always the MSB of and
+  // unsigned int...
+  nextbit = lennext & NEXT_BIT;
+  if ( ((nextbit == NEXT_BIT) && (next == NULL)) ||
+       ((nextbit == 0x0000) && (next != NULL)) ){
+    ec_log(EC_LOG_ERROR, "EC_Telegram::check_lennext(): Next field does not correspond with received data\n");
+    return false;
+  }
+  else // Extract len information
+    {
+      len = lennext & LEN_BIT;
+      if (len != get_datalen()){
+	ec_log(EC_LOG_ERROR, "EC_Telegram::check_lennext(): Len field does not correspond with received data\n");
+	return false;
+      }
+      return true;
+    }
+}
+
+// irq field is currently unused
+const EC_UINT EC_Telegram::m_irq = 0x0000;
+
+
+/** Attach a single a_telegram after this telegram in chain
+ */
+void EC_Telegram::attach(EC_Telegram *a_telegram) 
+{  
+  assert(this != a_telegram);    
+  assert(a_telegram->next == NULL);
+  assert(a_telegram->previous == NULL);
+  a_telegram->next = this->next;
+  a_telegram->previous = this;
+  if (this->next != NULL) {
+    this->next->previous = a_telegram;
+  }
+  this->next = a_telegram;
+}
diff --git a/tests/CMakeLists.txt ./tests/CMakeLists.txt
new file mode 100644
index 0000000..30a0c6f
--- /dev/null
+++ ./tests/CMakeLists.txt
@@ -0,0 +1,15 @@
+# Make sure the linker can find the eml library once it is built.
+LINK_DIRECTORIES (${EML_BINARY_DIR}/src)
+
+IF (BUILD_FOR_ECOS)
+    SUBDIRS( ecos )
+ENDIF (BUILD_FOR_ECOS)
+
+IF (BUILD_FOR_RTNET)
+    SUBDIRS( rtnet )
+ENDIF (BUILD_FOR_RTNET)
+
+IF (BUILD_FOR_POSIX)
+    SUBDIRS( posix )
+ENDIF (BUILD_FOR_POSIX)
+
diff --git a/tests/ecos/CMakeLists.txt ./tests/ecos/CMakeLists.txt
new file mode 100644
index 0000000..20e2372
--- /dev/null
+++ ./tests/ecos/CMakeLists.txt
@@ -0,0 +1,47 @@
+# INCLUDE(ProjectSources.txt)
+
+SET(CMAKE_VERBOSE_MAKEFILE ON)
+#create the eCos executable
+ADD_DEFINITIONS(-D__ECOS__=1 -D__ECOS=1)
+SET(ECOS_DEFINITIONS -Wall -Wno-long-long -pipe -fno-builtin)
+
+SET (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wstrict-prototypes")
+SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Woverloaded-virtual -fno-rtti -Wctor-dtor-privacy -fno-strict-aliasing -fno-exceptions")
+
+#sources depend on target.ld
+FOREACH (_current_FILE ${ARGN})
+ADD_FILE_DEPENDENCIES(${_current_FILE} ${ECOS_INSTALL_PATH}/ecos/install/lib/target.ld)
+ENDFOREACH (_current_FILE)
+
+#use a variable for the make_clean_files since later on even more files are added
+SET(ECOS_ADD_MAKE_CLEAN_FILES ${ECOS_ADD_MAKE_CLEAN_FILES};${ECOS_INSTALL_PATH}/ecos/install/lib/target.ld)
+SET_DIRECTORY_PROPERTIES(
+    PROPERTIES
+    ADDITIONAL_MAKE_CLEAN_FILES "${ECOS_ADD_MAKE_CLEAN_FILES}" )
+
+ADD_CUSTOM_COMMAND(OUTPUT ${CMAKE_CURRENT_SOURCE_DIR}/${ECOS_INSTALL_PATH}/ecos/install/lib/target.ld
+    COMMAND sh
+    ARGS -c \"make -C ecos || exit -1\; if [ -e ${ECOS_INSTALL_PATH}/ecos/install/lib/target.ld ] \; then touch ${ECOS_INSTALL_PATH}/ecos/install/lib/target.ld\; fi\"
+    DEPENDS ${ECOS_INSTALL_PATH}/makefile
+)
+
+ADD_CUSTOM_COMMAND(OUTPUT ${ECOS_INSTALL_PATH}/makefile
+    COMMAND sh
+    ARGS -c \" cd ecos\; ${ECOSCONFIG_EXECUTABLE} tree || exit -1\;\"
+    DEPENDS ${ECOS_INSTALL_PATH}/ecos.ecc
+)
+
+ADD_CUSTOM_TARGET( ecos make -C ${ECOS_INSTALL_PATH}/ DEPENDS  ${ECOS_INSTALL_PATH}/makefile )
+
+SET (_ecos_EXTRA_LIBS "${_ecos_EXTRA_LIBS} -L${EML_BINARY_DIR}/src -leml")
+
+#special link commands for ecos-executables
+SET(CMAKE_CXX_LINK_EXECUTABLE  "<CMAKE_CXX_COMPILER> <CMAKE_CXX_LINK_FLAGS> <OBJECTS>  -o <TARGET> ${_ecos_EXTRA_LIBS} -nostdlib  -nostartfiles -L${ECOS_INSTALL_PATH}/ecos/install/lib -Ttarget.ld ${ECOS_LD_MCPU}")
+SET(CMAKE_C_LINK_EXECUTABLE  "<CMAKE_C_COMPILER> <CMAKE_C_LINK_FLAGS> <OBJECTS>  -o <TARGET> ${_ecos_EXTRA_LIBS} -nostdlib  -nostartfiles -L${ECOS_INSTALL_PATH}/ecos/install/lib -Ttarget.ld ${ECOS_LD_MCPU}")
+
+ADD_EXECUTABLE(ethercat_master_test.elf ethercat.cxx src/process_data.cxx)
+
+SET_TARGET_PROPERTIES(${_exe_NAME} PROPERTIES SUFFIX ".elf")
+
+# ECOS_ADD_EXECUTABLE(ethercat_master_test.elf ethercat.cxx)
+
diff --git a/tests/ecos/ChangeLog ./tests/ecos/ChangeLog
new file mode 100644
index 0000000..0c4a522
--- /dev/null
+++ ./tests/ecos/ChangeLog
@@ -0,0 +1,7 @@
+2005-04-25  Klaas Gadeyne  <first dot last at fmtc dot be>
+	* Obfuscate Bob's email address :-)
+	* Implemented framing and added test to run the lights demo
+	* CVS tag FMVB_0_4_0
+	
+2004-11-17  Bob Koninckx <bob dot koninckx at fmtc dot be>
+	* Create new module 
diff --git a/tests/ecos/ProjectSources.txt ./tests/ecos/ProjectSources.txt
new file mode 100644
index 0000000..ecb0f1b
--- /dev/null
+++ ./tests/ecos/ProjectSources.txt
@@ -0,0 +1,5 @@
+#the following name will be used as the name for the executable
+SET(ECOS_PROJECT_NAME ethercat-evaluationboard-test)
+
+#list the source files for the application
+SET(PROJECT_SRCS ethercat.cxx)
diff --git a/tests/ecos/ecos-i386/CMakeLists.txt ./tests/ecos/ecos-i386/CMakeLists.txt
new file mode 100644
index 0000000..9e23c4e
--- /dev/null
+++ ./tests/ecos/ecos-i386/CMakeLists.txt
@@ -0,0 +1,24 @@
+# give the project a name, so that the KDevelop project gets a nice name
+PROJECT(helloworld-i386)
+
+#include the file with the source list
+INCLUDE(../ProjectSources.txt)
+
+#compile for the i386 processor
+ECOS_USE_I386_ELF_TOOLS()
+
+#add some compile switches
+ADD_DEFINITIONS(-O2 -g)
+
+# verbose Makefiles, so that we see the complete compile commands
+SET(CMAKE_VERBOSE_MAKEFILE ON)
+
+# we are one directory level deeper here, so the
+# relative paths from the ProjectSources.txt have to be adjusted accordingly
+ECOS_ADJUST_DIRECTORY(target_SRCS ${PROJECT_SRCS})
+
+#add the eCos include directories
+ECOS_ADD_INCLUDE_DIRECTORIES()
+
+#create the eCos executable
+ECOS_ADD_EXECUTABLE(${ECOS_PROJECT_NAME} ${target_SRCS})
diff --git a/tests/ecos/ecos-i386/ecos/ecos.ecc ./tests/ecos/ecos-i386/ecos/ecos.ecc
new file mode 100644
index 0000000..597be2e
--- /dev/null
+++ ./tests/ecos/ecos-i386/ecos/ecos.ecc
@@ -0,0 +1,14831 @@
+# eCos saved configuration
+
+# ---- commands --------------------------------------------------------
+# This section contains information about the savefile format.
+# It should not be edited. Any modifications made to this section
+# may make it impossible for the configuration tools to read
+# the savefile.
+
+cdl_savefile_version 1;
+cdl_savefile_command cdl_savefile_version {};
+cdl_savefile_command cdl_savefile_command {};
+cdl_savefile_command cdl_configuration { description hardware template package };
+cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };
+
+# ---- toplevel --------------------------------------------------------
+# This section defines the toplevel configuration object. The only
+# values that can be changed are the name of the configuration and
+# the description field. It is not possible to modify the target,
+# the template or the set of packages simply by editing the lines
+# below because these changes have wide-ranging effects. Instead
+# the appropriate tools should be used to make such modifications.
+
+cdl_configuration eCos {
+    description "" ;
+
+    # These fields should not be modified.
+    hardware    pc_rltk8139 ;
+    template    net ;
+    package -hardware CYGPKG_HAL_I386 current ;
+    package -hardware CYGPKG_HAL_I386_GENERIC current ;
+    package -hardware CYGPKG_HAL_I386_PC current ;
+    package -hardware CYGPKG_HAL_I386_PCMB current ;
+    package -hardware CYGPKG_IO_PCI current ;
+    package -hardware CYGPKG_IO_SERIAL_GENERIC_16X5X current ;
+    package -hardware CYGPKG_IO_SERIAL_I386_PC current ;
+    package -hardware CYGPKG_DEVS_ETH_RLTK_8139 current ;
+    package -hardware CYGPKG_DEVS_ETH_I386_PC_RLTK8139 current ;
+    package -hardware CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 current ;
+    package -hardware CYGPKG_DEVICES_WALLCLOCK_I386_PC current ;
+    package CYGPKG_HAL current ;
+    package CYGPKG_IO current ;
+    package CYGPKG_IO_SERIAL current ;
+    package CYGPKG_INFRA current ;
+    package CYGPKG_ISOINFRA current ;
+    package CYGPKG_KERNEL current ;
+    package CYGPKG_MEMALLOC current ;
+    package CYGPKG_LIBC current ;
+    package CYGPKG_LIBC_TIME current ;
+    package CYGPKG_LIBC_STDLIB current ;
+    package CYGPKG_LIBC_STRING current ;
+    package CYGPKG_LIBC_I18N current ;
+    package CYGPKG_LIBC_SETJMP current ;
+    package CYGPKG_LIBC_STARTUP current ;
+    package CYGPKG_LIBC_STDIO current ;
+    package CYGPKG_LIBM current ;
+    package CYGPKG_POSIX current ;
+    package CYGPKG_IO_WATCHDOG current ;
+    package CYGPKG_IO_WALLCLOCK current ;
+    package -template CYGPKG_ERROR current ;
+    package -template CYGPKG_IO_FILEIO current ;
+    package -template CYGPKG_IO_ETH_DRIVERS current ;
+    package CYGPKG_NET_ETHERCATMASTER current ;
+};
+
+# ---- conflicts -------------------------------------------------------
+# There are no conflicts.
+
+# ---- contents --------------------------------------------------------
+# >
+# >
+# Global build options
+# Global build options including control over
+# compiler flags, linker flags and choice of toolchain.
+#
+cdl_component CYGBLD_GLOBAL_OPTIONS {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Global command prefix
+# This option specifies the command prefix used when
+# invoking the build tools. If your host operating system
+# is Linux you can set this to empty to use your native tools.
+# If so, your native gcc must be gcc-2.95.2 or later, and
+# "ld -v" must report a version more recent than 2.9.1.
+#
+cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value i386-elf
+    # value_source default
+    # Default value: i386-elf
+};
+
+# Global compiler flags
+# This option controls the global compiler flags which
+# are used to compile all packages by
+# default. Individual packages may define
+# options which override these global flags.
+#
+cdl_option CYGBLD_GLOBAL_CFLAGS {
+    # Flavor: data
+    user_value "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    # value_source user
+    # Default value: "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+
+    # The following properties are affected by this value
+    # option CYGBLD_INFRA_CFLAGS_WARNINGS_AS_ERRORS
+    #     Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -Werror") 
+    # option CYGBLD_INFRA_CFLAGS_PIPE
+    #     Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -pipe") 
+};
+
+# Global linker flags
+# This option controls the global linker flags. Individual
+# packages may define options which override these global flags.
+#
+cdl_option CYGBLD_GLOBAL_LDFLAGS {
+    # Flavor: data
+    user_value "-nostdlib -Wl,--gc-sections -Wl,-static"
+    # value_source user
+    # Default value: "-g -nostdlib -Wl,--gc-sections -Wl,-static"
+};
+
+# Build GDB stub loader image
+# This option enables the building of the GDB stubs for the
+# board. The common HAL controls takes care of most of the
+# build process, but the final conversion from ELF image to
+# binary data is handled by the platform CDL, allowing
+# relocation of the data if necessary.
+#
+cdl_option CYGBLD_BUILD_GDB_STUBS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 0
+    # Requires: CYGSEM_HAL_ROM_MONITOR
+    #     CYGSEM_HAL_ROM_MONITOR == 0
+    #   --> 0
+    # Requires: CYGBLD_BUILD_COMMON_GDB_STUBS
+    #     CYGBLD_BUILD_COMMON_GDB_STUBS == 0
+    #   --> 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    #     CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    #     CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM == 1
+    #   --> 0
+};
+
+# Build common GDB stub ROM image
+# Unless a target board has specific requirements to the
+# stub implementation, it can use a simple common stub.
+# This option, which gets enabled by platform HALs as
+# appropriate, controls the building of the common stub.
+#
+cdl_option CYGBLD_BUILD_COMMON_GDB_STUBS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGBLD_BUILD_COMMON_GDB_STUBS
+};
+
+# <
+# Redboot HAL options
+# This option lists the target's requirements for a valid Redboot
+# configuration.
+#
+cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 0
+
+    # There is no associated value.
+};
+
+# >
+# Build RedBoot binary image
+#
+cdl_component CYGBLD_BUILD_REDBOOT_BIN {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_HAL_OPTIONS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Build Redboot FLOPPY binary image
+# This option enables the conversion of the Redboot 
+# ELF image to a binary image suitable for
+# copying to a floppy disk.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_BIN_FLOPPY {
+    # This option is not active
+    # The parent CYGBLD_BUILD_REDBOOT_BIN is not active
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT
+    #     CYGBLD_BUILD_REDBOOT (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint:  CYG_HAL_STARTUP == "FLOPPY" 
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Build Redboot ROM binary image
+# This option enables the conversion of the Redboot
+# ELF image to a binary image suitable for ROM
+# programming.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_BIN_ROM {
+    # This option is not active
+    # The parent CYGBLD_BUILD_REDBOOT_BIN is not active
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT
+    #     CYGBLD_BUILD_REDBOOT (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint:  CYG_HAL_STARTUP == "ROM" 
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# <
+# <
+# <
+# eCos HAL
+# doc: ref/the-ecos-hardware-abstraction-layer.html
+# The eCos HAL package provide a porting layer for
+# higher-level parts of the system such as the kernel and the
+# C library. Each installation should have HAL packages for
+# one or more architectures, and for each architecture there
+# may be one or more supported platforms. It is necessary to
+# select one target architecture and one platform for that
+# architecture. There are also a number of configuration
+# options that are common to all HAL packages.
+#
+cdl_package CYGPKG_HAL {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_INFRA
+    #     CYGPKG_INFRA == current
+    #   --> 1
+
+    # The following properties are affected by this value
+};
+
+# >
+# Platform-independent HAL options
+# A number of configuration options are common to most or all
+# HAL packages, for example options controlling how much state
+# should be saved during a context switch. The implementations
+# of these options will vary from architecture to architecture.
+#
+cdl_component CYGPKG_HAL_COMMON {
+    # There is no associated value.
+};
+
+# >
+# Provide eCos kernel support
+# The HAL can be configured to either support the full eCos
+# kernel, or to support only very simple applications which do
+# not require a full kernel. If kernel support is not required
+# then some of the startup, exception, and interrupt handling
+# code can be eliminated.
+#
+cdl_option CYGFUN_HAL_COMMON_KERNEL_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+};
+
+# HAL exception support
+# When a processor exception occurs, for example an attempt to
+# execute an illegal instruction or to perform a divide by
+# zero, this exception may be handled in a number of different
+# ways. If the target system has gdb support then typically
+# the exception will be handled by gdb code. Otherwise if the
+# HAL exception support is enabled then the HAL will invoke a
+# routine deliver_exception(). Typically this routine will be
+# provided by the eCos kernel, but it is possible for
+# application code to provide its own implementation. If the
+# HAL exception support is not enabled and a processor
+# exception occurs then the behaviour of the system is
+# undefined.
+#
+cdl_option CYGPKG_HAL_EXCEPTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGPKG_KERNEL_EXCEPTIONS
+    #     CYGPKG_KERNEL_EXCEPTIONS == 1
+    #   --> 1
+    # Requires: CYGPKG_KERNEL_EXCEPTIONS
+    #     CYGPKG_KERNEL_EXCEPTIONS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_KERNEL_EXCEPTIONS
+    #     Requires: CYGPKG_HAL_EXCEPTIONS
+};
+
+# Stop calling constructors early
+# This option supports environments where some constructors
+# must be run in the context of a thread rather than at
+# simple system startup time. A boolean flag named
+# cyg_hal_stop_constructors is set to 1 when constructors
+# should no longer be invoked. It is up to some other
+# package to deal with the rest of the constructors.
+# In the current version this is only possible with the
+# C library.
+#
+cdl_option CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     Requires: CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG
+};
+
+# HAL uses the MMU and allows for CDL manipulation of it's use
+#
+cdl_interface CYGINT_HAL_SUPPORTS_MMU_TABLES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     ActiveIf: CYGINT_HAL_SUPPORTS_MMU_TABLES
+};
+
+# Install MMU tables.
+# This option controls whether this application installs
+# its own Memory Management Unit (MMU) tables, or relies on the
+# existing environment to run.
+#
+cdl_option CYGSEM_HAL_INSTALL_MMU_TABLES {
+    # This option is not active
+    # ActiveIf constraint: CYGINT_HAL_SUPPORTS_MMU_TABLES
+    #     CYGINT_HAL_SUPPORTS_MMU_TABLES == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYG_HAL_STARTUP != "RAM" 
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_STATIC_MMU_TABLES
+    #     Requires: CYGSEM_HAL_INSTALL_MMU_TABLES
+};
+
+# Use static MMU tables.
+# This option defines an environment where any Memory
+# Management Unit (MMU) tables are constant.  Normally used by ROM
+# based environments, this provides a way to save RAM usage which
+# would otherwise be required for these tables.
+#
+cdl_option CYGSEM_HAL_STATIC_MMU_TABLES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     CYGSEM_HAL_INSTALL_MMU_TABLES == 0
+    #   --> 0
+};
+
+# Route diagnostic output to debug channel
+# If not inheriting the console setup from the ROM monitor,
+# it is possible to redirect diagnostic output to the debug
+# channel by enabling this option. Depending on the debugger
+# used it may also be necessary to select a mangler for the
+# output to be displayed by the debugger.
+#
+cdl_component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN {
+    # ActiveIf constraint: !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE == 0
+    #   --> 1
+    # ActiveIf constraint:  CYGPKG_HAL_ARM || CYGPKG_HAL_POWERPC_MPC8xx  || CYGPKG_HAL_V85X_V850 || CYGSEM_HAL_VIRTUAL_VECTOR_DIAG 
+    #     CYGPKG_HAL_ARM (unknown) == 0
+    #     CYGPKG_HAL_POWERPC_MPC8xx (unknown) == 0
+    #     CYGPKG_HAL_V85X_V850 (unknown) == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_DIAG == 1
+    #   --> 1
+
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+    #     Calculated:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+};
+
+# >
+# Mangler used on diag output
+# It is sometimes necessary to mangle (encode) the
+# diag ASCII text output in order for it to show up at the
+# other end. In particular, GDB may silently ignore raw
+# ASCII text.
+#
+cdl_option CYGSEM_HAL_DIAG_MANGLER {
+    # This option is not active
+    # The parent CYGDBG_HAL_DIAG_TO_DEBUG_CHAN is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value GDB
+    # value_source default
+    # Default value: GDB
+    # Legal values: "GDB" "None"
+};
+
+# <
+# <
+# HAL interrupt handling
+# A number of configuration options related to interrupt
+# handling are common to most or all HAL packages, even though
+# the implementations will vary from architecture to
+# architecture.
+#
+cdl_component CYGPKG_HAL_COMMON_INTERRUPTS {
+    # There is no associated value.
+};
+
+# >
+# Use separate stack for interrupts
+# When an interrupt occurs this interrupt can be handled either
+# on the current stack or on a separate stack maintained by the
+# HAL. Using a separate stack requires a small number of extra
+# instructions in the interrupt handling code, but it has the
+# advantage that it is no longer necessary to allow extra space
+# in every thread stack for the interrupt handlers. The amount
+# of extra space required depends on the interrupt handlers
+# that are being used.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Interrupt stack size
+# This configuration option specifies the stack size in bytes
+# for the interrupt stack. Typically this should be a multiple
+# of 16, but the exact requirements will vary from architecture
+# to architecture. The interrupt stack serves two separate
+# purposes. It is used as the stack during system
+# initialization. In addition, if the interrupt system is
+# configured to use a separate stack then all interrupts will
+# be processed on this stack. The exact memory requirements
+# will vary from application to application, and will depend
+# heavily on whether or not other interrupt-related options,
+# for example nested interrupts, are enabled. On most targets,
+# in a configuration with no kernel this stack will also be
+# the stack used to invoke the application, and must obviously
+# be appropriately large in that case.
+#
+cdl_option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4096
+    # value_source default
+    # Default value:  CYGPKG_KERNEL ? 4096 : 32768 
+    #     CYGPKG_KERNEL == current
+    #   --> 4096
+    # Legal values: 128 to 1048576
+};
+
+# Allow nested interrupts
+# When an interrupt occurs the HAL interrupt handling code can
+# either leave interrupts disabled for the duration of the
+# interrupt handling code, or by doing some extra work it can
+# reenable interrupts before invoking the interrupt handler and
+# thus allow nested interrupts to happen. If all the interrupt
+# handlers being used are small and do not involve any loops
+# then it is usually better to disallow nested interrupts.
+# However if any of the interrupt handlers are more complicated
+# than nested interrupts will usually be required.
+#
+cdl_option CYGSEM_HAL_COMMON_INTERRUPTS_ALLOW_NESTING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Save minimum context on interrupt
+# The HAL interrupt handling code can exploit the calling conventions
+# defined for a given architecture to reduce the amount of state
+# that has to be saved. Generally this improves performance and
+# reduces code size. However it can make source-level debugging
+# more difficult.
+#
+cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+};
+
+# Chain all interrupts together
+# Interrupts can be attached to vectors either singly, or be
+# chained together. The latter is necessary if there is no way
+# of discovering which device has interrupted without
+# inspecting the device itself. It can also reduce the amount
+# of RAM needed for interrupt decoding tables and code.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGIMP_KERNEL_INTERRUPTS_CHAIN
+    #     Requires: CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN
+};
+
+# Ignore spurious [fleeting] interrupts
+# On some hardware, interrupt sources may not be de-bounced or
+# de-glitched.  Rather than try to handle these interrupts (no
+# handling may be possible), this option allows the HAL to simply
+# ignore them.  In most cases, if the interrupt is real it will
+# reoccur in a detectable form.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# HAL context switch support
+# A number of configuration options related to thread contexts
+# are common to most or all HAL packages, even though the
+# implementations will vary from architecture to architecture.
+#
+cdl_component CYGPKG_HAL_COMMON_CONTEXT {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Use minimum thread context
+# The thread context switch code can exploit the calling
+# conventions defined for a given architecture to reduce the
+# amount of state that has to be saved during a context
+# switch. Generally this improves performance and reduces
+# code size. However it can make source-level debugging more
+# difficult.
+#
+cdl_option CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+};
+
+# <
+# Explicit control over cache behaviour
+# These options let the default behaviour of the caches 
+# be easily configurable.
+#
+cdl_component CYGPKG_HAL_CACHE_CONTROL {
+    # There is no associated value.
+};
+
+# >
+# Enable DATA cache on startup
+# Enabling this option will cause the data cache to be enabled
+# as soon as practicable when eCos starts up.  One would choose
+# to disable this if the data cache cannot safely be turned on,
+# such as a case where the cache(s) require additional platform
+# specific setup.
+#
+cdl_component CYGSEM_HAL_ENABLE_DCACHE_ON_STARTUP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# DATA cache mode on startup
+# This option controls the mode the cache will be set to
+# when enabled on startup.
+#
+cdl_option CYGSEM_HAL_DCACHE_STARTUP_MODE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value COPYBACK
+    # value_source default
+    # Default value: COPYBACK
+    # Legal values:  "COPYBACK" "WRITETHRU" 
+};
+
+# <
+# Enable INSTRUCTION cache on startup
+# Enabling this option will cause the instruction cache to be enabled
+# as soon as practicable when eCos starts up.  One would choose
+# to disable this if the instruction cache cannot safely be turned on,
+# such as a case where the cache(s) require additional platform
+# specific setup.
+#
+cdl_option CYGSEM_HAL_ENABLE_ICACHE_ON_STARTUP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Source-level debugging support
+# If the source level debugger gdb is to be used for debugging
+# application code then it may be necessary to configure in support
+# for this in the HAL.
+#
+cdl_component CYGPKG_HAL_DEBUG {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Support for GDB stubs
+# The HAL implements GDB stubs for the target.
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_STUBS {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     ActiveIf: CYGINT_HAL_DEBUG_GDB_STUBS
+};
+
+# Include GDB stubs in HAL
+# This option causes a set of GDB stubs to be included into the
+# system. On some target systems the GDB support will be
+# provided by other means, for example by a ROM monitor. On
+# other targets, especially when building a ROM-booting system,
+# the necessary support has to go into the target library
+# itself. When GDB stubs are include in a configuration, HAL
+# serial drivers must also be included.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
+    # ActiveIf constraint: CYGINT_HAL_DEBUG_GDB_STUBS
+    #     CYGINT_HAL_DEBUG_GDB_STUBS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: ! CYGSEM_HAL_USE_ROM_MONITOR
+    #     CYGSEM_HAL_USE_ROM_MONITOR == GDB_stubs
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    #     CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    #     CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM == 1
+    #   --> 0
+    # Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_DIAG == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     DefaultValue:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     DefaultValue: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     DefaultValue:  !CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGBLD_BUILD_COMMON_GDB_STUBS
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGPKG_HAL_GDB_FILEIO
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK
+    #     ActiveIf: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+};
+
+# Support for external break support in GDB stubs
+# The HAL implements external break (or asynchronous interrupt)
+# in the GDB stubs for the target.
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_STUBS_BREAK {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     ActiveIf: CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+};
+
+# Include GDB external break support for stubs
+# This option causes the GDB stub to add a serial interrupt handler
+# which will listen for GDB break packets. This lets you stop the
+# target asynchronously when using GDB, usually by hitting Control+C
+# or pressing the STOP button. This option differs from
+# CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT in that it is used when
+# GDB stubs are present.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT {
+    # ActiveIf constraint: CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    #     CYGINT_HAL_DEBUG_GDB_STUBS_BREAK == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     Requires: !CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+};
+
+# Platform does not support CTRLC
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0 
+};
+
+# Include GDB external break support when no stubs
+# This option adds an interrupt handler for the GDB serial line
+# which will listen for GDB break packets. This lets you stop the
+# target asynchronously when using GDB, usually by hitting Control+C
+# or pressing the STOP button. This option differs from
+# CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT in that it is used when the GDB
+# stubs are NOT present.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT {
+    # ActiveIf constraint:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGSEM_HAL_USE_ROM_MONITOR == GDB_stubs
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 1
+    # ActiveIf constraint:  CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0 
+    #     CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  !CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 1
+    # Requires: !CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+};
+
+# Include GDB multi-threading debug support
+# This option enables some extra HAL code which is needed
+# to support multi-threaded source level debugging.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT {
+    # ActiveIf constraint:  CYGSEM_HAL_ROM_MONITOR || CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT 
+    #     CYGSEM_HAL_ROM_MONITOR == 0
+    #     CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    # option CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+};
+
+# Number of times to retry sending a $O packet
+# This option controls the number of attempts that eCos programs
+# will make to send a $O packet to a host GDB process.  If it is
+# set non-zero, then the target process will attempt to resend the
+# $O packet data up to this number of retries.  Caution: use of
+# this option is not recommended as it can thoroughly confuse the
+# host GDB process.
+#
+cdl_option CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Timeout period for GDB packets
+# This option controls the time (in milliseconds) that eCos programs
+# will wait for a response when sending packets to a host GDB process.
+# If this time elapses, then the packet will be resent, up to some
+# maximum number of times (CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES).
+#
+cdl_option CYGNUM_HAL_DEBUG_GDB_PROTOCOL_TIMEOUT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 500
+    # value_source default
+    # Default value: 500
+};
+
+# Location of CRC32 table
+# The stubs use a 1 kilobyte CRC table that can either be pregenerated
+# and placed in ROM, or generated at runtime in RAM. Depending on
+# your memory constraints, one of these options may be better.
+#
+cdl_option CYGDBG_HAL_CRCTABLE_LOCATION {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value RAM
+    # value_source default
+    # Default value: RAM
+    # Legal values: "ROM" "RAM"
+};
+
+# Enable initial breakpoint
+# This option causes an application that has GDB stubs built in
+# to take a breakpoint immediately before calling cyg_start().
+# This gives the developer a chance to set any breakpoints or
+# inspect the system state before it proceeds.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK {
+    # This option is not active
+    # ActiveIf constraint: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  !CYGPKG_REDBOOT 
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 1
+};
+
+# <
+# ROM monitor support
+# Support for ROM monitors can be built in to your application. 
+# It may also be relevant to build your application as a ROM monitor
+# itself. Such options are contained here if relevant for your chosen
+# platform. The options and ROM monitors available to choose are
+# platform-dependent.
+#
+cdl_component CYGPKG_HAL_ROM_MONITOR {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Target has virtual vector support
+#
+cdl_interface CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # component CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+    #     ActiveIf: CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+};
+
+# Target supports baud rate control via vectors
+# Whether this target supports the __COMMCTL_GETBAUD
+# and __COMMCTL_SETBAUD virtual vector comm control operations.
+#
+cdl_interface CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Enable use of virtual vector calling interface
+# Virtual vector support allows the HAL to let the ROM
+# monitor handle certain operations. The virtual vector table
+# defines a calling interface between applications running in
+# RAM and the ROM monitor.
+#
+cdl_component CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT {
+    # ActiveIf constraint: CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+    #     CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Inherit console settings from ROM monitor
+# When this option is set, the application will inherit
+# the console as set up by the ROM monitor. This means
+# that the application will use whatever channel and
+# mangling style was used by the ROM monitor when
+# the application was launched.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE {
+    # ActiveIf constraint: CYGSEM_HAL_USE_ROM_MONITOR
+    #     CYGSEM_HAL_USE_ROM_MONITOR == GDB_stubs
+    #   --> 1
+
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value:  !CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     ActiveIf: !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+    #     Calculated:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+};
+
+# Debug channel is configurable
+# This option is a configuration hint - it is enabled
+# when the HAL initialization code will make use
+# of the debug channel configuration option.
+#
+cdl_option CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE {
+    # Calculated value:  CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 0
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Console channel is configurable
+# This option is a configuration hint - it is enabled
+# when the HAL initialization code will make use
+# of the console channel configuration option.
+#
+cdl_option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE {
+    # Calculated value:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE == 0
+    #     CYGDBG_HAL_DIAG_TO_DEBUG_CHAN == 0
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Initialize whole of virtual vector table
+# This option will cause the whole of the virtual
+# vector table to be initialized with dummy values on
+# startup. When this option is enabled, all the
+# options below must also be enabled - or the
+# table would be empty when the application
+# launches.
+# On targets where older ROM monitors without
+# virtual vector support may still be in use, it is
+# necessary for RAM applictions to initialize the
+# table (since all HAL diagnostics and debug IO
+# happens via the table).
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGSEM_HAL_USE_ROM_MONITOR == GDB_stubs
+    #   --> 0
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA == 0
+    #   --> 0
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT
+    #     ActiveIf: !CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_VERSION
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+};
+
+# Claim virtual vector table entries by default
+# By default most virtual vectors will be claimed by
+# RAM startup configurations, meaning that the RAM
+# application will provide the services. The
+# exception is COMMS support (HAL
+# diagnostics/debugging IO) which is left in the
+# control of the ROM monitor.
+# The reasoning behind this is to get as much of the
+# code exercised during regular development so it
+# is known to be working the few times a new ROM
+# monitor or a ROM production configuration is used
+# - COMMS are excluded only by necessity in order to
+# avoid breaking an existing debugger connections
+# (there may be ways around this).
+# For production RAM configurations this option can
+# be switched off, causing the appliction to rely on
+# the ROM monitor for these services, thus
+# saving some space.
+# Individual vectors may also be left unclaimed,
+# controlled by the below options (meaning that the
+# associated service provided by the ROM monitor
+# will be used).
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT {
+    # ActiveIf constraint: !CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+};
+
+# Claim reset virtual vectors
+# This option will cause the reset and kill_by_reset
+# virtual vectors to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+};
+
+# Claim version virtual vectors
+# This option will cause the version
+# virtual vectors to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_VERSION {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #   --> 0
+};
+
+# Claim delay_us virtual vector
+# This option will cause the delay_us
+# virtual vector to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+};
+
+# Claim cache virtual vectors
+# This option will cause the cache virtual vectors
+# to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+};
+
+# Claim data virtual vectors
+# This option will cause the data virtual vectors
+# to be claimed. At present there is only one, used
+# by the RedBoot ethernet driver to share diag output.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+};
+
+# Claim comms virtual vectors
+# This option will cause the communication tables
+# that are part of the virtual vectors mechanism to
+# be claimed. Note that doing this may cause an
+# existing ROM monitor communication connection to
+# be closed. For this reason, the option is disabled
+# per default for normal application
+# configurations.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 0
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     DefaultValue:  !CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+    #     Calculated:  CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+};
+
+# Do diagnostic IO via virtual vector table
+# All HAL IO happens via the virtual vector table / comm
+# tables when those tables are supported by the HAL.
+# If so desired, the low-level IO functions can
+# still be provided by the RAM application by
+# enabling the CLAIM_COMMS option.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_DIAG {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     ActiveIf:  CYGPKG_HAL_ARM || CYGPKG_HAL_POWERPC_MPC8xx  || CYGPKG_HAL_V85X_V850 || CYGSEM_HAL_VIRTUAL_VECTOR_DIAG 
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+};
+
+# <
+# Behave as a ROM monitor
+# Enable this option if this program is to be used as a ROM monitor,
+# i.e. applications will be loaded into RAM on the board, and this
+# ROM monitor may process exceptions or interrupts generated from the
+# application. This enables features such as utilizing a separate
+# interrupt stack when exceptions are generated.
+#
+cdl_option CYGSEM_HAL_ROM_MONITOR {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 0
+    # Requires:  !CYGHWR_HAL_I386_FPU_SWITCH_LAZY 
+    #     CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 1
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGSEM_HAL_ROM_MONITOR
+    # option CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_ROM_MONITOR || CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT 
+};
+
+# Work with a ROM monitor
+# Support can be enabled for different varieties of ROM monitor.
+# This support changes various eCos semantics such as the encoding
+# of diagnostic output, or the overriding of hardware interrupt
+# vectors.
+# Firstly there is "Generic" support which prevents the HAL
+# from overriding the hardware vectors that it does not use, to
+# instead allow an installed ROM monitor to handle them. This is
+# the most basic support which is likely to be common to most
+# implementations of ROM monitor.
+# "GDB_stubs" provides support when GDB stubs are included in
+# the ROM monitor or boot ROM.
+#
+cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 GDB_stubs
+    # value_source default
+    # Default value:  CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 1 GDB_stubs
+    # Legal values:  "Generic" "GDB_stubs" 
+    # Requires:  CYG_HAL_STARTUP == "RAM" 
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGSEM_HAL_USE_ROM_MONITOR
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     ActiveIf: CYGSEM_HAL_USE_ROM_MONITOR
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+};
+
+# <
+# Platform defined I/O channels.
+# Platforms which provide additional I/O channels can implement
+# this interface, indicating that the function plf_if_init()
+# needs to be called.
+#
+cdl_interface CYGINT_HAL_PLF_IF_INIT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Platform IDE I/O support.
+# Platforms which provide IDE controllers can implement
+# this interface, indicating that IDE I/O macros are
+# available.
+#
+cdl_interface CYGINT_HAL_PLF_IF_IDE {
+    # Implemented by CYGPKG_HAL_I386_PCMB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# File I/O operations via GDB
+# This option enables support for various file I/O
+# operations using the GDB remote protocol to communicate
+# with GDB. The operations are then performed on the
+# debugging host by proxy. These operations are only
+# currently available by using a system call interface
+# to RedBoot. This may change in the future.
+#
+cdl_option CYGPKG_HAL_GDB_FILEIO {
+    # This option is not active
+    # ActiveIf constraint: CYGSEM_REDBOOT_BSP_SYSCALLS
+    #     CYGSEM_REDBOOT_BSP_SYSCALLS (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 0
+    #   --> 0
+};
+
+# Build Compiler sanity checking tests
+# Enabling this option causes compiler tests to be built.
+#
+cdl_option CYGPKG_HAL_BUILD_COMPILER_TESTS {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_TESTS
+    #     Calculated:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+};
+
+# Common HAL tests
+# This option specifies the set of tests for the common HAL.
+#
+cdl_component CYGPKG_HAL_TESTS {
+    # Calculated value:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+    #     CYGINT_HAL_TESTS_NO_CACHES == 0
+    #     CYGPKG_HAL_BUILD_COMPILER_TESTS == 0
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    # Flavor: data
+    # Current_value: tests/context tests/basic tests/cache
+};
+
+# >
+# Interface for cache presence
+# Some architectures and/or platforms do not have caches. By
+# implementing this interface, these can disable the various
+# cache-related tests.
+#
+cdl_interface CYGINT_HAL_TESTS_NO_CACHES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_TESTS
+    #     Calculated:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+};
+
+# <
+# i386 architecture
+# The i386 architecture HAL package provides generic
+# support for this processor architecture. It is also
+# necessary to select a specific target platform HAL
+# package.
+#
+cdl_package CYGPKG_HAL_I386 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # option CYGPKG_LIBM_CFLAGS_ADD
+    #     DefaultValue:  ((0 == CYGPKG_HAL_I386) && (0 == CYGPKG_HAL_SYNTH_I386)) ? "" : "-ffloat-store" 
+};
+
+# >
+# SMP support
+#
+cdl_component CYGPKG_HAL_SMP_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0 
+    #     CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 1
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT
+    #     ActiveIf:  CYGPKG_HAL_SMP_SUPPORT 
+    # component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT
+    #     Calculated:  CYGPKG_HAL_SMP_SUPPORT 
+    # component CYGPKG_KERNEL_SMP_SUPPORT
+    #     Requires: CYGPKG_HAL_SMP_SUPPORT
+};
+
+# >
+# Max number of CPUs supported
+#
+cdl_option CYGPKG_HAL_SMP_CPU_MAX {
+    # This option is not active
+    # The parent CYGPKG_HAL_SMP_SUPPORT is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2
+    # value_source default
+    # Default value: 2
+};
+
+# <
+# Enable I386 FPU support
+# This component enables support for the
+# I386 floating point unit.
+#
+cdl_component CYGHWR_HAL_I386_FPU {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Use lazy FPU state switching
+# This option enables lazy FPU state switching.
+# The default behaviour for eCos is to save and
+# restore FPU state on every thread switch, interrupt
+# and exception. While simple and deterministic, this
+# approach can be expensive if the FPU is not used by
+# all threads. The alternative, enabled by this option,
+# is to use hardware features that allow the FPU state
+# of a thread to be left in the FPU after it has been
+# descheduled, and to allow the state to be switched to
+# a new thread only if it actually uses the FPU. Where
+# only one or two threads use the FPU this can avoid a
+# lot of unnecessary state switching.
+#
+cdl_option CYGHWR_HAL_I386_FPU_SWITCH_LAZY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_SMP_SUPPORT
+    #     Requires:  CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  !CYGHWR_HAL_I386_FPU_SWITCH_LAZY 
+};
+
+# <
+# Enable Pentium class CPU features
+# This component enables support for various
+# features of Pentium class CPUs.
+#
+cdl_component CYGHWR_HAL_I386_PENTIUM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Save/Restore SSE registers on context switch
+# This option enables SSE state switching. The default
+# behaviour for eCos is to ignore the SSE registers.
+# Enabling this option adds SSE state information to
+# every thread context.
+#
+cdl_option CYGHWR_HAL_I386_PENTIUM_SSE {
+    # This option is not active
+    # The parent CYGHWR_HAL_I386_PENTIUM is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Support extra Pentium registers in GDB stub
+# This option enables support for extra Pentium registers
+# in the GDB stub. These are registers such as CR0-CR4, and
+# all MSRs. Not all GDBs support these registers, so the
+# default behaviour for eCos is to not include them in the
+# GDB stub support code.
+#
+cdl_option CYGHWR_HAL_I386_PENTIUM_GDB_REGS {
+    # This option is not active
+    # The parent CYGHWR_HAL_I386_PENTIUM is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Linker script
+#
+cdl_option CYGBLD_LINKER_SCRIPT {
+    # Calculated value:  "src/i386.ld" 
+    # Flavor: data
+    # Current_value: src/i386.ld
+};
+
+# Implementations of hal_i386_mem_real_region_top()
+#
+cdl_interface CYGINT_HAL_I386_MEM_REAL_REGION_TOP {
+    # Implemented by CYGPKG_HAL_I386_PCMB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# Provide the exec command in RedBoot
+# This option contains requirements for booting linux
+# from RedBoot. The component is enabled/disabled from
+# RedBoots CDL.
+#
+cdl_component CYGPKG_REDBOOT_I386_LINUX_EXEC {
+    # This option is not active
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT_WITH_EXEC
+    #     CYGBLD_BUILD_REDBOOT_WITH_EXEC (unknown) == 0
+    #   --> 0
+
+    # There is no associated value.
+};
+
+# >
+# Address for the trampoline code
+# This is the address to where the trampoline code is
+# copied.  The trampoline copies the image to its
+# final location and jumps to its entry point.
+#
+cdl_option CYGHWR_REDBOOT_I386_TRAMPOLINE_ADDRESS {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_I386_LINUX_EXEC is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x0007C000
+    # value_source default
+    # Default value: 0x0007C000
+};
+
+# <
+# i386 generic target
+# This package provides support for generic IA32 CPU variants.
+# Any CPU from an 80386 to the latest Pentium/Athlon should work
+# with this variant HAL. Essentially this variant is empty, it
+# just avoids providing any configuration to the generic architecture
+# support in the architecture HAL.
+#
+cdl_package CYGPKG_HAL_I386_GENERIC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# i386 PC Target
+# The i386 PC Target HAL package provides the 
+# support needed to run eCos binaries on an i386 PC.
+#
+cdl_package CYGPKG_HAL_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_I386_PC_RLTK8139
+    #     ActiveIf: CYGPKG_HAL_I386_PC
+    # package CYGPKG_DEVICES_WALLCLOCK_I386_PC
+    #     ActiveIf: CYGPKG_HAL_I386_PC
+};
+
+# >
+# How to discover the size of available RAM.
+# It is possible for the HAL to discover the 
+# size of RAM In several ways. Currently this
+# can be done by querying the BIOS or by 
+# hardcoding the values into the executable.
+#
+cdl_component CYGPKG_HAL_I386_PC_MEMSIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value BIOS
+    # value_source default
+    # Default value: BIOS
+    # Legal values: "BIOS" "HARDCODE"
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_I386_PC_MEMSIZE_BASE
+    #     ActiveIf:  CYGPKG_HAL_I386_PC_MEMSIZE == "HARDCODE" 
+    # option CYGNUM_HAL_I386_PC_MEMSIZE_EXTENDED
+    #     ActiveIf:  CYGPKG_HAL_I386_PC_MEMSIZE == "HARDCODE" 
+};
+
+# >
+# Amount of Base RAM available.
+#
+cdl_option CYGNUM_HAL_I386_PC_MEMSIZE_BASE {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_I386_PC_MEMSIZE == "HARDCODE" 
+    #     CYGPKG_HAL_I386_PC_MEMSIZE == BIOS
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000F0000
+    # value_source default
+    # Default value: 0x000F0000
+};
+
+# Amount of Extended RAM available.
+#
+cdl_option CYGNUM_HAL_I386_PC_MEMSIZE_EXTENDED {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_I386_PC_MEMSIZE == "HARDCODE" 
+    #     CYGPKG_HAL_I386_PC_MEMSIZE == BIOS
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00100000
+    # value_source default
+    # Default value: 0x00100000
+};
+
+# <
+# Startup type
+# It is possible to configure eCos for the PC target to build for:
+# RAM startup (generally when being run under an existing
+# Monitor program like RedBoot); FLOPPY startup (for writing
+# to a floppy disk, which can then be used for booting
+# on PCs with a standard BIOS), GRUB startup (for being booted
+# by the GRUB bootloader) ROM startup (for writing
+# straight to a boot ROM/Flash). ROM startup is experimental
+# at this time.
+#
+cdl_component CYG_HAL_STARTUP {
+    # Flavor: data
+    user_value RAM
+    # value_source user
+    # Default value: RAM
+    # Legal values: "RAM" "FLOPPY" "ROM" "GRUB"
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_I386_ROMBOOT
+    #     Calculated:  CYG_HAL_STARTUP == "ROM" 
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGHWR_HAL_I386_PC_LOAD_HIGH
+    #     Requires:  CYG_HAL_STARTUP == "RAM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGHWR_HAL_I386_PC_LOAD_HIGH
+    #     Requires:  CYG_HAL_STARTUP == "RAM" || CYG_HAL_STARTUP == "GRUB" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_USE_ROM_MONITOR
+    #     DefaultValue:  CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 
+    # option CYGSEM_HAL_USE_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "RAM" 
+    # option CYGBLD_BUILD_REDBOOT_BIN_FLOPPY
+    #     ActiveIf:  CYG_HAL_STARTUP == "FLOPPY" 
+    # option CYGBLD_BUILD_REDBOOT_BIN_ROM
+    #     ActiveIf:  CYG_HAL_STARTUP == "ROM" 
+    # option CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" 
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     DefaultValue:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+};
+
+# Build ROM bootstrap code
+#
+cdl_option CYGBLD_BUILD_I386_ROMBOOT {
+    # Calculated value:  CYG_HAL_STARTUP == "ROM" 
+    #     CYG_HAL_STARTUP == RAM
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Diagnostic serial port baud rate
+# This option selects the baud rate used for the diagnostic port.
+# Note: this should match the value chosen for the GDB port if the
+# diagnostic and GDB port are the same.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values: 9600 19200 38400 57600 115200
+};
+
+# GDB serial port baud rate
+# This option controls the baud rate used for the GDB connection.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values: 9600 19200 38400 57600 115200
+};
+
+# Number of communication channels on the board
+# This define the number of serial ports that will be used by the HAL.
+# Ports 0 and 1 equate to COM1 and COM2 and port 2 is the PC screen and
+# keyboard.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value:  CYGSEM_HAL_I386_PC_DIAG_SCREEN ? 3 : 2 
+    #     CYGSEM_HAL_I386_PC_DIAG_SCREEN == 1
+    #   --> 3
+    # Legal values: 1 to 3
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+};
+
+# Debug serial port
+# On PCs with two serial ports, this option
+# chooses which port will be used to connect to a host
+# running GDB.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+};
+
+# Default console channel.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT {
+    # Flavor: data
+    user_value 2
+    # value_source user
+    # Default value: 0
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL
+    #     DefaultValue: CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+};
+
+# Diagnostic serial port
+# On PCs with two serial ports, this option
+# chooses which port will be used for diagnostic output.
+# Selecting port 2 will cause the PC screen to be used.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2
+    # value_source default
+    # Default value: CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT == 2
+    #   --> 2
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+};
+
+# Output to PC screen
+# This option enables use of the PC screen and keyboard as a
+# third virtual serial device.
+#
+cdl_option CYGSEM_HAL_I386_PC_DIAG_SCREEN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS
+    #     DefaultValue:  CYGSEM_HAL_I386_PC_DIAG_SCREEN ? 3 : 2 
+    # option CYGNUM_HAL_I386_PC_STARTUP_VIDEO_MODE
+    #     Requires:  !CYGSEM_HAL_I386_PC_DIAG_SCREEN 
+};
+
+# Load into higher memory (2MB)
+# This option enables building RAM applications
+# which have a start address outside of the area
+# used by redboot_GRUB.
+#
+cdl_option CYGHWR_HAL_I386_PC_LOAD_HIGH {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "RAM" || CYG_HAL_STARTUP == "GRUB" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+};
+
+# Memory layout
+#
+cdl_component CYGHWR_MEMORY_LAYOUT {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_grub_hi" :  "i386_pc_grub") :  "i386_pc_floppy" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    # Flavor: data
+    # Current_value: i386_pc_ram_hi
+};
+
+# >
+# Memory layout linker script fragment
+#
+cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.ldi>" :  "<pkgconf/mlt_i386_pc_grub.ldi>") :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    # Flavor: data
+    # Current_value: <pkgconf/mlt_i386_pc_ram_hi.ldi>
+};
+
+# Memory layout header file
+#
+cdl_option CYGHWR_MEMORY_LAYOUT_H {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_grub_hi.h>" :  "<pkgconf/mlt_i386_pc_grub.h>") :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    #     CYG_HAL_STARTUP == RAM
+    #     CYG_HAL_STARTUP == RAM
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 1
+    # Flavor: data
+    # Current_value: <pkgconf/mlt_i386_pc_ram_hi.h>
+};
+
+# <
+# <
+# i386 PC Motherboard Support
+# The i386 PC Motherboard HAL package provides the
+# support needed to run eCos binaries on an i386 PC
+# using a standard motherboard. This package provides
+# support for the standard PC devices: timers, interrupt
+# controller, serial ports, ASCII display, keyboard, PCI
+# bus etc. that are found on all PC compatible platforms.
+# It does not provide support for devices that may also be
+# found on modern motherboards, such as ethernet, sound and
+# video devices. These are supported by drivers elsewhere.
+#
+cdl_package CYGPKG_HAL_I386_PCMB {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_I386_PC
+    #     ActiveIf: CYGPKG_HAL_I386_PCMB
+};
+
+# >
+# Real-time clock constants.
+# The RTC period is based on the clock input
+# to the 8254, which is 1193180 Hz.
+# CYGNUM_HAL_RTC_PERIOD is set for 100 ticks
+# per second.
+#
+cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+    # There is no associated value.
+};
+
+# >
+# Real-time clock numerator
+#
+cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1000000000
+    # value_source default
+    # Default value: 1000000000
+
+    # The following properties are affected by this value
+    # option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+    # option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_ROUTE_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+};
+
+# Real-time clock denominator
+#
+cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 100
+    # value_source default
+    # Default value: 100
+
+    # The following properties are affected by this value
+    # option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+    # option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_ROUTE_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+};
+
+# Real-time clock period
+#
+cdl_option CYGNUM_HAL_RTC_PERIOD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 11932
+    # value_source default
+    # Default value: 11932
+};
+
+# <
+# Search entire PCI space
+# This option enables searching the entire PCI address space, including
+# up to 256 busses, etc.  Probably only useful when there are bridges or
+# other PCI expanding devices (such as a board with it's own PCI bus)
+# in the system.  If disabled, the system will revert to the default
+# PCI space size (typically 8 busses).
+#
+cdl_option CYGSEM_HAL_I386_PC_LARGE_PCI_SPACE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Switch the display to an alternative video mode
+# This option can be used when building RedBoot to switch
+# the display to a suitable mode, typically before running
+# an eCos graphical application. The mode switch involves
+# calling the PC Video BIOS, so needs to happen while the
+# processor is still running in real mode. Some information
+# about the video BIOS, the current mode, and the available
+# modes will be written to video memory so that the eCos
+# application knows what happened.
+# Different graphics cards use different numbers for the
+# various modes, so there is no simple way of knowing which
+# mode should be specified to achieve the desired resolution.
+# Instead RedBoot can be built with a suitable default, for
+# example 0x0100, and then a simple eCos application can be
+# built using an appropriate eCos configuration and
+# run to find out about all the available mode. RedBoot can
+# then be reconfigured and rebuilt to use a suitable mode.
+# The PC motherboard support package comes with a simple
+# eCos program gfxmode.c which can be used for this.
+#
+cdl_option CYGNUM_HAL_I386_PC_STARTUP_VIDEO_MODE {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 0
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+    # Requires:  !CYGSEM_HAL_I386_PC_DIAG_SCREEN 
+    #     CYGSEM_HAL_I386_PC_DIAG_SCREEN == 1
+    #   --> 0
+};
+
+#
+cdl_component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_SMP_SUPPORT 
+    #     CYGPKG_HAL_SMP_SUPPORT == 0
+    #   --> 0
+
+    # Calculated value:  CYGPKG_HAL_SMP_SUPPORT 
+    #     CYGPKG_HAL_SMP_SUPPORT == 0
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Support for gprof profiling
+# The PC HAL support can provide a profiling timer for use
+# by the gprof package. However the hardware only provides a
+# single source of timer interrupts so this must be shared
+# between the system clock and the profiling code. The current
+# implementation requires that the system clock be initialized
+# first (which happens in a static constructor with priority
+# CYG_INIT_CLOCK), then profiling can be enabled via a call
+# to profile_on().
+#
+cdl_option CYGFUN_HAL_I386_PCMB_GPROF_SUPPORT {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_PROFILE_GPROF
+    #     CYGPKG_PROFILE_GPROF (unknown) == 0
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+};
+
+# Enable PC screen support
+# This option enables support for the PC screen and
+# keyboard. These are combined into a virtual serial
+# device that may be used for diagnostic output.
+# Note that there is little point in trying to use it
+# as a debug channel.
+#
+cdl_interface CYGINT_HAL_I386_PCMB_SCREEN_SUPPORT {
+    # Implemented by CYGSEM_HAL_I386_PC_DIAG_SCREEN, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# <
+# <
+# <
+# I/O sub-system
+# doc: ref/io.html
+# The eCos system is supplied with a number of different
+# device drivers.  This option enables the basic I/O system
+# support which is the basis for all drivers.
+#
+cdl_package CYGPKG_IO {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL
+    #     ActiveIf: CYGPKG_IO
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGPKG_IO
+    # option CYGPKG_IO_FILEIO_DEVFS_SUPPORT
+    #     ActiveIf: CYGPKG_IO
+};
+
+# >
+# Debug I/O sub-system
+# This option enables verbose messages to be displayed on the
+# system 'diag' device during I/O system initialization.
+#
+cdl_option CYGDBG_IO_INIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Basic support for file based I/O
+# This option control support for simple file I/O primitives. It is only
+# present if the FILEIO package is not included.
+#
+cdl_component CYGPKG_IO_FILE_SUPPORT {
+    # This option is not active
+    # ActiveIf constraint: !CYGPKG_IO_FILEIO
+    #     CYGPKG_IO_FILEIO == current
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Number of open files
+# This option controls the number of open files.
+#
+cdl_option CYGPKG_IO_NFILE {
+    # This option is not active
+    # The parent CYGPKG_IO_FILE_SUPPORT is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+};
+
+# <
+# PCI configuration library
+# doc: ref/io-pci.html
+# The PCI configuration library provides initialization of devices
+# on the PCI bus. Functions to find and access these devices are
+# also provided.
+#
+cdl_package CYGPKG_IO_PCI {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# PCI build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_PCI_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the PCI configuration library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_PCI_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the PCI configuration library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_PCI_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Enable debugging.
+# This option enables minimal debugging of the PCI library.
+# In particular, it will print information about devices as the
+# PCI bus is being scanned/searched.
+#
+cdl_option CYGPKG_IO_PCI_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# PCI tests
+# This option specifies the set of tests for the PCI configuration library.
+#
+cdl_option CYGPKG_IO_PCI_TESTS {
+    # Calculated value:  "tests/pci1 tests/pci2" 
+    # Flavor: data
+    # Current_value: tests/pci1 tests/pci2
+};
+
+# Writeback Interrupt Line register.
+# This option causes a PCI device interrupt vector to be
+# written to the Interrupt Line register in config space.
+# This is traditionally done by a BIOS so that device
+# drivers can read the interrupt vector directly from
+# device configuration space.
+#
+cdl_option CYGPKG_IO_PCI_CONFIGURE_INTLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# <
+# Serial device drivers
+# doc: ref/io.html
+# This option enables drivers for basic I/O services on
+# serial devices.
+#
+cdl_package CYGPKG_IO_SERIAL {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO
+    #     CYGPKG_IO == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_GENERIC_16X5X
+    #     ActiveIf: CYGPKG_IO_SERIAL
+    # package CYGPKG_IO_SERIAL_I386_PC
+    #     ActiveIf: CYGPKG_IO_SERIAL
+};
+
+# >
+# Support non-blocking read and write calls
+# This option enables extra code in the generic serial driver
+# which allows clients to switch read() and write() call
+# semantics from blocking to non-blocking.
+#
+cdl_option CYGOPT_IO_SERIAL_SUPPORT_NONBLOCKING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Driver requires block transfer callback functions
+# Some low-level drivers can be optimized to transfer blocks
+# of data instead of a single character at a time. These usually
+# rely on a hardware FIFO of some sort.
+#
+cdl_interface CYGINT_IO_SERIAL_BLOCK_TRANSFER {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Serial driver supports line status
+#
+cdl_interface CYGINT_IO_SERIAL_LINE_STATUS_HW {
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL0, active, enabled
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL1, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 2
+
+    # The following properties are affected by this value
+    # option CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS
+    #     Requires:  CYGINT_IO_SERIAL_LINE_STATUS_HW > 0 
+    # option CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS
+    #     DefaultValue:  0 != CYGINT_IO_SERIAL_LINE_STATUS_HW 
+};
+
+# Support line status callbacks
+# This option indicates that if the serial driver supports it,
+# serial line status and modem status information should be
+# propagated to higher layers via callbacks.
+#
+cdl_option CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGINT_IO_SERIAL_LINE_STATUS_HW 
+    #     CYGINT_IO_SERIAL_LINE_STATUS_HW == 2
+    #   --> 1
+    # Requires:  CYGINT_IO_SERIAL_LINE_STATUS_HW > 0 
+    #     CYGINT_IO_SERIAL_LINE_STATUS_HW == 2
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW
+    #     Requires: CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS
+    # option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW
+    #     DefaultValue:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 ?  CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS : 0 
+};
+
+# Flow control
+# This component contains options related to flow control.
+#
+cdl_component CYGPKG_IO_SERIAL_FLOW_CONTROL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: (CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE || CYGOPT_IO_SERIAL_FLOW_CONTROL_HW)
+    #     CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE == 0
+    #     CYGOPT_IO_SERIAL_FLOW_CONTROL_HW == 0
+    #   --> 0
+};
+
+# >
+# Software flow control
+# This component enables support of software flow control.
+#
+cdl_component CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_SERIAL_FLOW_CONTROL
+    #     Requires: (CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE || CYGOPT_IO_SERIAL_FLOW_CONTROL_HW)
+};
+
+# >
+# Start character
+# This option specifies the ascii character used to
+# indicate that transmission should start.
+#
+cdl_option CYGDAT_IO_SERIAL_FLOW_CONTROL_XON_CHAR {
+    # This option is not active
+    # The parent CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 17
+    # value_source default
+    # Default value: 17
+    # Legal values: 0 to 255
+};
+
+# Stop character
+# This option specifies the ascii character used to
+# indicate that transmission should stop.
+#
+cdl_option CYGDAT_IO_SERIAL_FLOW_CONTROL_XOFF_CHAR {
+    # This option is not active
+    # The parent CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 19
+    # value_source default
+    # Default value: 19
+    # Legal values: 0 to 255
+};
+
+# <
+# Hardware flow control
+# If the hardware supports it, this option allows hardware
+# flow control to be enabled. This may be in the form of
+# either or both of RTS/CTS, or DSR/DTR flow control.
+#
+cdl_option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+    # ActiveIf constraint:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 
+    #     CYGINT_IO_SERIAL_FLOW_CONTROL_HW == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 ?  CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS : 0 
+    #     CYGINT_IO_SERIAL_FLOW_CONTROL_HW == 0
+    #     CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS == 1
+    #   --> 0
+    # Requires:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 
+    #     CYGINT_IO_SERIAL_FLOW_CONTROL_HW == 0
+    #   --> 0
+    # Requires: CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS
+    #     CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_SERIAL_FLOW_CONTROL
+    #     Requires: (CYGOPT_IO_SERIAL_FLOW_CONTROL_SOFTWARE || CYGOPT_IO_SERIAL_FLOW_CONTROL_HW)
+};
+
+# Serial h/w supports hardware flow control
+#
+cdl_interface CYGINT_IO_SERIAL_FLOW_CONTROL_HW {
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL0, active, enabled
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL1, active, enabled
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 2
+
+    # The following properties are affected by this value
+    # option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW
+    #     ActiveIf:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 
+    # option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW
+    #     Requires:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 
+    # option CYGOPT_IO_SERIAL_FLOW_CONTROL_HW
+    #     DefaultValue:  CYGINT_IO_SERIAL_FLOW_CONTROL_HW > 0 ?  CYGOPT_IO_SERIAL_SUPPORT_LINE_STATUS : 0 
+};
+
+# Default flow control method
+# This option allows a default flow control method
+# to be defined. Combinations of flow control methods
+# may also be set, but this is only possible by
+# using the cyg_io_set_config() API in source code.
+#
+cdl_option CYGDAT_IO_SERIAL_FLOW_CONTROL_DEFAULT {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value NONE
+    # value_source default
+    # Default value: NONE
+    # Legal values:  "NONE" "XONXOFF" "RTSCTS" "DSRDTR" 
+};
+
+# Rx flow control low water mark
+# This sets the water mark used for determining
+# when to disable flow control, expressed
+# as a percentage of the buffer size. When the
+# receive buffer size is lower than this percentage,
+# if the transmitter had previously been throttled, it
+# will now be informed it can restart.
+#
+cdl_option CYGNUM_IO_SERIAL_FLOW_CONTROL_LOW_WATER_PERCENT {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 33
+    # value_source default
+    # Default value: 33
+    # Legal values: 1 to 100
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT
+    #     Requires:  CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT >=  CYGNUM_IO_SERIAL_FLOW_CONTROL_LOW_WATER_PERCENT 
+};
+
+# Rx flow control high water mark
+# This sets the water mark used for determining
+# when to enable flow control, expressed
+# as a percentage of the buffer size. When the
+# receive buffer size exceeds this percentage,
+# signals are sent to the transmitter to tell it
+# to throttle tranmission.
+#
+cdl_option CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_FLOW_CONTROL is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 66
+    # value_source default
+    # Default value: 66
+    # Legal values: 1 to 100
+    # Requires:  CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT >=  CYGNUM_IO_SERIAL_FLOW_CONTROL_LOW_WATER_PERCENT 
+    #     CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT == 0
+    #     CYGNUM_IO_SERIAL_FLOW_CONTROL_LOW_WATER_PERCENT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT
+    #     Requires:  CYGNUM_IO_SERIAL_FLOW_CONTROL_HIGH_WATER_PERCENT >=  CYGNUM_IO_SERIAL_FLOW_CONTROL_LOW_WATER_PERCENT 
+};
+
+# <
+# TTY-mode serial device drivers
+# This option enables a simple terminal-like device driver 
+# that can be used for serial devices that interact with humans,
+# such as a system console.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# HAL/diag serial device driver
+# This option enables the use of the HAL diagnostic channel
+# via the standard I/O drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_HALDIAG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  (CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE == "\"/dev/ttydiag\"" ?  CYGPKG_IO_SERIAL_HALDIAG : 1) 
+};
+
+# Console device name
+# This option selects the TTY device to use for the console.
+#
+cdl_option CYGDAT_IO_SERIAL_TTY_CONSOLE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ttydiag\""
+    # value_source default
+    # Default value: "\"/dev/ttydiag\""
+
+    # The following properties are affected by this value
+    # option CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE
+    #     DefaultValue:  CYGDAT_IO_SERIAL_TTY_CONSOLE ? CYGDAT_IO_SERIAL_TTY_CONSOLE : "\"/dev/null\"" 
+    # option CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE
+    #     DefaultValue:  CYGDAT_IO_SERIAL_TTY_CONSOLE ? CYGDAT_IO_SERIAL_TTY_CONSOLE : "\"/dev/null\"" 
+};
+
+# TTY mode HAL/diag channel
+# This option causes '/dev/ttydiag' to be included in the standard
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY_TTYDIAG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# TTY mode channel #0
+# This option causes '/dev/tty0' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY_TTY0 {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+};
+
+# >
+# TTY mode channel #0 device
+# This option selects the physical device to use for 
+# '/dev/tty0'.
+#
+cdl_option CYGDAT_IO_SERIAL_TTY_TTY0_DEV {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser0\""
+    # value_source default
+    # Default value: "\"/dev/ser0\""
+};
+
+# <
+# TTY mode channel #1
+# This option causes '/dev/tty1' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY_TTY1 {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+};
+
+# >
+# TTY mode channel #1 device
+# This option selects the physical device to use for 
+# '/dev/tty1'.
+#
+cdl_option CYGDAT_IO_SERIAL_TTY_TTY1_DEV {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser1\""
+    # value_source default
+    # Default value: "\"/dev/ser1\""
+};
+
+# <
+# TTY mode channel #2
+# This option causes '/dev/tty2' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY_TTY2 {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+};
+
+# >
+# TTY mode channel #2 device
+# This option selects the physical device to use for 
+# '/dev/tty2'.
+#
+cdl_option CYGDAT_IO_SERIAL_TTY_TTY2_DEV {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser2\""
+    # value_source default
+    # Default value: "\"/dev/ser2\""
+};
+
+# <
+# TTY mode channel #3
+# This option causes '/dev/tty3' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TTY_TTY3 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# TTY mode channel #3 device
+# This option selects the physical device to use for 
+# '/dev/tty3'.
+#
+cdl_option CYGDAT_IO_SERIAL_TTY_TTY3_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_TTY_TTY3 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser3\""
+    # value_source default
+    # Default value: "\"/dev/ser3\""
+};
+
+# <
+# <
+# Termios compatible TTY drivers
+# This option enables terminal drivers compatible with
+# POSIX termios.
+#
+cdl_component CYGPKG_IO_SERIAL_TERMIOS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_ISOINFRA && 0 != CYGPKG_IO_FILEIO &&  0 != CYGINT_ISO_ERRNO_CODES &&  0 != CYGINT_ISO_ERRNO 
+    #     CYGPKG_ISOINFRA == current
+    #     CYGPKG_IO_FILEIO == current
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_IO_FILEIO
+    #     CYGPKG_IO_FILEIO == current
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO_CODES
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+};
+
+# >
+# Interface for termios tty driver file enabling
+#
+cdl_interface CYGINT_IO_SERIAL_TERMIOS_TERMIOS_TTY {
+    # Implemented by CYGPKG_IO_SERIAL_TERMIOS_TERMIOS0, active, disabled
+    # Implemented by CYGPKG_IO_SERIAL_TERMIOS_TERMIOS1, active, disabled
+    # Implemented by CYGPKG_IO_SERIAL_TERMIOS_TERMIOS2, active, disabled
+    # Implemented by CYGPKG_IO_SERIAL_TERMIOS_TERMIOS3, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGBLD_IO_SERIAL_TERMIOS_TERMIOS_TTY
+    #     ActiveIf:  CYGINT_IO_SERIAL_TERMIOS_TERMIOS_TTY > 0 
+};
+
+# Build termios tty driver file
+#
+cdl_option CYGBLD_IO_SERIAL_TERMIOS_TERMIOS_TTY {
+    # This option is not active
+    # ActiveIf constraint:  CYGINT_IO_SERIAL_TERMIOS_TERMIOS_TTY > 0 
+    #     CYGINT_IO_SERIAL_TERMIOS_TERMIOS_TTY == 0
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Termios TTY channel #0
+# This option causes '/dev/termios0' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TERMIOS_TERMIOS0 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Termios TTY channel #0 device
+# This option selects the physical device to use for 
+# '/dev/termios0'.
+#
+cdl_option CYGDAT_IO_SERIAL_TERMIOS_TERMIOS0_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_TERMIOS_TERMIOS0 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser0\""
+    # value_source default
+    # Default value: "\"/dev/ser0\""
+};
+
+# <
+# Termios TTY channel #1
+# This option causes '/dev/termios1' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TERMIOS_TERMIOS1 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Termios TTY channel #1 device
+# This option selects the physical device to use for 
+# '/dev/termios1'.
+#
+cdl_option CYGDAT_IO_SERIAL_TERMIOS_TERMIOS1_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_TERMIOS_TERMIOS1 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser1\""
+    # value_source default
+    # Default value: "\"/dev/ser1\""
+};
+
+# <
+# Termios TTY channel #2
+# This option causes '/dev/termios2' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TERMIOS_TERMIOS2 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Termios TTY channel #2 device
+# This option selects the physical device to use for 
+# '/dev/termios2'.
+#
+cdl_option CYGDAT_IO_SERIAL_TERMIOS_TERMIOS2_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_TERMIOS_TERMIOS2 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser2\""
+    # value_source default
+    # Default value: "\"/dev/ser2\""
+};
+
+# <
+# Termios TTY channel #3
+# This option causes '/dev/termios3' to be included in the standard 
+# drivers.
+#
+cdl_component CYGPKG_IO_SERIAL_TERMIOS_TERMIOS3 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Termios TTY channel #3 device
+# This option selects the physical device to use for 
+# '/dev/termios3'.
+#
+cdl_option CYGDAT_IO_SERIAL_TERMIOS_TERMIOS3_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_TERMIOS_TERMIOS3 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser3\""
+    # value_source default
+    # Default value: "\"/dev/ser3\""
+};
+
+# <
+# Support signals
+# This option selects whether those parts of the termios
+# interface involving signals is supported. This includes
+# BRKINT mode, the INTR and QUIT characters, and whether
+# SIGHUP is sent on terminal close.
+#
+cdl_option CYGSEM_IO_SERIAL_TERMIOS_USE_SIGNALS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGINT_ISO_SIGNAL_NUMBERS != 0 &&  CYGINT_ISO_SIGNAL_IMPL != 0 
+    #     CYGINT_ISO_SIGNAL_NUMBERS == 1
+    #     CYGINT_ISO_SIGNAL_IMPL == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_SIGNAL_NUMBERS
+    #     CYGINT_ISO_SIGNAL_NUMBERS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_SIGNAL_IMPL
+    #     CYGINT_ISO_SIGNAL_IMPL == 1
+    #   --> 1
+};
+
+# <
+# Hardware serial device drivers
+# This option enables the hardware device drivers
+# for the current platform.
+#
+cdl_component CYGPKG_IO_SERIAL_DEVICES {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_IO_SERIAL_TESTS
+    #     Calculated:  CYGPKG_IO_SERIAL_DEVICES ? "tests/serial1 tests/serial2 tests/serial3 tests/serial4 tests/serial5 tests/tty1 tests/tty2 tests/flow1 tests/flow2" : "" 
+};
+
+# >
+# 16x5x generic serial device drivers
+# This option enables the serial device drivers for the
+# 16x5x compatiple controllers.
+#
+cdl_package CYGPKG_IO_SERIAL_GENERIC_16X5X {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_SERIAL
+    #     CYGPKG_IO_SERIAL == current
+    #   --> 1
+    # ActiveIf constraint: CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED
+    #     CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED == 2
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+};
+
+# >
+# 16x5x FIFO support
+# Options to configure the FIFO on a 16550 (or above) variant.
+#
+cdl_component CYGPKG_IO_SERIAL_GENERIC_16X5X_FIFO {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Threshold for RX interrupt on 16550 FIFO
+# This options configures the threshold value at which
+# the RX interrupt occurs when a FIFO is used. (16550 and
+# above only), this may be after 1, 4, 8 or 14 characters.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_FIFO_RX_THRESHOLD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Legal values:  14 8 4 1 
+};
+
+# 16x5x TX FIFO size
+# Configures the maximum number of bytes written to the
+# 16x5x UART transmit FIFO when the TX interrupt occurs.
+#
+cdl_option CYGNUM_IO_SERIAL_GENERIC_16X5X_FIFO_TX_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+};
+
+# <
+# Serial device driver build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_SERIAL_GENERIC_16X5X_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are
+# used in addition to the set of global flags.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are
+# removed from the set of global flags if present.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# PC serial device drivers
+# This option enables the serial device drivers for the
+# PC.
+#
+cdl_package CYGPKG_IO_SERIAL_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_SERIAL
+    #     CYGPKG_IO_SERIAL == current
+    #   --> 1
+    # ActiveIf constraint: CYGPKG_HAL_I386_PCMB
+    #     CYGPKG_HAL_I386_PCMB == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+};
+
+# >
+# Generic 16x5x serial driver required
+#
+cdl_interface CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED {
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL0, active, enabled
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL1, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 2
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_GENERIC_16X5X
+    #     ActiveIf: CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED
+};
+
+# PC serial port 0 driver
+# This option includes the serial device driver for port 0 on the 
+# PC.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_SERIAL0 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_SERIAL_I386_PC_TESTING
+    #     ActiveIf: CYGPKG_IO_SERIAL_I386_PC_SERIAL0
+};
+
+# >
+# Device name for PC serial port 0
+# This option specifies the device name port 0 on the PC.
+#
+cdl_option CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser0\""
+    # value_source default
+    # Default value: "\"/dev/ser0\""
+
+    # The following properties are affected by this value
+    # option CYGPRI_SER_TEST_SER_DEV
+    #     DefaultValue:  CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME 
+};
+
+# Baud rate for the PC serial port 0 driver
+# This option specifies the default baud rate (speed) for the
+# PC port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values:  50 75 110 "134_5" 150 200 300 600 1200 1800 2400 3600
+    #                           4800 7200 9600 14400 19200 38400 57600 115200 230400
+    #             
+};
+
+# Buffer size for the PC serial port 0 driver
+# This option specifies the size of the internal buffers used
+# for the PC port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_BUFSIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+    # Legal values: 0 to 8192
+};
+
+# I/O base address for the i386-PC serial port 0
+# This option specifies the I/O address of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IOBASE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000003F8
+    # value_source default
+    # Default value: 0x000003F8
+    # Legal values: 0 to 0xFF8
+};
+
+# IRQ for the i386-PC serial port 0
+# This option specifies the IRQ of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 0 to 15
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_INT
+    #     DefaultValue:  CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ + 32 
+};
+
+# INT for the i386-PC serial port 0
+# This option specifies the interrupt vector of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_INT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 36
+    # value_source default
+    # Default value:  CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ + 32 
+    #     CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ == 4
+    #   --> 36
+    # Legal values: 32 to 47
+};
+
+# <
+# PC serial port 1 driver
+# This option includes the serial device driver for port 1 on
+# the PC.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_SERIAL1 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Device name for PC serial port 1
+# This option specifies the device name port 1 on the PC.
+#
+cdl_option CYGDAT_IO_SERIAL_I386_PC_SERIAL1_NAME {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser1\""
+    # value_source default
+    # Default value: "\"/dev/ser1\""
+};
+
+# Baud rate for the PC serial port 1 driver
+# This option specifies the default baud rate (speed) for the
+# PC port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values:  50 75 110 "134_5" 150 200 300 600 1200 1800 2400 3600
+    #                           4800 7200 9600 14400 19200 38400 57600 115200 230400
+    #             
+};
+
+# Buffer size for the PC serial port 1 driver
+# This option specifies the size of the internal buffers used
+# for the PC port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_BUFSIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+    # Legal values: 0 to 8192
+};
+
+# I/O base address for the i386-PC serial port 1
+# This option specifies the I/O address of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IOBASE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000002F8
+    # value_source default
+    # Default value: 0x000002F8
+    # Legal values: 0 to 0xFF8
+};
+
+# IRQ for the i386-PC serial port 1
+# This option specifies the IRQ of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value: 3
+    # Legal values: 0 to 15
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_INT
+    #     DefaultValue:  CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ + 32 
+};
+
+# INT for the i386-PC serial port 1
+# This option specifies the interrupt vector of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_INT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 35
+    # value_source default
+    # Default value:  CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ + 32 
+    #     CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ == 3
+    #   --> 35
+    # Legal values: 32 to 47
+};
+
+# <
+# Serial device driver build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_SERIAL_I386_PC_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_SERIAL_I386_PC_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# Testing parameters
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_TESTING {
+    # ActiveIf constraint: CYGPKG_IO_SERIAL_I386_PC_SERIAL0
+    #     CYGPKG_IO_SERIAL_I386_PC_SERIAL0 == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Serial device used for testing
+#
+cdl_option CYGPRI_SER_TEST_SER_DEV {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser0\""
+    # value_source default
+    # Default value:  CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME 
+    #     CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME == "\"/dev/ser0\""
+    #   --> "\"/dev/ser0\""
+};
+
+# <
+# <
+# <
+# Build extra serial tests
+# This option enables the building of some extra tests which
+# can be used when testing / debugging serial drivers. These
+# are not built by default since they do not use the dedicated
+# testing infrastructure.
+#
+cdl_option CYGBLD_IO_SERIAL_EXTRA_TESTS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Serial device driver build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_SERIAL_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the serial device drivers. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_SERIAL_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the serial device drivers. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_SERIAL_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Serial device driver tests
+# This option specifies the set of tests for the serial device drivers.
+#
+cdl_option CYGPKG_IO_SERIAL_TESTS {
+    # Calculated value:  CYGPKG_IO_SERIAL_DEVICES ? "tests/serial1 tests/serial2 tests/serial3 tests/serial4 tests/serial5 tests/tty1 tests/tty2 tests/flow1 tests/flow2" : "" 
+    #     CYGPKG_IO_SERIAL_DEVICES == 1
+    # Flavor: data
+    # Current_value: tests/serial1 tests/serial2 tests/serial3 tests/serial4 tests/serial5 tests/tty1 tests/tty2 tests/flow1 tests/flow2
+};
+
+# <
+# Enable serial device select support
+# This option enables support for the select() API function on all
+# serial devices.
+#
+cdl_option CYGPKG_IO_SERIAL_SELECT_SUPPORT {
+    # ActiveIf constraint: CYGPKG_IO_FILEIO
+    #     CYGPKG_IO_FILEIO == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGFUN_IO_FILEIO_SELECT == 1 
+    #     CYGFUN_IO_FILEIO_SELECT == 1
+    #   --> 1
+};
+
+# Serial testing specification
+#
+cdl_component CYGPKG_IO_SERIAL_TEST_SPECS {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Skip 9600 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_9600 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 14400 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_14400 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 19200 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_19200 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 38400 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_38400 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 57600 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_57600 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 115200 baud testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_115200 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip even-parity testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_PARITY_EVEN {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip odd-parity testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_PARITY_ODD {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Skip 2-stop bit testing
+#
+cdl_interface CYGINT_IO_SERIAL_TEST_SKIP_STOP_2 {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# <
+# <
+# Common ethernet support
+# doc: ref/io-eth-drv-generic.html
+# Platform independent ethernet drivers
+#
+cdl_package CYGPKG_IO_ETH_DRIVERS {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_RLTK_8139
+    #     ActiveIf: CYGPKG_IO_ETH_DRIVERS
+    # package CYGPKG_DEVS_ETH_I386_PC_RLTK8139
+    #     ActiveIf: CYGPKG_IO_ETH_DRIVERS
+    # package CYGPKG_NET_ETHERCATMASTER
+    #     Requires: CYGPKG_IO_ETH_DRIVERS
+};
+
+# >
+# Network drivers
+#
+cdl_interface CYGHWR_NET_DRIVERS {
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0, active, disabled
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# Driver supports multicast addressing
+# This interface defines whether or not a driver can handle
+# requests for multicast addressing.
+#
+cdl_interface CYGINT_IO_ETH_MULTICAST {
+    # Implemented by CYGPKG_DEVS_ETH_RLTK_8139, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# Support printing driver debug information
+# Selecting this option will include code to allow the driver to
+# print lots of information on diagnostic output such as full
+# packet dumps.
+#
+cdl_component CYGDBG_IO_ETH_DRIVERS_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Driver debug output verbosity
+# The value of this option indicates the default verbosity
+# level of debugging output. 0 means no debugging output
+# is made by default. Higher values indicate higher verbosity.
+# The verbosity level may also be changed at run time by
+# changing the variable cyg_io_eth_net_debug.
+#
+cdl_option CYGDBG_IO_ETH_DRIVERS_DEBUG_VERBOSITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Size of scatter-gather I/O lists
+# A scatter-gather list is used to pass requests to/from
+# the physical device driver.  This list can typically be
+# small, as the data is normally already packed into reasonable
+# chunks.
+#
+cdl_option CYGNUM_IO_ETH_DRIVERS_SG_LIST_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+};
+
+# Support for standard eCos TCP/IP stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_NET {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+};
+
+# >
+# Warn when there are no more mbufs
+# Warnings about running out of mbufs are printed to the
+# diagnostic output channel via diag_printf() if this option
+# is enabled.  Mbufs are the network stack's basic dynamic
+# memory objects that hold all packets in transit; running
+# out is bad for performance but not fatal, not a crash.
+# You might want to turn off the warnings to preserve realtime
+# properties of the system even in extremis.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_WARN_NO_MBUFS {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_NET is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Simulate network failures for testing
+# This package contains a suite of simulated failure modes
+# for the ethernet device layer, including dropping and/or
+# corrupting received packets, dropping packets queued for
+# transmission, and simulating a complete network break.
+# It requires the kernel as a source of time information.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_NET is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Drop incoming packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_DROP_RX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Corrupt incoming packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_CORRUPT_RX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Drop outgoing packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_DROP_TX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Simulate a line cut from time to time
+# This option causes the system to drop all packets for a
+# short random period (10s of seconds), and then act
+# normally for up to 4 times that long.  This simulates your
+# sysadmin fiddling with plugs in the network switch
+# cupboard.
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_LINE_CUT {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# <
+# Support for stand-alone network stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_STAND_ALONE {
+    # ActiveIf constraint: !CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 1
+
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+    # Requires: CYGINT_ISO_STRING_MEMFUNCS
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+};
+
+# >
+# Pass packets to an alternate stack
+# Define this to allow packets seen by this layer to be
+# passed on to the previous logical layer, i.e. when
+# stand-alone processing replaces system (eCos) processing.
+#
+cdl_option CYGSEM_IO_ETH_DRIVERS_PASS_PACKETS {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_STAND_ALONE is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 != CYGPKG_REDBOOT_NETWORKING 
+    #     CYGPKG_REDBOOT_NETWORKING (unknown) == 0
+    #   --> 0
+};
+
+# Number of [network] buffers
+# This option is used to allocate space to buffer incoming network
+# packets.  These buffers are used to hold data until they can be
+# logically processed by higher layers.
+#
+cdl_option CYGNUM_IO_ETH_DRIVERS_NUM_PKT {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_STAND_ALONE is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 2 to 32
+};
+
+# Show driver warnings
+# Selecting this option will allows the stand-alone ethernet driver
+# to display warnings on the system console when incoming network
+# packets are being discarded due to lack of buffer space.
+#
+cdl_option CYGSEM_IO_ETH_DRIVERS_WARN {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_STAND_ALONE is disabled
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Support for lwIP network stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_LWIP {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET_LWIP
+    #     CYGPKG_NET_LWIP (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: !CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 1
+};
+
+# Support for EtherCAT Master protocol stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_ETHERCATMASTER {
+    # ActiveIf constraint: CYGPKG_NET_ETHERCATMASTER
+    #     CYGPKG_NET_ETHERCATMASTER == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: !CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 1
+};
+
+# >
+# Number of [network] buffers
+# This option is used to allocate space to buffer incoming network
+# packets.  These buffers are used to hold data until they can be
+# logically processed by higher layers.
+#
+cdl_option CYGNUM_IO_ETH_DRIVERS_ETHERCATMASTER_NUM_PKT {
+    # Flavor: data
+    user_value 32
+    # value_source user
+    # Default value: 4
+    # Legal values: 2 to 32
+};
+
+# <
+# Interrupt support required
+# This interface is used to indicate to the low
+# level device drivers that interrupt driven operation
+# is required by higher layers.
+#
+cdl_interface CYGINT_IO_ETH_INT_SUPPORT_REQUIRED {
+    # Implemented by CYGPKG_IO_ETH_DRIVERS_NET, inactive, enabled
+    # Implemented by CYGPKG_IO_ETH_DRIVERS_LWIP, inactive, enabled
+    # Implemented by CYGPKG_IO_ETH_DRIVERS_ETHERCATMASTER, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+
+    # The following properties are affected by this value
+};
+
+# Common ethernet support build options
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the common ethernet support package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D_KERNEL -D__ECOS"
+    # value_source default
+    # Default value: "-D_KERNEL -D__ECOS"
+};
+
+# <
+# RealTek 8139 ethernet driver
+# Ethernet driver for RealTek 8139 controller.
+#
+cdl_package CYGPKG_DEVS_ETH_RLTK_8139 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+    # ActiveIf constraint: CYGINT_DEVS_ETH_RLTK_8139_REQUIRED
+    #     CYGINT_DEVS_ETH_RLTK_8139_REQUIRED == 1
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# Share interrupt with other devices
+# If this option is enabled, the driver does not assume that it is
+# in sole possession of the interrupt pin used by the 8139.
+#
+cdl_component CYGPKG_DEVS_ETH_RLTK_8139_SHARE_INTERRUPTS {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+};
+
+# >
+# Mask 8139 interrupts on chip
+# If this option is enabled, the driver masks interrupts in the 8139's
+# status register, and does not mask the interrupt vector. This is
+# only useful if the 8139 must share it's interrupt line with other
+# devices.
+#
+cdl_option CYGPKG_DEVS_ETH_RLTK_8139_MASK_INTERRUPTS_IN_8139 {
+    # This option is not active
+    # The parent CYGPKG_DEVS_ETH_RLTK_8139_SHARE_INTERRUPTS is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Print debugging messages
+# If this option is set, a lot of debugging messages are printed
+# to the console to help debug the driver.
+#
+cdl_option CYGDBG_DEVS_ETH_RLTK_8139_CHATTER {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Size of the receive ring
+# The 8139 stores all received packets in a single 'rx ring'
+# located somewhere in physical memory. The size of this ring
+# can be varied from ~8k to ~64k; however the driver currently
+# supports a maximum buffer size of only ~32k (so we can use
+# the 8139's WRAP mode). The actual buffer size is
+# 8192<<x + 16 + 1536 bytes, with x being the value of this
+# option.
+#
+cdl_option CYGNUM_DEVS_ETH_RLTK_8139_RX_BUF_LEN_IDX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2
+    # value_source default
+    # Default value:  CYGPKG_REDBOOT ? 0 : 2 
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 2
+    # Legal values: 0 to 2
+};
+
+# RealTek 8139 ethernet driver build options
+#
+cdl_component CYGPKG_DEVS_ETH_RLTK_8139_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the RealTek 8139 ethernet driver package. These
+# flags are used in addition to the set of global flags.
+#
+cdl_option CYGPKG_DEVS_ETH_RLTK_8139_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D_KERNEL -D__ECOS"
+    # value_source default
+    # Default value: "-D_KERNEL -D__ECOS"
+};
+
+# <
+# <
+# PC RealTek 8139 ethernet driver
+# Ethernet driver for standard PC's.
+#
+cdl_package CYGPKG_DEVS_ETH_I386_PC_RLTK8139 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+    # ActiveIf constraint: CYGPKG_HAL_I386_PC
+    #     CYGPKG_HAL_I386_PC == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# RealTek 8139 ethernet driver required
+#
+cdl_interface CYGINT_DEVS_ETH_RLTK_8139_REQUIRED {
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0, active, disabled
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_RLTK_8139
+    #     ActiveIf: CYGINT_DEVS_ETH_RLTK_8139_REQUIRED
+};
+
+# Ethernet port 0 driver
+#
+cdl_component CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0 {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+};
+
+# >
+# Device name for the ETH0 ethernet port 0 driver
+# This option sets the name of the ethernet device for the
+# RealTek 8139 ethernet port 0.
+#
+cdl_option CYGDAT_DEVS_ETH_I386_PC_RLTK8139_ETH0_NAME {
+    # This option is not active
+    # The parent CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"eth0\""
+    # value_source default
+    # Default value: "\"eth0\""
+};
+
+# <
+# Ethernet port 1 driver
+#
+cdl_component CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1 {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+};
+
+# >
+# Device name for the ETH1 ethernet port 1 driver
+# This option sets the name of the ethernet device for the
+# RealTek 8139 ethernet port 1.
+#
+cdl_option CYGDAT_DEVS_ETH_I386_PC_RLTK8139_ETH1_NAME {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"eth1\""
+    # value_source default
+    # Default value: "\"eth1\""
+};
+
+# <
+# <
+# <
+# <
+# Infrastructure
+# Common types and useful macros.
+# Tracing and assertion facilities.
+# Package startup options.
+#
+cdl_package CYGPKG_INFRA {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_HAL
+    #     Requires: CYGPKG_INFRA
+};
+
+# >
+# Asserts & Tracing
+# The eCos source code contains a significant amount of
+# internal debugging support, in the form of assertions and
+# tracing.
+# Assertions check at runtime that various conditions are as
+# expected; if not, execution is halted.
+# Tracing takes the form of text messages that are output
+# whenever certain events occur, or whenever functions are
+# called or return.
+# The most important property of these checks and messages is
+# that they are not required for the program to run.
+# It is prudent to develop software with assertions enabled,
+# but disable them when making a product release, thus
+# removing the overhead of that checking.
+# It is possible to enable assertions and tracing
+# independently.
+# There are also options controlling the exact behaviour of
+# the assertion and tracing facilities, thus giving users
+# finer control over the code and data size requirements.
+#
+cdl_component CYGPKG_INFRA_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGNUM_INFRA_EMPTY_DELETE_THRESHOLD
+    #     ActiveIf: CYGPKG_INFRA_DEBUG
+    # component CYGFUN_KERNEL_THREADS_STACK_CHECKING
+    #     ActiveIf: CYGPKG_INFRA_DEBUG
+    # component CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT
+    #     DefaultValue:  0 != CYGPKG_INFRA_DEBUG 
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+};
+
+# >
+# Use asserts
+# If this option is defined, asserts in the code are tested.
+# Assert functions (CYG_ASSERT()) are defined in
+# 'include/cyg/infra/cyg_ass.h' within the 'install' tree.
+# If it is not defined, these result in no additional
+# object code and no checking of the asserted conditions.
+#
+cdl_component CYGDBG_USE_ASSERTS {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    #     CYGINT_INFRA_DEBUG_TRACE_IMPL == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGFUN_KERNEL_THREADS_STACK_CHECKING
+    #     ActiveIf: CYGDBG_USE_ASSERTS
+    # option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG
+    #     Requires: CYGDBG_USE_ASSERTS
+    # option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG
+    #     DefaultValue:  0 != CYGDBG_USE_ASSERTS 
+};
+
+# >
+# Preconditions
+# This option allows individual control of preconditions.
+# A precondition is one type of assert, which it is
+# useful to control separately from more general asserts.
+# The function is CYG_PRECONDITION(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_PRECONDITIONS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Postconditions
+# This option allows individual control of postconditions.
+# A postcondition is one type of assert, which it is
+# useful to control separately from more general asserts.
+# The function is CYG_POSTCONDITION(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_POSTCONDITIONS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Loop invariants
+# This option allows individual control of loop invariants.
+# A loop invariant is one type of assert, which it is
+# useful to control separately from more general asserts,
+# particularly since a loop invariant is typically evaluated
+# a great many times when used correctly.
+# The function is CYG_LOOP_INVARIANT(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_LOOP_INVARIANTS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use assert text
+# All assertions within eCos contain a text message
+# which should give some information about the condition
+# being tested.
+# These text messages will end up being embedded in the
+# application image and hence there is a significant penalty
+# in terms of image size.
+# It is possible to suppress the use of these messages by
+# disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information if an assertion actually gets
+# triggered.
+#
+cdl_option CYGDBG_INFRA_DEBUG_ASSERT_MESSAGE {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Use tracing
+# If this option is defined, tracing operations
+# result in output or logging, depending on other options.
+# This may have adverse effects on performance, if the time
+# taken to output message overwhelms the available CPU
+# power or output bandwidth.
+# Trace functions (CYG_TRACE()) are defined in
+# 'include/cyg/infra/cyg_trac.h' within the 'install' tree.
+# If it is not defined, these result in no additional
+# object code and no trace information.
+#
+cdl_component CYGDBG_USE_TRACING {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    #     CYGINT_INFRA_DEBUG_TRACE_IMPL == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_WRAP
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_HALT
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT_ON_ASSERT
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_KERNEL_TRACE_TIMESLICE
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # component CYGPKG_LIBM_TRACE
+    #     Requires: CYGDBG_USE_TRACING
+};
+
+# >
+# Trace function reports
+# This option allows individual control of
+# function entry/exit tracing, independent of
+# more general tracing output.
+# This may be useful to remove clutter from a
+# trace log.
+#
+cdl_option CYGDBG_INFRA_DEBUG_FUNCTION_REPORTS {
+    # This option is not active
+    # The parent CYGDBG_USE_TRACING is not active
+    # The parent CYGDBG_USE_TRACING is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use trace text
+# All trace calls within eCos contain a text message
+# which should give some information about the circumstances.
+# These text messages will end up being embedded in the
+# application image and hence there is a significant penalty
+# in terms of image size.
+# It is possible to suppress the use of these messages by
+# disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information available in the trace output,
+# possibly only filenames and line numbers.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_MESSAGE {
+    # This option is not active
+    # The parent CYGDBG_USE_TRACING is not active
+    # The parent CYGDBG_USE_TRACING is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Trace output implementations
+#
+cdl_interface CYGINT_INFRA_DEBUG_TRACE_IMPL {
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_NULL, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER, inactive, enabled
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # component CYGDBG_USE_ASSERTS
+    #     Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    # component CYGDBG_USE_TRACING
+    #     Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+};
+
+# Null output
+# A null output module which is useful when
+# debugging interactively; the output routines
+# can be breakpointed rather than have them actually
+# 'print' something.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_NULL {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Simple output
+# An output module which produces simple output
+# from tracing and assertion events.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_TRACE_TIMESLICE
+    #     Requires: !CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE
+};
+
+# Fancy output
+# An output module which produces fancy output
+# from tracing and assertion events.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_TRACE_TIMESLICE
+    #     Requires: !CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY
+};
+
+# Buffered tracing
+# An output module which buffers output
+# from tracing and assertion events. The stored
+# messages are output when an assert fires, or
+# CYG_TRACE_PRINT() (defined in <cyg/infra/cyg_trac.h>)
+# is called.
+# Of course, there will only be stored messages
+# if tracing per se (CYGDBG_USE_TRACING)
+# is enabled above.
+#
+cdl_component CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Trace buffer size
+# The size of the trace buffer. This counts the number
+# of trace records stored. When the buffer fills it
+# either wraps, stops recording, or generates output.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 5 to 65535
+};
+
+# Wrap trace buffer when full
+# When the trace buffer has filled with records it
+# starts again at the beginning. Hence only the last
+# CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE messages will
+# be recorded.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_WRAP {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Halt trace buffer when full
+# When the trace buffer has filled with records it
+# stops recording. Hence only the first
+# CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE messages will
+# be recorded.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_HALT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Print trace buffer when full
+# When the trace buffer has filled with records it
+# prints the contents of the buffer. The buffer is then
+# emptied and the system continues.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Print trace buffer on assert fail
+# When an assertion fails the trace buffer will be 
+# printed to the default diagnostic device.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT_ON_ASSERT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Use function names
+# All trace and assert calls within eCos contain a
+# reference to the builtin macro '__PRETTY_FUNCTION__',
+# which evaluates to a string containing
+# the name of the current function.
+# This is useful when reading a trace log.
+# It is possible to suppress the use of the function name
+# by disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information available in the trace output,
+# possibly only filenames and line numbers.
+#
+cdl_option CYGDBG_INFRA_DEBUG_FUNCTION_PSEUDOMACRO {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Startup options
+# Some packages require a startup routine to be called.
+# This can be carried out by application code, by supplying
+# a routine called cyg_package_start() which calls the
+# appropriate package startup routine(s).
+# Alternatively, this routine can be constructed automatically
+# and configured to call the startup routines of your choice.
+#
+cdl_component CYGPKG_INFRA_STARTUP {
+    # There is no associated value.
+};
+
+# >
+# Start uITRON subsystem
+# Generate a call to initialize the
+# uITRON compatibility subsystem
+# within the system version of cyg_package_start().
+# This enables compatibility with uITRON.
+# You must configure uITRON with the correct tasks before
+# starting the uItron subsystem.
+# If this is disabled, and you want to use uITRON,
+# you must call cyg_uitron_start() from your own
+# cyg_package_start() or cyg_userstart().
+#
+cdl_option CYGSEM_START_UITRON_COMPATIBILITY {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_UITRON
+    #     CYGPKG_UITRON (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGPKG_UITRON
+    #     CYGPKG_UITRON (unknown) == 0
+    #   --> 0
+};
+
+# <
+# Smaller slower memcpy()
+# Enabling this option causes the implementation of
+# the standard memcpy() routine to reduce code
+# size at the expense of execution speed. This
+# option is automatically enabled with the use of
+# the -Os option to the compiler. Also note that
+# the compiler will try to use its own builtin
+# version of memcpy() if possible, ignoring the
+# implementation in this package, unless given
+# the -fno-builtin compiler option.
+#
+cdl_option CYGIMP_INFRA_PREFER_SMALL_TO_FAST_MEMCPY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Smaller slower memset()
+# Enabling this option causes the implementation of
+# the standard memset() routine to reduce code
+# size at the expense of execution speed. This
+# option is automatically enabled with the use of
+# the -Os option to the compiler. Also note that
+# the compiler will try to use its own builtin
+# version of memset() if possible, ignoring the
+# implementation in this package, unless given
+# the -fno-builtin compiler option.
+#
+cdl_option CYGIMP_INFRA_PREFER_SMALL_TO_FAST_MEMSET {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide empty C++ delete functions
+# To deal with virtual destructors, where the correct delete()
+# function must be called for the derived class in question, the
+# underlying delete is called when needed, from destructors.  This
+# is regardless of whether the destructor is called by delete itself.
+# So there is a reference to delete() from all destructors.  The
+# default builtin delete() attempts to call free() if there is
+# one defined.  So, if you have destructors, and you have free(),
+# as in malloc() and free(), any destructor counts as a reference
+# to free().  So the dynamic memory allocation code is linked
+# in regardless of whether it gets explicitly called. This
+# increases code and data size needlessly.
+# To defeat this undesirable behaviour, we define empty versions
+# of delete and delete.  But doing this prevents proper use
+# of dynamic memory in C++ programs via C++'s new and delete
+# operators.
+# Therefore, this option is provided
+# for explicitly disabling the provision of these empty functions,
+# so that new and delete can be used, if that is what is required.
+#
+cdl_option CYGFUN_INFRA_EMPTY_DELETE_FUNCTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Threshold for valid number of delete calls
+# Some users don't know about the empty delete function and then
+# wonder why their C++ classes are leaking memory. If
+# INFRA_DEBUG is enabled we keep a counter for the number of
+# times delete is called. If it goes above this threshold we throw
+# an assertion failure. This should point heavy users of
+# delete in the right direction without upsetting those who want
+# an empty delete function. 
+#
+cdl_option CYGNUM_INFRA_EMPTY_DELETE_THRESHOLD {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_INFRA_DEBUG
+    #     CYGPKG_INFRA_DEBUG == 0
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 100
+    # value_source default
+    # Default value: 100
+};
+
+# Provide dummy abort() function
+# This option controls the inclusion of a dummy abort() function.
+# Parts of the C and C++ compiler runtime systems contain references
+# to abort(), particulary in the C++ exception handling code. It is
+# not possible to eliminate these references, so this dummy function
+# in included to satisfy them. It is not expected that this function
+# will ever be called, so its current behaviour is to simply loop.
+#
+cdl_option CYGFUN_INFRA_DUMMY_ABORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGINT_ISO_EXIT == 0 
+    #     CYGINT_ISO_EXIT == 1
+    #   --> 0
+    # Requires: !CYGINT_ISO_EXIT
+    #     CYGINT_ISO_EXIT == 1
+    #   --> 0
+};
+
+# Reset platform at end of test case execution
+# If this option is set then test case programs will reset the platform
+# when they terminate, as opposed to the default which is to just hang
+# in a loop.
+#
+cdl_option CYGSEM_INFRA_RESET_ON_TEST_EXIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide dummy strlen() function
+# This option controls the inclusion of a dummy strlen() function.
+# Parts of the C and C++ compiler runtime systems contain references
+# to strlen(), particulary in the C++ exception handling code. It is
+# not possible to eliminate these references, so this dummy function
+# in included to satisfy them. While it is not expected that this function
+# will ever be called, it is functional but uses the simplest, smallest
+# algorithm. There is a faster version of strlen() in the C library.
+#
+cdl_option CYGFUN_INFRA_DUMMY_STRLEN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGINT_ISO_STRING_STRFUNCS == 0 
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 0
+    # Requires: !CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 0
+};
+
+# Make all compiler warnings show as errors
+# Enabling this option will cause all compiler warnings to show
+# as errors and bring the library build to a halt. This is used
+# to ensure that the code base is warning free, and thus ensure
+# that newly introduced warnings stand out and get fixed before
+# they show up as weird run-time behavior.
+#
+cdl_option CYGBLD_INFRA_CFLAGS_WARNINGS_AS_ERRORS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -Werror") 
+    #     CYGBLD_GLOBAL_CFLAGS == "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    #   --> 0
+};
+
+# Make compiler and assembler communicate by pipe
+# Enabling this option will cause the compiler to feed the
+# assembly output the the assembler via a pipe instead of
+# via a temporary file. This normally reduces the build
+# time.
+#
+cdl_option CYGBLD_INFRA_CFLAGS_PIPE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -pipe") 
+    #     CYGBLD_GLOBAL_CFLAGS == "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    #   --> 0
+};
+
+# Infra build options
+# Package specific build options including control over
+# compiler flags used only in building this package.
+#
+cdl_component CYGPKG_INFRA_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos infra package. These flags are used
+# in addition to the set of global flags.
+#
+cdl_option CYGPKG_INFRA_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos infra package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed linker flags
+# This option modifies the set of linker flags for
+# building the eCos infra package tests. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_LDFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wl,--gc-sections
+    # value_source default
+    # Default value: -Wl,--gc-sections
+};
+
+# Additional linker flags
+# This option modifies the set of linker flags for
+# building the eCos infra package tests. These flags are added to
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_LDFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wl,--fatal-warnings
+    # value_source default
+    # Default value: -Wl,--fatal-warnings
+};
+
+# Infra package tests
+#
+cdl_component CYGPKG_INFRA_TESTS {
+    # Calculated value:  "tests/cxxsupp tests/diag_sprintf1 tests/diag_sprintf2" 
+    # Flavor: data
+    # Current_value: tests/cxxsupp tests/diag_sprintf1 tests/diag_sprintf2
+};
+
+# >
+# Number of times a test runs
+# This option controls the number of times tests will execute their
+# basic function.  Not all tests will honor this setting, but those
+# that do will execute the test N times before terminating.  A value
+# less than 0 indicates to run forever.
+#
+cdl_option CYGNUM_TESTS_RUN_COUNT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# <
+# <
+# ISO C and POSIX infrastructure
+# eCos supports implementations of ISO C libraries and POSIX
+# implementations. This package provides infrastructure used by
+# all such implementations.
+#
+cdl_package CYGPKG_ISOINFRA {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     Requires: CYGPKG_ISOINFRA
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA && 0 != CYGPKG_IO_FILEIO &&  0 != CYGINT_ISO_ERRNO_CODES &&  0 != CYGINT_ISO_ERRNO 
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY
+    #     Requires: CYGPKG_ISOINFRA
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA 
+    # component CYGPKG_MEMALLOC_MALLOC_ALLOCATORS
+    #     ActiveIf: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_TIME
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_STDLIB
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_STRING
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_I18N
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_SETJMP
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_STARTUP
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_POSIX
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_IO_FILEIO
+    #     Requires: CYGPKG_ISOINFRA
+};
+
+# >
+# Startup and termination
+#
+cdl_component CYGPKG_ISO_STARTUP {
+    # There is no associated value.
+};
+
+# >
+# main() startup implementations
+# Implementations of this interface arrange for a user-supplied
+# main() to be called in an ISO compatible environment.
+#
+cdl_interface CYGINT_ISO_MAIN_STARTUP {
+    # Implemented by CYGPKG_LIBC_STARTUP, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MAIN_STARTUP 
+    #     CYGINT_ISO_MAIN_STARTUP == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MAIN_STARTUP
+    #     Requires:  1 >= CYGINT_ISO_MAIN_STARTUP 
+};
+
+# environ implementations
+# Implementations of this interface provide the environ
+# variable required by POSIX.
+#
+cdl_interface CYGINT_ISO_ENVIRON {
+    # Implemented by CYGPKG_LIBC_STARTUP, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_ENVIRON 
+    #     CYGINT_ISO_ENVIRON == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ENVIRON
+    #     Requires:  1 >= CYGINT_ISO_ENVIRON 
+};
+
+# <
+# ctype.h functions
+#
+cdl_component CYGPKG_ISO_CTYPE_H {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of ctype functions
+#
+cdl_interface CYGINT_ISO_CTYPE {
+    # Implemented by CYGPKG_LIBC_I18N, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_CTYPE 
+    #     CYGINT_ISO_CTYPE == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_CTYPE
+    #     Requires:  1 >= CYGINT_ISO_CTYPE 
+    # package CYGPKG_LIBC_STDLIB
+    #     Requires: CYGINT_ISO_CTYPE
+    # option CYGFUN_LIBC_STRING_BSD_FUNCS
+    #     Requires: CYGINT_ISO_CTYPE
+};
+
+# Ctype implementation header
+#
+cdl_option CYGBLD_ISO_CTYPE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/i18n/ctype.inl>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_LIBC_I18N_NEWLIB_CTYPE
+    #     Requires:  CYGBLD_ISO_CTYPE_HEADER ==  "<cyg/libc/i18n/newlibctype.h>" 
+    # option CYGIMP_LIBC_I18N_CTYPE_INLINES
+    #     Requires:  CYGBLD_ISO_CTYPE_HEADER ==  "<cyg/libc/i18n/ctype.inl>" 
+};
+
+# <
+# Error handling
+#
+cdl_component CYGPKG_ISO_ERRNO {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of error codes
+#
+cdl_interface CYGINT_ISO_ERRNO_CODES {
+    # Implemented by CYGPKG_ERROR, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_ERRNO_CODES 
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ERRNO_CODES
+    #     Requires:  1 >= CYGINT_ISO_ERRNO_CODES 
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     Requires: CYGINT_ISO_ERRNO_CODES
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA && 0 != CYGPKG_IO_FILEIO &&  0 != CYGINT_ISO_ERRNO_CODES &&  0 != CYGINT_ISO_ERRNO 
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_ERRNO_CODES
+    # package CYGPKG_POSIX
+    #     Requires: CYGINT_ISO_ERRNO_CODES
+    # package CYGPKG_IO_FILEIO
+    #     Requires: CYGINT_ISO_ERRNO_CODES
+};
+
+# Error codes implementation header
+#
+cdl_option CYGBLD_ISO_ERRNO_CODES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/error/codes.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_ERROR
+    #     Requires:  CYGBLD_ISO_ERRNO_CODES_HEADER == "<cyg/error/codes.h>" 
+};
+
+# Number of implementations of errno variable
+#
+cdl_interface CYGINT_ISO_ERRNO {
+    # Implemented by CYGPKG_ERROR_ERRNO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_ERRNO 
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ERRNO
+    #     Requires:  1 >= CYGINT_ISO_ERRNO 
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     Requires: CYGINT_ISO_ERRNO
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA && 0 != CYGPKG_IO_FILEIO &&  0 != CYGINT_ISO_ERRNO_CODES &&  0 != CYGINT_ISO_ERRNO 
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_ERRNO
+    # package CYGPKG_POSIX
+    #     Requires: CYGINT_ISO_ERRNO
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGINT_ISO_ERRNO
+    # package CYGPKG_IO_FILEIO
+    #     Requires: CYGINT_ISO_ERRNO
+};
+
+# errno variable implementation header
+#
+cdl_option CYGBLD_ISO_ERRNO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/error/errno.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_ERROR_ERRNO
+    #     Requires:  CYGBLD_ISO_ERRNO_HEADER == "<cyg/error/errno.h>" 
+};
+
+# <
+# Locale-related functions
+#
+cdl_component CYGPKG_ISO_LOCALE {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of locale functions
+#
+cdl_interface CYGINT_ISO_LOCALE {
+    # Implemented by CYGPKG_LIBC_I18N, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_LOCALE 
+    #     CYGINT_ISO_LOCALE == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_LOCALE
+    #     Requires:  1 >= CYGINT_ISO_LOCALE 
+};
+
+# Locale implementation header
+#
+cdl_option CYGBLD_ISO_LOCALE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Standard I/O-related functionality
+#
+cdl_component CYGPKG_ISO_STDIO {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of stdio file types
+#
+cdl_interface CYGINT_ISO_STDIO_FILETYPES {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILETYPES 
+    #     CYGINT_ISO_STDIO_FILETYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILETYPES
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILETYPES 
+};
+
+# Stdio file types implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FILETYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_FILETYPES_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Stdio standard streams implementations
+#
+cdl_interface CYGINT_ISO_STDIO_STREAMS {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_STREAMS 
+    #     CYGINT_ISO_STDIO_STREAMS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_STREAMS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_STREAMS 
+};
+
+# Stdio standard streams implementation header
+# This header file must define stdin, stdout
+# and stderr.
+#
+cdl_option CYGBLD_ISO_STDIO_STREAMS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_STREAMS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio file operations
+#
+cdl_interface CYGINT_ISO_STDIO_FILEOPS {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEOPS 
+    #     CYGINT_ISO_STDIO_FILEOPS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEOPS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEOPS 
+};
+
+# Stdio file operations implementation header
+# This header controls the file system operations on a file
+# such as remove(), rename(), tmpfile(), tmpnam() and associated
+# constants.
+#
+cdl_option CYGBLD_ISO_STDIO_FILEOPS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_FILEOPS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio file access  functionals
+#
+cdl_interface CYGINT_ISO_STDIO_FILEACCESS {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEACCESS 
+    #     CYGINT_ISO_STDIO_FILEACCESS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEACCESS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEACCESS 
+    # option CYGSEM_LIBC_EXIT_CALLS_FFLUSH
+    #     Requires: CYGINT_ISO_STDIO_FILEACCESS
+    # option CYGSEM_LIBC_EXIT_CALLS_FFLUSH
+    #     DefaultValue:  0 != CYGINT_ISO_STDIO_FILEACCESS 
+};
+
+# Stdio file access implementation header
+# This header controls the file access operations
+# such as fclose(), fflush(), fopen(), freopen(), setbuf(),
+# setvbuf(), and associated constants.
+#
+cdl_option CYGBLD_ISO_STDIO_FILEACCESS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_FILEACCESS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio formatted I/O
+#
+cdl_interface CYGINT_ISO_STDIO_FORMATTED_IO {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_FORMATTED_IO 
+    #     CYGINT_ISO_STDIO_FORMATTED_IO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FORMATTED_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FORMATTED_IO 
+};
+
+# Stdio formatted I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FORMATTED_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_FORMATTED_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio character I/O
+#
+cdl_interface CYGINT_ISO_STDIO_CHAR_IO {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_CHAR_IO 
+    #     CYGINT_ISO_STDIO_CHAR_IO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_CHAR_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_CHAR_IO 
+};
+
+# Stdio character I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_CHAR_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_CHAR_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio direct I/O
+#
+cdl_interface CYGINT_ISO_STDIO_DIRECT_IO {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_DIRECT_IO 
+    #     CYGINT_ISO_STDIO_DIRECT_IO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_DIRECT_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_DIRECT_IO 
+};
+
+# Stdio direct I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_DIRECT_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_DIRECT_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio file positioning
+#
+cdl_interface CYGINT_ISO_STDIO_FILEPOS {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEPOS 
+    #     CYGINT_ISO_STDIO_FILEPOS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEPOS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEPOS 
+};
+
+# Stdio file positioning implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FILEPOS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_FILEPOS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# Number of implementations of stdio error handling
+#
+cdl_interface CYGINT_ISO_STDIO_ERROR {
+    # Implemented by CYGPKG_LIBC_STDIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STDIO_ERROR 
+    #     CYGINT_ISO_STDIO_ERROR == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_ERROR
+    #     Requires:  1 >= CYGINT_ISO_STDIO_ERROR 
+};
+
+# Stdio error handling implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_ERROR_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdio/stdio.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  CYGBLD_ISO_STDIO_ERROR_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+};
+
+# POSIX fd-related function implementations
+#
+cdl_interface CYGINT_ISO_STDIO_POSIX_FDFUNCS {
+    # Implemented by CYGFUN_LIBC_STDIO_OPEN_POSIX_FDFUNCS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >=  CYGINT_ISO_STDIO_POSIX_FDFUNCS 
+    #     CYGINT_ISO_STDIO_POSIX_FDFUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_POSIX_FDFUNCS
+    #     Requires:  1 >=  CYGINT_ISO_STDIO_POSIX_FDFUNCS 
+};
+
+# POSIX fd-related function implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_POSIX_FDFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Standard general utility functions
+#
+cdl_component CYGPKG_ISO_STDLIB {
+    # There is no associated value.
+};
+
+# >
+# String conversion function implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_STRCONV {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV 
+    #     CYGINT_ISO_STDLIB_STRCONV == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_STRCONV
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV 
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_STDLIB_STRCONV
+};
+
+# String conversion function implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_STRCONV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdlib/atox.inl>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGIMP_LIBC_STDLIB_INLINE_ATOX
+    #     Requires:  CYGBLD_ISO_STDLIB_STRCONV_HEADER ==  "<cyg/libc/stdlib/atox.inl>" 
+};
+
+# String to FP conversion function implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_STRCONV_FLOAT {
+    # Implemented by CYGFUN_LIBC_strtod, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+    #     CYGINT_ISO_STDLIB_STRCONV_FLOAT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_STRCONV_FLOAT
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+    # option CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
+    #     Requires: CYGINT_ISO_STDLIB_STRCONV_FLOAT
+    # option CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
+    #     DefaultValue:  0 != CYGPKG_LIBM &&
+    #                                 0 != CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+};
+
+# String to FP conversion function implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_STRCONV_FLOAT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Random number generator implementations
+#
+cdl_interface CYGINT_ISO_RAND {
+    # Implemented by CYGIMP_LIBC_RAND_SIMPLEST, active, disabled
+    # Implemented by CYGIMP_LIBC_RAND_SIMPLE1, active, enabled
+    # Implemented by CYGIMP_LIBC_RAND_KNUTH1, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_RAND 
+    #     CYGINT_ISO_RAND == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_RAND
+    #     Requires:  1 >= CYGINT_ISO_RAND 
+};
+
+# Random number generator implementation header
+#
+cdl_option CYGBLD_ISO_RAND_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Malloc implementations
+#
+cdl_interface CYGINT_ISO_MALLOC {
+    # Implemented by CYGPKG_MEMALLOC_MALLOC_ALLOCATORS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MALLOC 
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MALLOC
+    #     Requires:  1 >= CYGINT_ISO_MALLOC 
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     Requires: CYGINT_ISO_MALLOC
+    # option CYGFUN_LIBC_STRING_STRDUP
+    #     ActiveIf: CYGINT_ISO_MALLOC
+    # option CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
+    #     Requires: CYGINT_ISO_MALLOC
+    # option CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
+    #     DefaultValue:  0 != CYGINT_ISO_MALLOC 
+    # component CYGPKG_LIBC_STDIO_OPEN
+    #     Requires: CYGINT_ISO_MALLOC
+    # component CYGPKG_LIBC_STDIO_OPEN
+    #     DefaultValue:  0 != CYGINT_ISO_MALLOC 
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGINT_ISO_MALLOC
+    # component CYGPKG_IO_FILEIO_INODE
+    #     Requires: CYGINT_ISO_MALLOC
+};
+
+# Malloc implementation header
+#
+cdl_option CYGBLD_ISO_MALLOC_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Mallinfo() implementations
+#
+cdl_interface CYGINT_ISO_MALLINFO {
+    # Implemented by CYGPKG_MEMALLOC_MALLOC_ALLOCATORS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MALLINFO 
+    #     CYGINT_ISO_MALLINFO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MALLINFO
+    #     Requires:  1 >= CYGINT_ISO_MALLINFO 
+};
+
+# Mallinfo() implementation header
+#
+cdl_option CYGBLD_ISO_MALLINFO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Program exit functionality implementations
+#
+cdl_interface CYGINT_ISO_EXIT {
+    # Implemented by CYGPKG_LIBC_STARTUP, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_EXIT 
+    #     CYGINT_ISO_EXIT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_EXIT
+    #     Requires:  1 >= CYGINT_ISO_EXIT 
+    # option CYGFUN_INFRA_DUMMY_ABORT
+    #     Requires: !CYGINT_ISO_EXIT
+    # option CYGFUN_INFRA_DUMMY_ABORT
+    #     DefaultValue:  CYGINT_ISO_EXIT == 0 
+};
+
+# Program exit functionality implementation header
+#
+cdl_option CYGBLD_ISO_EXIT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Program environment implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_ENVIRON {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_ENVIRON 
+    #     CYGINT_ISO_STDLIB_ENVIRON == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_ENVIRON
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_ENVIRON 
+};
+
+# Program environment implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_ENVIRON_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# system() implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_SYSTEM {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_SYSTEM 
+    #     CYGINT_ISO_STDLIB_SYSTEM == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_SYSTEM
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_SYSTEM 
+};
+
+# system() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_SYSTEM_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# bsearch() implementations
+#
+cdl_interface CYGINT_ISO_BSEARCH {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_BSEARCH 
+    #     CYGINT_ISO_BSEARCH == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_BSEARCH
+    #     Requires:  1 >= CYGINT_ISO_BSEARCH 
+};
+
+# bsearch() implementation header
+#
+cdl_option CYGBLD_ISO_BSEARCH_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# qsort() implementations
+#
+cdl_interface CYGINT_ISO_QSORT {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_QSORT 
+    #     CYGINT_ISO_STDLIB_QSORT (unknown) == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+};
+
+# qsort() implementation header
+#
+cdl_option CYGBLD_ISO_QSORT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# abs()/labs() implementations
+#
+cdl_interface CYGINT_ISO_ABS {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_ABS 
+    #     CYGINT_ISO_STDLIB_ABS (unknown) == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_TIME
+    #     Requires: CYGINT_ISO_ABS
+};
+
+# abs()/labs() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_ABS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdlib/abs.inl>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGIMP_LIBC_STDLIB_INLINE_ABS
+    #     Requires:  CYGBLD_ISO_STDLIB_ABS_HEADER ==  "<cyg/libc/stdlib/abs.inl>" 
+};
+
+# div()/ldiv() implementations
+#
+cdl_interface CYGINT_ISO_DIV {
+    # Implemented by CYGPKG_LIBC_STDLIB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_DIV 
+    #     CYGINT_ISO_STDLIB_DIV (unknown) == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_TIME
+    #     Requires: CYGINT_ISO_DIV
+};
+
+# div()/ldiv() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_DIV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/stdlib/div.inl>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGIMP_LIBC_STDLIB_INLINE_DIV
+    #     Requires:  CYGBLD_ISO_STDLIB_DIV_HEADER ==  "<cyg/libc/stdlib/div.inl>" 
+};
+
+# Header defining the implementation's MB_CUR_MAX
+#
+cdl_option CYGBLD_ISO_STDLIB_MB_CUR_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # interface CYGINT_LIBC_I18N_MB_REQUIRED
+    #     Requires:  CYGBLD_ISO_STDLIB_MB_CUR_MAX_HEADER ==  "<cyg/libc/i18n/mb.h>" 
+};
+
+# Multibyte character implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_MULTIBYTE {
+    # Implemented by CYGPKG_LIBC_I18N, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_STDLIB_MULTIBYTE 
+    #     CYGINT_ISO_STDLIB_MULTIBYTE == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_MULTIBYTE
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_MULTIBYTE 
+};
+
+# Multibyte character implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_MULTIBYTE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# String functions
+#
+cdl_component CYGPKG_ISO_STRING {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of strerror() function
+#
+cdl_interface CYGINT_ISO_STRERROR {
+    # Implemented by CYGPKG_ERROR_STRERROR, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRERROR 
+    #     CYGINT_ISO_STRERROR == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRERROR
+    #     Requires:  1 >= CYGINT_ISO_STRERROR 
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_STRERROR
+};
+
+# strerror() implementation header
+#
+cdl_option CYGBLD_ISO_STRERROR_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/error/strerror.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_ERROR_STRERROR
+    #     Requires:  CYGBLD_ISO_STRERROR_HEADER == "<cyg/error/strerror.h>" 
+};
+
+# memcpy() implementation header
+#
+cdl_option CYGBLD_ISO_MEMCPY_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# memset() implementation header
+#
+cdl_option CYGBLD_ISO_MEMSET_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of strtok_r() function
+#
+cdl_interface CYGINT_ISO_STRTOK_R {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRTOK_R 
+    #     CYGINT_ISO_STRTOK_R == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRTOK_R
+    #     Requires:  1 >= CYGINT_ISO_STRTOK_R 
+};
+
+# strtok_r() implementation header
+#
+cdl_option CYGBLD_ISO_STRTOK_R_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRTOK_R_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of locale-specific string  functions
+# This covers locale-dependent string functions such as strcoll()
+# and strxfrm().
+#
+cdl_interface CYGINT_ISO_STRING_LOCALE_FUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_LOCALE_FUNCS 
+    #     CYGINT_ISO_STRING_LOCALE_FUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_LOCALE_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_LOCALE_FUNCS 
+};
+
+# Locale-specific string functions' implementation  header
+# This covers locale-dependent string functions such as strcoll()
+# and strxfrm().
+#
+cdl_option CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of BSD string functions
+#
+cdl_interface CYGINT_ISO_STRING_BSD_FUNCS {
+    # Implemented by CYGFUN_LIBC_STRING_BSD_FUNCS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_BSD_FUNCS 
+    #     CYGINT_ISO_STRING_BSD_FUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_BSD_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_BSD_FUNCS 
+    # option CYGFUN_LIBC_TIME_POSIX
+    #     Requires: CYGINT_ISO_STRING_BSD_FUNCS
+};
+
+# BSD string functions' implementation header
+#
+cdl_option CYGBLD_ISO_STRING_BSD_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/bsdstring.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGFUN_LIBC_STRING_BSD_FUNCS
+    #     Requires:  CYGBLD_ISO_STRING_BSD_FUNCS_HEADER ==  "<cyg/libc/string/bsdstring.h>" 
+};
+
+# Number of implementations of other mem*() functions
+#
+cdl_interface CYGINT_ISO_STRING_MEMFUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_MEMFUNCS 
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_MEMFUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_MEMFUNCS 
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_STRING_MEMFUNCS
+    # component CYGPKG_IO_ETH_DRIVERS_STAND_ALONE
+    #     Requires: CYGINT_ISO_STRING_MEMFUNCS
+};
+
+# Other mem*() functions' implementation header
+#
+cdl_option CYGBLD_ISO_STRING_MEMFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_MEMFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of other ISO C str*()  functions
+# This covers the other str*() functions defined by ISO C.
+#
+cdl_interface CYGINT_ISO_STRING_STRFUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_STRFUNCS 
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_STRFUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_STRFUNCS 
+    # option CYGFUN_INFRA_DUMMY_STRLEN
+    #     Requires: !CYGINT_ISO_STRING_STRFUNCS
+    # option CYGFUN_INFRA_DUMMY_STRLEN
+    #     DefaultValue:  CYGINT_ISO_STRING_STRFUNCS == 0 
+    # package CYGPKG_LIBC_STDLIB
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # package CYGPKG_IO_FILEIO
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # component CYGPKG_IO_ETH_DRIVERS_NET
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+};
+
+# Other ISO C str*() functions' implementation  header
+# This covers the other str*() functions defined by ISO C.
+#
+cdl_option CYGBLD_ISO_STRING_STRFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_STRFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# <
+# Clock and time functionality
+#
+cdl_component CYGPKG_ISO_TIME {
+    # There is no associated value.
+};
+
+# >
+# time_t implementation header
+#
+cdl_option CYGBLD_ISO_TIME_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# clock_t implementation header
+#
+cdl_option CYGBLD_ISO_CLOCK_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# struct timeval implementation header
+#
+cdl_option CYGBLD_ISO_STRUCTTIMEVAL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/sys/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_CLOCKS
+    #     Requires:  CYGBLD_ISO_STRUCTTIMEVAL_HEADER ==  "<cyg/posix/sys/time.h>" 
+};
+
+# Number of implementations of POSIX timer types
+#
+cdl_interface CYGINT_ISO_POSIX_TIMER_TYPES {
+    # Implemented by CYGPKG_POSIX_TIMERS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMER_TYPES 
+    #     CYGINT_ISO_POSIX_TIMER_TYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMER_TYPES
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMER_TYPES 
+};
+
+# POSIX timer types implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMER_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires:  CYGBLD_ISO_POSIX_TIMER_TYPES_HEADER ==  "<cyg/posix/time.h>" 
+};
+
+# Number of implementations of POSIX clock types
+#
+cdl_interface CYGINT_ISO_POSIX_CLOCK_TYPES {
+    # Implemented by CYGPKG_POSIX_CLOCKS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_CLOCK_TYPES 
+    #     CYGINT_ISO_POSIX_CLOCK_TYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_CLOCK_TYPES
+    #     Requires:  1 >= CYGINT_ISO_POSIX_CLOCK_TYPES 
+};
+
+# POSIX clock types implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_CLOCK_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_CLOCKS
+    #     Requires:  CYGBLD_ISO_POSIX_CLOCK_TYPES_HEADER ==  "<cyg/posix/time.h>" 
+};
+
+# Number of implementations of ISO C types
+#
+cdl_interface CYGINT_ISO_C_TIME_TYPES {
+    # Implemented by CYGPKG_LIBC_TIME, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_C_TIME_TYPES 
+    #     CYGINT_ISO_C_TIME_TYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_C_TIME_TYPES
+    #     Requires:  1 >= CYGINT_ISO_C_TIME_TYPES 
+};
+
+# ISO C time types implementation header
+#
+cdl_option CYGBLD_ISO_C_TIME_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/time/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_TIME
+    #     Requires:  CYGBLD_ISO_C_TIME_TYPES_HEADER == "<cyg/libc/time/time.h>" 
+};
+
+# Number of implementations of POSIX timers
+#
+cdl_interface CYGINT_ISO_POSIX_TIMERS {
+    # Implemented by CYGPKG_POSIX_TIMERS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMERS 
+    #     CYGINT_ISO_POSIX_TIMERS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMERS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMERS 
+};
+
+# POSIX timer implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMERS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires:  CYGBLD_ISO_POSIX_TIMERS_HEADER ==  "<cyg/posix/time.h>" 
+};
+
+# Number of implementations of POSIX clocks
+#
+cdl_interface CYGINT_ISO_POSIX_CLOCKS {
+    # Implemented by CYGPKG_POSIX_CLOCKS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_CLOCKS 
+    #     CYGINT_ISO_POSIX_CLOCKS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_CLOCKS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_CLOCKS 
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires: CYGINT_ISO_POSIX_CLOCKS
+};
+
+# POSIX clocks implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_CLOCKS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_CLOCKS
+    #     Requires:  CYGBLD_ISO_POSIX_CLOCKS_HEADER ==  "<cyg/posix/time.h>" 
+};
+
+# Number of implementations of ISO C clock functions
+#
+cdl_interface CYGINT_ISO_C_CLOCK_FUNCS {
+    # Implemented by CYGPKG_LIBC_TIME, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_C_CLOCK_FUNCS 
+    #     CYGINT_ISO_C_CLOCK_FUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_C_CLOCK_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_C_CLOCK_FUNCS 
+};
+
+# ISO C clock functions' implementation header
+#
+cdl_option CYGBLD_ISO_C_CLOCK_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/time/time.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_TIME
+    #     Requires:  CYGBLD_ISO_C_CLOCK_FUNCS_HEADER ==  "<cyg/libc/time/time.h>" 
+};
+
+# Number of implementations of tzset() function
+#
+cdl_interface CYGINT_ISO_TZSET {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_TZSET 
+    #     CYGINT_ISO_TZSET == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_TZSET
+    #     Requires:  1 >= CYGINT_ISO_TZSET 
+};
+
+# tzset() implementation header
+#
+cdl_option CYGBLD_ISO_TZSET_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Signal functionality
+#
+cdl_component CYGPKG_ISO_SIGNAL {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of signal numbers
+#
+cdl_interface CYGINT_ISO_SIGNAL_NUMBERS {
+    # Implemented by CYGPKG_POSIX_SIGNALS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SIGNAL_NUMBERS 
+    #     CYGINT_ISO_SIGNAL_NUMBERS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGNAL_NUMBERS
+    #     Requires:  1 >= CYGINT_ISO_SIGNAL_NUMBERS 
+    # option CYGSEM_IO_SERIAL_TERMIOS_USE_SIGNALS
+    #     Requires: CYGINT_ISO_SIGNAL_NUMBERS
+    # option CYGSEM_IO_SERIAL_TERMIOS_USE_SIGNALS
+    #     DefaultValue:  CYGINT_ISO_SIGNAL_NUMBERS != 0 &&  CYGINT_ISO_SIGNAL_IMPL != 0 
+};
+
+# Signal numbering implementation header
+# This header provides the mapping of signal
+# names (e.g. SIGBUS) to numbers.
+#
+cdl_option CYGBLD_ISO_SIGNAL_NUMBERS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/signal.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires:  CYGBLD_ISO_SIGNAL_NUMBERS_HEADER ==  "<cyg/posix/signal.h>" 
+};
+
+# Number of signal implementations
+#
+cdl_interface CYGINT_ISO_SIGNAL_IMPL {
+    # Implemented by CYGPKG_POSIX_SIGNALS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SIGNAL_IMPL 
+    #     CYGINT_ISO_SIGNAL_IMPL == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGNAL_IMPL
+    #     Requires:  1 >= CYGINT_ISO_SIGNAL_IMPL 
+    # option CYGSEM_IO_SERIAL_TERMIOS_USE_SIGNALS
+    #     Requires: CYGINT_ISO_SIGNAL_IMPL
+    # option CYGSEM_IO_SERIAL_TERMIOS_USE_SIGNALS
+    #     DefaultValue:  CYGINT_ISO_SIGNAL_NUMBERS != 0 &&  CYGINT_ISO_SIGNAL_IMPL != 0 
+};
+
+# Signals implementation header
+#
+cdl_option CYGBLD_ISO_SIGNAL_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/signal.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires:  CYGBLD_ISO_SIGNAL_IMPL_HEADER ==  "<cyg/posix/signal.h>" 
+};
+
+# POSIX real time signals feature test macro
+# This defines the POSIX feature test macro
+# that indicates that the POSIX real time signals
+# are present.
+#
+cdl_interface CYGINT_POSIX_REALTIME_SIGNALS {
+    # Implemented by CYGPKG_POSIX_SIGNALS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_POSIX_REALTIME_SIGNALS 
+    #     CYGINT_POSIX_REALTIME_SIGNALS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_POSIX_REALTIME_SIGNALS
+    #     Requires:  1 >= CYGINT_POSIX_REALTIME_SIGNALS 
+};
+
+# <
+# Non-local jumps functionality
+#
+cdl_component CYGPKG_ISO_SETJMP {
+    # There is no associated value.
+};
+
+# >
+# setjmp() / longjmp() implementations
+#
+cdl_interface CYGINT_ISO_SETJMP {
+    # Implemented by CYGPKG_LIBC_SETJMP, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SETJMP 
+    #     CYGINT_ISO_SETJMP == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SETJMP
+    #     Requires:  1 >= CYGINT_ISO_SETJMP 
+};
+
+# setjmp() / longjmp() implementation header
+#
+cdl_option CYGBLD_ISO_SETJMP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/setjmp/setjmp.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_SETJMP
+    #     Requires:  CYGBLD_ISO_SETJMP_HEADER == "<cyg/libc/setjmp/setjmp.h>" 
+};
+
+# sigsetjmp() / siglongjmp() implementations
+#
+cdl_interface CYGINT_ISO_SIGSETJMP {
+    # Implemented by CYGPKG_POSIX_SIGNALS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SIGSETJMP 
+    #     CYGINT_ISO_SIGSETJMP == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGSETJMP
+    #     Requires:  1 >= CYGINT_ISO_SIGSETJMP 
+};
+
+# sigsetjmp() / siglongjmp() implementation header
+#
+cdl_option CYGBLD_ISO_SIGSETJMP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/sigsetjmp.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires:  CYGBLD_ISO_SIGSETJMP_HEADER ==  "<cyg/posix/sigsetjmp.h>" 
+};
+
+# <
+# Assertions implementation header
+#
+cdl_option CYGBLD_ISO_ASSERT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX file control
+# This covers the POSIX file control definitions,
+# normally found in <fcntl.h>
+#
+cdl_component CYGPKG_ISO_POSIX_FCNTL {
+    # There is no associated value.
+};
+
+# >
+# POSIX open flags implementation header
+#
+cdl_option CYGBLD_ISO_OFLAG_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX fcntl() implementations
+#
+cdl_interface CYGINT_ISO_FCNTL {
+    # Implemented by CYGPKG_IO_FILEIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_FCNTL 
+    #     CYGINT_ISO_FCNTL == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_FCNTL
+    #     Requires:  1 >= CYGINT_ISO_FCNTL 
+};
+
+# POSIX fcntl() implementation header
+#
+cdl_option CYGBLD_ISO_FCNTL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX file open implementations
+#
+cdl_interface CYGINT_ISO_OPEN {
+    # Implemented by CYGPKG_IO_FILEIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_OPEN 
+    #     CYGINT_ISO_OPEN == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_OPEN
+    #     Requires:  1 >= CYGINT_ISO_OPEN 
+};
+
+# POSIX file open implementation header
+#
+cdl_option CYGBLD_ISO_OPEN_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# <sys/stat.h> definitions implementation header
+#
+cdl_option CYGBLD_ISO_STAT_DEFS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX directory reading implementation
+#
+cdl_interface CYGINT_ISO_DIRENT {
+    # Implemented by CYGPKG_IO_FILEIO, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_DIRENT 
+    #     CYGINT_ISO_DIRENT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DIRENT
+    #     Requires:  1 >= CYGINT_ISO_DIRENT 
+};
+
+# <dirent.h> definitions implementation header
+#
+cdl_option CYGBLD_ISO_DIRENT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/fileio/dirent.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_FILEIO
+    #     Requires:  CYGBLD_ISO_DIRENT_HEADER == "<cyg/fileio/dirent.h>" 
+};
+
+# POSIX <sys/types.h> contents
+# This covers the types required by POSIX to be in
+# <sys/types.h>
+#
+cdl_component CYGPKG_ISO_POSIX_TYPES {
+    # There is no associated value.
+};
+
+# >
+# POSIX thread types implementations
+#
+cdl_interface CYGINT_ISO_PTHREADTYPES {
+    # Implemented by CYGPKG_POSIX_PTHREAD_REQUIREMENTS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    #     CYGINT_ISO_PTHREADTYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREADTYPES
+    #     Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    # interface CYGINT_ISO_PMUTEXTYPES
+    #     Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+};
+
+# POSIX thread types implementation header
+#
+cdl_option CYGBLD_ISO_PTHREADTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/types.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires:  CYGBLD_ISO_PTHREADTYPES_HEADER ==  "<cyg/posix/types.h>" 
+};
+
+# POSIX mutex types implementations
+#
+cdl_interface CYGINT_ISO_PMUTEXTYPES {
+    # Implemented by CYGPKG_POSIX_PTHREAD_MUTEX, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    #     CYGINT_ISO_PTHREADTYPES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+};
+
+# POSIX mutex types implementation header
+#
+cdl_option CYGBLD_ISO_PMUTEXTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/muttypes.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_POSIX
+    #     Requires:  CYGBLD_ISO_PMUTEXTYPES_HEADER ==  "<cyg/posix/muttypes.h>" 
+};
+
+# ssize_t implementation header
+#
+cdl_option CYGBLD_ISO_SSIZE_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Filesystem types implementation header
+#
+cdl_option CYGBLD_ISO_FSTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# gid_t, pid_t, uid_t implementation header
+#
+cdl_option CYGBLD_ISO_SCHEDTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Non-POSIX <sys/types.h> contents
+# This covers the extra types required by non-POSIX
+# packages to be in <sys/types.h>. These would normally
+# only be visible if _POSIX_SOURCE is not defined.
+#
+cdl_component CYGPKG_ISO_EXTRA_TYPES {
+    # There is no associated value.
+};
+
+# >
+# BSD compatible types
+#
+cdl_interface CYGINT_ISO_BSDTYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_BSDTYPES 
+    #     CYGINT_ISO_BSDTYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_BSDTYPES
+    #     Requires:  1 >= CYGINT_ISO_BSDTYPES 
+};
+
+# BSD types header
+#
+cdl_option CYGBLD_ISO_BSDTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <sys/bsdtypes.h>
+    # value_source inferred
+    # Default value: 0 0
+};
+
+# <
+# Utsname structure
+#
+cdl_component CYGPKG_ISO_UTSNAME {
+    # There is no associated value.
+};
+
+# >
+# Utsname header
+#
+cdl_option CYGBLD_ISO_UTSNAME_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/utsname.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_UTSNAME
+    #     Requires:  CYGBLD_ISO_UTSNAME_HEADER ==  "<cyg/posix/utsname.h>" 
+};
+
+# <
+# POSIX scheduler
+#
+cdl_component CYGPKG_ISO_SCHED {
+    # There is no associated value.
+};
+
+# >
+# POSIX scheduler implementations
+#
+cdl_interface CYGINT_ISO_SCHED_IMPL {
+    # Implemented by CYGPKG_POSIX_SCHED, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SCHED_IMPL 
+    #     CYGINT_ISO_SCHED_IMPL == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SCHED_IMPL
+    #     Requires:  1 >= CYGINT_ISO_SCHED_IMPL 
+};
+
+# POSIX scheduler implementation header
+#
+cdl_option CYGBLD_ISO_SCHED_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX semaphores
+#
+cdl_component CYGPKG_ISO_SEMAPHORES {
+    # There is no associated value.
+};
+
+# >
+# POSIX semaphore implementations
+#
+cdl_interface CYGINT_ISO_SEMAPHORES {
+    # Implemented by CYGPKG_POSIX_SEMAPHORES, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_SEMAPHORES 
+    #     CYGINT_ISO_SEMAPHORES == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SEMAPHORES
+    #     Requires:  1 >= CYGINT_ISO_SEMAPHORES 
+};
+
+# POSIX semaphore implementation header
+#
+cdl_option CYGBLD_ISO_SEMAPHORES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/semaphore.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_SEMAPHORES
+    #     Requires:  CYGBLD_ISO_SEMAPHORES_HEADER ==  "<cyg/posix/semaphore.h>" 
+};
+
+# <
+# POSIX message queues
+#
+cdl_component CYGPKG_ISO_MQUEUE {
+    # There is no associated value.
+};
+
+# >
+# Implementations
+#
+cdl_interface CYGINT_ISO_MQUEUE {
+    # Implemented by CYGPKG_POSIX_MQUEUES, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MQUEUE 
+    #     CYGINT_ISO_MQUEUE == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MQUEUE
+    #     Requires:  1 >= CYGINT_ISO_MQUEUE 
+    # option CYGNUM_ISO_MQUEUE_OPEN_MAX
+    #     ActiveIf: CYGINT_ISO_MQUEUE
+    # option CYGNUM_ISO_MQUEUE_PRIO_MAX
+    #     ActiveIf: CYGINT_ISO_MQUEUE
+};
+
+# Implementation header
+#
+cdl_option CYGBLD_ISO_MQUEUE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Maximum number of open message queues
+#
+cdl_option CYGNUM_ISO_MQUEUE_OPEN_MAX {
+    # ActiveIf constraint: CYGINT_ISO_MQUEUE
+    #     CYGINT_ISO_MQUEUE == 1
+    #   --> 1
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 8
+    # value_source default
+    # Default value:  CYGNUM_POSIX_MQUEUE_OPEN_MAX > 0 ? CYGNUM_POSIX_MQUEUE_OPEN_MAX : 0 
+    #     CYGNUM_POSIX_MQUEUE_OPEN_MAX == 8
+    #     CYGNUM_POSIX_MQUEUE_OPEN_MAX == 8
+    #   --> 1 8
+};
+
+# Maximum number of message priorities
+#
+cdl_option CYGNUM_ISO_MQUEUE_PRIO_MAX {
+    # ActiveIf constraint: CYGINT_ISO_MQUEUE
+    #     CYGINT_ISO_MQUEUE == 1
+    #   --> 1
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 65535
+    # value_source default
+    # Default value: 1 65535
+};
+
+# <
+# POSIX threads
+#
+cdl_component CYGPKG_ISO_PTHREAD {
+    # There is no associated value.
+};
+
+# >
+# POSIX pthread implementations
+#
+cdl_interface CYGINT_ISO_PTHREAD_IMPL {
+    # Implemented by CYGPKG_POSIX_PTHREAD_REQUIREMENTS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_PTHREAD_IMPL 
+    #     CYGINT_ISO_PTHREAD_IMPL == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREAD_IMPL
+    #     Requires:  1 >= CYGINT_ISO_PTHREAD_IMPL 
+};
+
+# POSIX pthread implementation header
+#
+cdl_option CYGBLD_ISO_PTHREAD_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/pthread.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires:  CYGBLD_ISO_PTHREAD_IMPL_HEADER ==  "<cyg/posix/pthread.h>" 
+};
+
+# POSIX mutex/cond var implementations
+#
+cdl_interface CYGINT_ISO_PTHREAD_MUTEX {
+    # Implemented by CYGPKG_POSIX_PTHREAD_MUTEX, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_PTHREAD_MUTEX 
+    #     CYGINT_ISO_PTHREAD_MUTEX == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREAD_MUTEX
+    #     Requires:  1 >= CYGINT_ISO_PTHREAD_MUTEX 
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGINT_ISO_PTHREAD_MUTEX
+};
+
+# POSIX mutex/cond var implementation header
+#
+cdl_option CYGBLD_ISO_PTHREAD_MUTEX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/mutex.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_POSIX
+    #     Requires:  CYGBLD_ISO_PTHREAD_MUTEX_HEADER ==  "<cyg/posix/mutex.h>" 
+};
+
+# <
+# Limits
+#
+cdl_component CYGPKG_ISO_LIMITS {
+    # There is no associated value.
+};
+
+# >
+# POSIX pthread limits implementations
+#
+cdl_interface CYGINT_ISO_POSIX_LIMITS {
+    # Implemented by CYGPKG_POSIX, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_LIMITS 
+    #     CYGINT_ISO_POSIX_LIMITS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_LIMITS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_LIMITS 
+};
+
+# POSIX pthread limits implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_LIMITS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/posix/limits.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_POSIX
+    #     Requires:  CYGBLD_ISO_POSIX_LIMITS_HEADER ==  "<cyg/posix/limits.h>" 
+};
+
+# OPEN_MAX implementation header
+#
+cdl_option CYGBLD_ISO_OPEN_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/fileio/limits.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_FILEIO
+    #     Requires:  CYGBLD_ISO_OPEN_MAX_HEADER == "<cyg/fileio/limits.h>" 
+};
+
+# LINK_MAX implementation header
+#
+cdl_option CYGBLD_ISO_LINK_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# NAME_MAX implementation header
+#
+cdl_option CYGBLD_ISO_NAME_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/fileio/limits.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_FILEIO
+    #     Requires:  CYGBLD_ISO_NAME_MAX_HEADER == "<cyg/fileio/limits.h>" 
+};
+
+# PATH_MAX implementation header
+#
+cdl_option CYGBLD_ISO_PATH_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX termios
+#
+cdl_component CYGPKG_ISO_TERMIOS {
+    # There is no associated value.
+};
+
+# >
+# POSIX termios implementations
+#
+cdl_interface CYGINT_ISO_TERMIOS {
+    # Implemented by CYGPKG_IO_SERIAL_TERMIOS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_TERMIOS 
+    #     CYGINT_ISO_TERMIOS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_TERMIOS
+    #     Requires:  1 >= CYGINT_ISO_TERMIOS 
+};
+
+# POSIX termios implementation header
+#
+cdl_option CYGBLD_ISO_TERMIOS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Dynamic load API
+#
+cdl_component CYGPKG_ISO_DLFCN {
+    # There is no associated value.
+};
+
+# >
+# Dynamic load implementations
+#
+cdl_interface CYGINT_ISO_DLFCN {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_DLFCN 
+    #     CYGINT_ISO_DLFCN == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DLFCN
+    #     Requires:  1 >= CYGINT_ISO_DLFCN 
+};
+
+# Dynamic load implementation header
+#
+cdl_option CYGBLD_ISO_DLFCN_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# UNIX standard functions
+#
+cdl_component CYGPKG_ISO_UNISTD {
+    # There is no associated value.
+};
+
+# >
+# POSIX timer operations implementations
+#
+cdl_interface CYGINT_ISO_POSIX_TIMER_OPS {
+    # Implemented by CYGPKG_POSIX_TIMERS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMER_OPS 
+    #     CYGINT_ISO_POSIX_TIMER_OPS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMER_OPS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMER_OPS 
+};
+
+# POSIX timer operations implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMER_OPS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX sleep() implementations
+#
+cdl_interface CYGINT_ISO_POSIX_SLEEP {
+    # Implemented by CYGPKG_POSIX_CLOCKS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_POSIX_SLEEP 
+    #     CYGINT_ISO_POSIX_SLEEP == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_SLEEP
+    #     Requires:  1 >= CYGINT_ISO_POSIX_SLEEP 
+};
+
+# POSIX sleep() implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_SLEEP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# select()/poll() functions
+#
+cdl_component CYGPKG_ISO_SELECT {
+    # There is no associated value.
+};
+
+# >
+# select() implementations
+#
+cdl_interface CYGINT_ISO_SELECT {
+    # Implemented by CYGFUN_IO_FILEIO_SELECT, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_SELECT 
+    #     CYGINT_ISO_SELECT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SELECT
+    #     Requires:  1 >= CYGINT_ISO_SELECT 
+};
+
+# select() implementation header
+#
+cdl_option CYGBLD_ISO_SELECT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# poll() implementations
+#
+cdl_interface CYGINT_ISO_POLL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POLL 
+    #     CYGINT_ISO_POLL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POLL
+    #     Requires:  1 >= CYGINT_ISO_POLL 
+};
+
+# poll() implementation header
+#
+cdl_option CYGBLD_ISO_POLL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# NetDB utility functions
+#
+cdl_component CYGPKG_ISO_NETDB {
+    # There is no associated value.
+};
+
+# >
+# DNS implementations
+#
+cdl_interface CYGINT_ISO_DNS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_DNS 
+    #     CYGINT_ISO_DNS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DNS
+    #     Requires:  1 >= CYGINT_ISO_DNS 
+};
+
+# DNS implementation header
+#
+cdl_option CYGBLD_ISO_DNS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/ns/dns/dns.h>
+    # value_source inferred
+    # Default value: 0 0
+};
+
+# Protocol network database implementations
+#
+cdl_interface CYGINT_ISO_NETDB_PROTO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_NETDB_PROTO 
+    #     CYGINT_ISO_NETDB_PROTO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_NETDB_PROTO
+    #     Requires:  1 >= CYGINT_ISO_NETDB_PROTO 
+};
+
+# Protocol network database implementation header
+#
+cdl_option CYGBLD_ISO_NETDB_PROTO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <net/netdb.h>
+    # value_source inferred
+    # Default value: 0 0
+};
+
+# Services network database implementations
+#
+cdl_interface CYGINT_ISO_NETDB_SERV {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_NETDB_SERV 
+    #     CYGINT_ISO_NETDB_SERV == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_NETDB_SERV
+    #     Requires:  1 >= CYGINT_ISO_NETDB_SERV 
+};
+
+# Services network database implementation header
+#
+cdl_option CYGBLD_ISO_NETDB_SERV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <net/netdb.h>
+    # value_source inferred
+    # Default value: 0 0
+};
+
+# <
+# Build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_ISOINFRA_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the ISO C and POSIX infrastructure package.
+# These flags are used in addition to the set of global flags.
+#
+cdl_option CYGPKG_ISOINFRA_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the ISO C and POSIX infrastructure package.
+# These flags are removed from the set of global flags
+# if present.
+#
+cdl_option CYGPKG_ISOINFRA_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# eCos kernel
+# doc: ref/kernel.html
+# This package contains the core functionality of the eCos
+# kernel. It relies on functionality provided by various HAL
+# packages and by the eCos infrastructure. In turn the eCos
+# kernel provides support for other packages such as the device
+# drivers and the uITRON compatibility layer.
+#
+cdl_package CYGPKG_KERNEL {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # option CYGFUN_HAL_COMMON_KERNEL_SUPPORT
+    #     Requires: CYGPKG_KERNEL
+    # option CYGFUN_HAL_COMMON_KERNEL_SUPPORT
+    #     DefaultValue: CYGPKG_KERNEL
+    # option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE
+    #     DefaultValue:  CYGPKG_KERNEL ? 4096 : 32768 
+    # option CYGSEM_MEMALLOC_ALLOCATOR_FIXED_THREADAWARE
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_THREADAWARE
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_THREADAWARE
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_THREADAWARE
+    #     Requires: CYGPKG_KERNEL
+    # option CYGSEM_MEMALLOC_ALLOCATOR_SEPMETA_THREADAWARE
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGFUN_MEMALLOC_KAPI
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGSEM_LIBC_STRING_PER_THREAD_STRTOK
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGSEM_LIBC_I18N_PER_THREAD_MB
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGSEM_LIBC_STARTUP_MAIN_INITCONTEXT
+    #     DefaultValue:  0 == CYGPKG_KERNEL && 0 == 
+    #                                 CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    # component CYGSEM_LIBC_STARTUP_MAIN_THREAD
+    #     Requires: CYGPKG_KERNEL
+    # component CYGSEM_LIBC_STARTUP_MAIN_THREAD
+    #     DefaultValue:  0 != CYGPKG_KERNEL && 0 ==  CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    # option CYGSEM_LIBC_EXIT_STOPS_SYSTEM
+    #     Requires: CYGPKG_KERNEL
+    # option CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS
+    #     ActiveIf: CYGPKG_KERNEL
+    # package CYGPKG_POSIX
+    #     Requires: CYGPKG_KERNEL
+    # option CYGPKG_POSIX_CLOCKS
+    #     Requires: CYGPKG_KERNEL
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires: CYGPKG_KERNEL
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGPKG_KERNEL
+    # option CYGPKG_WALLCLOCK_EMULATE
+    #     Requires: CYGPKG_KERNEL
+    # option CYGIMP_WALLCLOCK_NONE
+    #     DefaultValue:  !CYGPKG_KERNEL && 0 == CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS 
+    # option CYGPKG_IO_WALLCLOCK_TESTS
+    #     Calculated:  CYGPKG_KERNEL ? "tests/wallclock tests/wallclock2" : "" 
+    # option CYGFUN_IO_FILEIO_SELECT
+    #     ActiveIf: CYGPKG_KERNEL
+    # option CYGPKG_IO_FILEIO_SOCKET_SUPPORT
+    #     ActiveIf: CYGPKG_KERNEL
+};
+
+# >
+# Kernel interrupt handling
+# doc: ref/kernel-interrupts.html
+# The majority of configuration options related to interrupt
+# handling are in the HAL packages, since usually the code has
+# to be platform-specific. There are a number of options
+# provided within the kernel related to slightly higher-level
+# concepts, for example Delayed Service Routines.
+#
+cdl_component CYGPKG_KERNEL_INTERRUPTS {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_INSTRUMENT_INTR
+    #     ActiveIf: CYGPKG_KERNEL_INTERRUPTS
+};
+
+# >
+# Use delayed service routines (DSRs)
+# In eCos the recommended way to handle device interrupts is to
+# do a minimum amount of work inside the low level interrupt
+# handler itself, and instead do as much as possible in a
+# Delayed Service Routine or DSR. If an application does not
+# make use of DSRs directly or indirectly then it is possible
+# to disable the DSR support completely, which reduces the
+# overheads of context switches and interrupt handling. Note
+# that the kernel real-time clock makes use of DSRs, as do many
+# of the device drivers. 
+#
+cdl_component CYGIMP_KERNEL_INTERRUPTS_DSRS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     Requires: CYGIMP_KERNEL_INTERRUPTS_DSRS
+};
+
+# >
+#
+cdl_interface CYGINT_KERNEL_INTERRUPTS_DSRS {
+    # Implemented by CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST, active, enabled
+    # Implemented by CYGIMP_KERNEL_INTERRUPTS_DSRS_TABLE, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires: 1 == CYGINT_KERNEL_INTERRUPTS_DSRS
+    #     CYGINT_KERNEL_INTERRUPTS_DSRS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_KERNEL_INTERRUPTS_DSRS
+    #     Requires: 1 == CYGINT_KERNEL_INTERRUPTS_DSRS
+};
+
+# Use linked lists for DSRs
+# When DSR support is enabled the kernel must keep track of all
+# the DSRs that are pending. This information can be kept in a
+# fixed-size table or in a linked list. The list implementation
+# requires that the kernel disable interrupts for a very short
+# period of time outside interrupt handlers, but there is no
+# possibility of a table overflow occurring.
+#
+cdl_component CYGIMP_KERNEL_INTERRUPTS_DSRS_LIST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Schedule DSRs in FIFO order
+# When this option is set, DSRs are scheduled
+# in the natural FIFO (first in, first out) order,
+# otherwise they are scheduled in LIFO (last in, first
+# out) order. Applications should not rely on any
+# particular order of scheduling of DSRs. LIFO
+# scheduling is kept for backward compatibility only and
+# is not recommended as it may lead to high (up to 2
+# times higher then FIFO) IRQ-to-DSR latencies at some
+# (typically rare) conditions. If unsure, leave this set.
+#
+cdl_option CYGSEM_KERNEL_INTERRUPTS_DSRS_LIST_FIFO {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Use fixed-size table for DSRs
+# When DSR support is enabled the kernel must keep track of all
+# the DSRs that are pending. This information can be kept in a
+# fixed-size table or in a linked list. The table
+# implementation involves a very small risk of overflow at
+# run-time if a given interrupt source is able to have more
+# than one pending DSR. However it has the advantage that
+# the kernel does not need to disable interrupts outside
+# interrupt handlers.
+#
+cdl_component CYGIMP_KERNEL_INTERRUPTS_DSRS_TABLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Number of entries in fixed-size DSR table
+# When DSR support is enabled the kernel must keep track of all
+# the DSRs that are pending. One approach involves a fixed-size
+# table, which involves a very small risk of overflow at
+# run-time. By increasing the table size it is possible to reduce
+# this risk.
+#
+cdl_option CYGNUM_KERNEL_INTERRUPTS_DSRS_TABLE_SIZE {
+    # This option is not active
+    # The parent CYGIMP_KERNEL_INTERRUPTS_DSRS_TABLE is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 2 to 1024
+};
+
+# <
+# Chain all interrupts together
+# Interrupts can be attached to vectors either singly, or be
+# chained together. The latter is necessary if there is no way
+# of discovering which device has interrupted without
+# inspecting the device itself. It can also reduce the amount
+# of RAM needed for interrupt decoding tables and code.
+#
+cdl_option CYGIMP_KERNEL_INTERRUPTS_CHAIN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN
+    #     CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN == 0
+    #   --> 0
+};
+
+# <
+# <
+# Exception handling
+# doc: ref/kernel-exceptions.html
+# In the context of the eCos kernel exceptions are unexpected
+# events detected by the hardware, for example an attempt to
+# execute an illegal instruction. There is no relation with
+# other forms of exception, for example the catch and throw
+# facilities of languages like C++. It is possible to disable
+# all support for exceptions and thus save some memory.
+#
+cdl_component CYGPKG_KERNEL_EXCEPTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_HAL_EXCEPTIONS
+    #     CYGPKG_HAL_EXCEPTIONS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_HAL_EXCEPTIONS
+    #     Requires: CYGPKG_KERNEL_EXCEPTIONS
+    # option CYGPKG_HAL_EXCEPTIONS
+    #     DefaultValue: CYGPKG_KERNEL_EXCEPTIONS
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires: CYGPKG_KERNEL_EXCEPTIONS
+};
+
+# >
+# Decode exception types in kernel
+# On targets where several different types of exception are
+# possible, for example executing an illegal instruction and
+# division by zero, it is possible for the kernel to do some
+# decoding of the exception type and deliver the different
+# types of exception to different handlers in the application
+# code. Alternatively the kernel can simply pass all
+# exceptions directly to application code, leaving the
+# decoding to be done by the application
+#
+cdl_option CYGSEM_KERNEL_EXCEPTIONS_DECODE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Use global exception handlers
+# In the context of the eCos kernel exceptions are
+# unexpected events detected by the hardware, for
+# example an attempt to execute an illegal
+# instruction. If the kernel is configured
+# to support exceptions then two implementations are
+# possible. The default implementation involves a single set
+# of exception handlers that are in use for the entire
+# system. The alternative implementation allows different
+# exception handlers to be specified for each thread.
+#
+cdl_option CYGSEM_KERNEL_EXCEPTIONS_GLOBAL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Kernel schedulers
+# doc: ref/kernel-overview.html#KERNEL-OVERVIEW-SCHEDULERS
+# The eCos kernel provides a choice of schedulers. In addition
+# there are a number of configuration options to control the
+# detailed behaviour of these schedulers.
+#
+cdl_component CYGPKG_KERNEL_SCHED {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_INSTRUMENT_SCHED
+    #     ActiveIf: CYGPKG_KERNEL_SCHED
+};
+
+# >
+# Number of schedulers in this configuration
+#
+cdl_interface CYGINT_KERNEL_SCHEDULER {
+    # Implemented by CYGSEM_KERNEL_SCHED_MLQUEUE, active, enabled
+    # Implemented by CYGSEM_KERNEL_SCHED_BITMAP, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires: 1 == CYGINT_KERNEL_SCHEDULER
+    #     CYGINT_KERNEL_SCHEDULER == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_KERNEL_SCHEDULER
+    #     Requires: 1 == CYGINT_KERNEL_SCHEDULER
+};
+
+# Non-zero if the active schedule only has unique priorities
+# Not all schedulers allow mutiple threads to use the same
+# priority. That property is signalled via this option, allowing
+# scheduler and tests to behave accordingly.
+#
+cdl_interface CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES {
+    # Implemented by CYGSEM_KERNEL_SCHED_BITMAP, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # component CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL
+    #     Requires:  CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES == 0 
+};
+
+# Multi-level queue scheduler
+# The multi-level queue scheduler supports multiple priority
+# levels and multiple threads at each priority level.
+# Preemption between priority levels is automatic. Timeslicing
+# within a given priority level is controlled by a separate
+# configuration option.
+#
+cdl_component CYGSEM_KERNEL_SCHED_MLQUEUE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPRI_KERNEL_SCHED_IMPL_HXX
+    #     Calculated:   CYGSEM_KERNEL_SCHED_BITMAP  ? "<cyg/kernel/bitmap.hxx>"  : CYGSEM_KERNEL_SCHED_MLQUEUE ? "<cyg/kernel/mlqueue.hxx>" : CYGSEM_KERNEL_SCHED_LOTTERY ? "<cyg/kernel/lottery.hxx>" : "!!!-- Configuration broken - no scheduler selected --!!!"
+    # component CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL
+    #     ActiveIf:  CYGSEM_KERNEL_SCHED_MLQUEUE 
+    # option _POSIX_PRIORITY_SCHEDULING
+    #     Requires: CYGSEM_KERNEL_SCHED_MLQUEUE
+    # option _POSIX_THREAD_PRIORITY_SCHEDULING
+    #     Requires: CYGSEM_KERNEL_SCHED_MLQUEUE
+};
+
+# >
+# Output timeslices when tracing
+# When tracing is enabled, output trace messages every
+# timeslice. This can be quite verbose so is disabled by
+# default.
+#
+cdl_option CYGDBG_KERNEL_TRACE_TIMESLICE {
+    # This option is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: !CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE
+    #     CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE == 0
+    #   --> 1
+    # Requires: !CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY
+    #     CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY == 0
+    #   --> 1
+};
+
+# <
+# Bitmap scheduler
+# The bitmap scheduler supports multiple priority levels but
+# only one thread can exist at each priority level. This means
+# that scheduling decisions are very simple and hence the
+# scheduler is efficient. Preemption between priority levels is
+# automatic. Timeslicing within a given priority level is
+# irrelevant since there can be only one thread at each
+# priority level.
+#
+cdl_option CYGSEM_KERNEL_SCHED_BITMAP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: !CYGPKG_KERNEL_SMP_SUPPORT
+    #     CYGPKG_KERNEL_SMP_SUPPORT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPRI_KERNEL_SCHED_IMPL_HXX
+    #     Calculated:   CYGSEM_KERNEL_SCHED_BITMAP  ? "<cyg/kernel/bitmap.hxx>"  : CYGSEM_KERNEL_SCHED_MLQUEUE ? "<cyg/kernel/mlqueue.hxx>" : CYGSEM_KERNEL_SCHED_LOTTERY ? "<cyg/kernel/lottery.hxx>" : "!!!-- Configuration broken - no scheduler selected --!!!"
+    # component CYGSEM_KERNEL_SCHED_TIMESLICE
+    #     Requires: !CYGSEM_KERNEL_SCHED_BITMAP
+};
+
+# Scheduler header file
+# This option sets a preprocessor symbol which names the header
+# file for the selected scheduler.  It is used internally by the
+# common scheduler code to include the correct header file.
+#
+cdl_option CYGPRI_KERNEL_SCHED_IMPL_HXX {
+    # Calculated value:   CYGSEM_KERNEL_SCHED_BITMAP  ? "<cyg/kernel/bitmap.hxx>"  : CYGSEM_KERNEL_SCHED_MLQUEUE ? "<cyg/kernel/mlqueue.hxx>" : CYGSEM_KERNEL_SCHED_LOTTERY ? "<cyg/kernel/lottery.hxx>" : "!!!-- Configuration broken - no scheduler selected --!!!"
+    #     CYGSEM_KERNEL_SCHED_BITMAP == 0
+    #     CYGSEM_KERNEL_SCHED_MLQUEUE == 1
+    #     CYGSEM_KERNEL_SCHED_LOTTERY (unknown) == 0
+    # Flavor: data
+    # Current_value: <cyg/kernel/mlqueue.hxx>
+};
+
+# Number of priority levels
+# This option controls the number of priority levels that are
+# available. For some types of scheduler including the bitmap
+# scheduler this may impose an upper bound on the number of
+# threads in the system. For other schedulers such as the
+# mlqueue scheduler the number of threads is independent from
+# the number of priority levels. Note that the lowest priority
+# level is normally used only by the idle thread, although
+# application threads can run at this priority if necessary.
+#
+cdl_component CYGNUM_KERNEL_SCHED_PRIORITIES {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 1 to 32
+
+    # The following properties are affected by this value
+    # option CYGIMP_IDLE_THREAD_YIELD
+    #     ActiveIf: (CYGNUM_KERNEL_SCHED_PRIORITIES == 1)
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY
+    #     LegalValues: 0 to  CYGNUM_KERNEL_SCHED_PRIORITIES - 1 
+};
+
+# >
+# Bitmap size
+# This option automatically defines the size of bitmap
+# used to track occupied priority levels.
+#
+cdl_option CYGNUM_KERNEL_SCHED_BITMAP_SIZE {
+    # Calculated value: "CYGNUM_KERNEL_SCHED_PRIORITIES"
+    # Flavor: data
+    # Current_value: CYGNUM_KERNEL_SCHED_PRIORITIES
+};
+
+# Dequeue highest priority threads first
+# With this option enabled, threads queued in a thread queue
+# will be dequeued in priority order, rather than first in,
+# first out (FIFO). Threads of equal priority are dequeued
+# oldest first. The only exception is the scheduler run 
+# queues where order is less important as each is already
+# sorted by priority. Note that this makes the thread queueing
+# less deterministic.
+#
+cdl_option CYGIMP_KERNEL_SCHED_SORTED_QUEUES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_POSIX
+    #     Requires: CYGIMP_KERNEL_SCHED_SORTED_QUEUES
+};
+
+# <
+# Scheduler timeslicing
+# Some schedulers including the mlqueue scheduler support
+# timeslicing. This means that the kernel will check regularly
+# whether or not there is another runnable thread with the
+# same priority, and if there is such a thread there will be
+# an automatic context switch. Not all applications require
+# timeslicing, for example because every thread performs a
+# blocking operation regularly. For these applications it is
+# possible to disable timeslicing, which reduces the overheads
+# associated with timer interrupts.
+#
+cdl_component CYGSEM_KERNEL_SCHED_TIMESLICE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: !CYGSEM_KERNEL_SCHED_BITMAP
+    #     CYGSEM_KERNEL_SCHED_BITMAP == 0
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option _POSIX_THREADS
+    #     Requires: CYGSEM_KERNEL_SCHED_TIMESLICE
+};
+
+# >
+# Number of clock ticks between timeslices
+# Assuming timeslicing is enabled, how frequently should it
+# take place? The value of this option corresponds to the
+# number of clock ticks that should occur before a timeslice
+# takes place, so increasing the value reduces the frequency
+# of timeslices.
+#
+cdl_option CYGNUM_KERNEL_SCHED_TIMESLICE_TICKS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 5
+    # value_source default
+    # Default value: 5
+    # Legal values: 1 to 65535
+};
+
+# Support runtime enable of timeslice per-thread
+# This option makes timslicing a per-thread runtime
+# option. When enabled, threads may have timeslicing
+# turned on or off dynamically. This is generally used
+# by higher level APIs (such as POSIX) to implement
+# differing scheduling policies.
+#
+cdl_option CYGSEM_KERNEL_SCHED_TIMESLICE_ENABLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: false
+    #     false (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: CYGSEM_KERNEL_SCHED_TIMESLICE_ENABLE
+};
+
+# <
+# Enable ASR support
+# This component controls support for Asynchronous Service
+# Routines (ASRs). This is a function that may be called
+# from the scheduler when it has just exited the scheduler
+# lock. This is primarily for use by API compatibility layers.
+#
+cdl_component CYGSEM_KERNEL_SCHED_ASR_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: false
+    #     false (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: CYGSEM_KERNEL_SCHED_ASR_SUPPORT
+};
+
+# >
+# Make ASR function global
+# This option controls whether the ASR function is shared by
+# all threads, or whether each thread may have its own ASR
+# function.
+#
+cdl_option CYGSEM_KERNEL_SCHED_ASR_GLOBAL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: true
+    #     true (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: CYGSEM_KERNEL_SCHED_ASR_GLOBAL
+};
+
+# Make ASR data global
+# This option controls whether the ASR data is shared by
+# all threads, or whether each thread may have its own ASR
+# data. This is independent of the previous option because
+# it may be useful to pass per-thread data to a shared ASR
+# function.
+#
+cdl_option CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: true
+    #     true (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: !CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL
+};
+
+# <
+# <
+# SMP support
+#
+cdl_component CYGPKG_KERNEL_SMP_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGPKG_HAL_SMP_SUPPORT
+    #     CYGPKG_HAL_SMP_SUPPORT == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_KERNEL_SCHED_BITMAP
+    #     Requires: !CYGPKG_KERNEL_SMP_SUPPORT
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+};
+
+# Counters and clocks
+# doc: ref/kernel-counters.html
+# The counter objects provided by the kernel provide an
+# abstraction of the clock facility that is generally provided.
+# Application code can associate alarms with counters, where an
+# alarm is identified by the number of ticks until it triggers,
+# the action to be taken on triggering, and whether or not the
+# alarm should be repeated.
+#
+cdl_component CYGPKG_KERNEL_COUNTERS {
+    # There is no associated value.
+};
+
+# >
+# Provide real-time clock
+# On all current target systems the kernel can provide a
+# real-time clock. This clock serves two purposes. First it is
+# necessary to support clock and alarm related functions.
+# Second it is needed to implement timeslicing in some of the
+# schedulers including the mlqueue scheduler. If the
+# application does not require any of these facilities then it
+# is possible to disable the real time clock support
+# completely.
+#
+cdl_option CYGVAR_KERNEL_COUNTERS_CLOCK {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGIMP_KERNEL_INTERRUPTS_DSRS
+    #     CYGIMP_KERNEL_INTERRUPTS_DSRS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGSEM_KERNEL_SCHED_TIMESLICE
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY
+    #     ActiveIf: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGFUN_KERNEL_THREADS_TIMER
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGDBG_KERNEL_INSTRUMENT_CLOCK
+    #     ActiveIf: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGDBG_KERNEL_INSTRUMENT_ALARM
+    #     ActiveIf: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGDBG_KERNEL_INSTRUMENT_SMP
+    #     ActiveIf: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGFUN_HAL_I386_PCMB_GPROF_SUPPORT
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # component CYGPKG_HAL_TESTS
+    #     Calculated:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+    # option CYGSEM_LIBC_TIME_CLOCK_WORKING
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGPKG_POSIX_CLOCKS
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    # option CYGPKG_WATCHDOG_EMULATE
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+};
+
+# Interrupt priority for the real-time clock
+# The implementation of the kernel's real-time clock typically
+# involves installing an interrupt handler on a suitable hardware
+# timer. This option controls the priority level used for that
+# interrupt. On most platforms the value is not important because 
+# the clock ISR leaves most of the work to be done by the DSR. 
+# However some processors have interrupt controllers with special
+# requirements for the interrupt priorities, in which case
+# application developers must be able to manipulate the clock's
+# priority.
+#
+cdl_option CYGNUM_KERNEL_COUNTERS_CLOCK_ISR_PRIORITY {
+    # ActiveIf constraint: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  is_loaded(CYGNUM_HAL_KERNEL_COUNTERS_CLOCK_ISR_DEFAULT_PRIORITY) ?
+    #      	                      CYGNUM_HAL_KERNEL_COUNTERS_CLOCK_ISR_DEFAULT_PRIORITY : 1 
+    #     CYGNUM_HAL_KERNEL_COUNTERS_CLOCK_ISR_DEFAULT_PRIORITY (unknown) == 0
+    #     CYGNUM_HAL_KERNEL_COUNTERS_CLOCK_ISR_DEFAULT_PRIORITY (unknown) == 0
+    #   --> 1
+};
+
+#
+cdl_interface CYGINT_KERNEL_COUNTERS {
+    # Implemented by CYGIMP_KERNEL_COUNTERS_SINGLE_LIST, active, enabled
+    # Implemented by CYGIMP_KERNEL_COUNTERS_MULTI_LIST, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires: 1 == CYGINT_KERNEL_COUNTERS
+    #     CYGINT_KERNEL_COUNTERS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_KERNEL_COUNTERS
+    #     Requires: 1 == CYGINT_KERNEL_COUNTERS
+};
+
+# Implement counters using a single list
+# There are two different implementations of the counter
+# objects. The first implementation stores all alarms in a
+# single linked list. The alternative implementation uses a
+# table of linked lists. A single list is more efficient in
+# terms of memory usage and is generally adequate when the
+# application only makes use of a small number of alarms.
+#
+cdl_option CYGIMP_KERNEL_COUNTERS_SINGLE_LIST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Implement counters using a table of lists
+# There are two different implementations of the counter
+# objects. The first implementation stores all alarms in a
+# single linked list. The alternative implementation uses a
+# table of linked lists, with the size of the table being a
+# separate configurable option. For more complicated
+# operations it is better to have a table of lists since this
+# reduces the amount of computation whenever the timer goes
+# off. Assuming a table size of 8 (the default value) on
+# average the timer code will only need to check 1/8 of the
+# pending alarms instead of all of them.
+#
+cdl_component CYGIMP_KERNEL_COUNTERS_MULTI_LIST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Size of counter list table
+# If counters are implemented using an array of linked lists
+# then this option controls the size of the array. A larger
+# size reduces the amount of computation that needs to take
+# place whenever the timer goes off, but requires extra
+# memory.
+#
+cdl_option CYGNUM_KERNEL_COUNTERS_MULTI_LIST_SIZE {
+    # This option is not active
+    # The parent CYGIMP_KERNEL_COUNTERS_MULTI_LIST is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 1 to 1024
+};
+
+# <
+# Sort the counter list
+# Sorting the counter lists reduces the amount of work that
+# has to be done when a counter tick is processed, since the
+# next alarm to expire is always at the front of the list.
+# However, it makes adding an alarm to the list more expensive
+# since a search must be done for the correct place to put it.
+# Many alarms are used to implement timeouts, which seldom trigger,
+# so it is worthwhile optimizing this case. For this reason
+# sorted list are disabled by default.
+#
+cdl_option CYGIMP_KERNEL_COUNTERS_SORT_LIST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Measure real-time [clock] interrupt latency
+# Measure the interrupt latency as seen by the real-time clock
+# timer interrupt.  This requires hardware support, defined by
+# the HAL_CLOCK_LATENCY() macro.
+#
+cdl_option CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGVAR_KERNEL_COUNTERS_CLOCK_DSR_LATENCY
+    #     Requires: CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+    # option CYGVAR_KERNEL_COUNTERS_CLOCK_DSR_LATENCY
+    #     DefaultValue: CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+};
+
+# Measure real-time [clock] DSR latency
+# Measure the DSR latency as seen by the real-time clock
+# timer interrupt.  This requires hardware support, defined by
+# the HAL_CLOCK_LATENCY() macro.
+#
+cdl_option CYGVAR_KERNEL_COUNTERS_CLOCK_DSR_LATENCY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY == 0
+    #   --> 0
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK_LATENCY == 0
+    #   --> 0
+};
+
+# RTC resolution
+# This option automatically defines the tuple which is used to
+# initialize the RTC resolution, consisting of a numerator and
+# denominator. The values of the numerator and denominator are
+# defined by the HAL.
+#
+cdl_option CYGNUM_KERNEL_COUNTERS_RTC_RESOLUTION {
+    # Calculated value: "{CYGNUM_HAL_RTC_NUMERATOR, CYGNUM_HAL_RTC_DENOMINATOR}"
+    # Flavor: data
+    # Current_value: {CYGNUM_HAL_RTC_NUMERATOR, CYGNUM_HAL_RTC_DENOMINATOR}
+};
+
+# RTC period
+# This option defines the RTC period to be used in
+# setting the system clock hardware. It is essentially
+# an alias for CYGNUM_HAL_RTC_PERIOD, which is defined
+# in the HAL.
+#
+cdl_option CYGNUM_KERNEL_COUNTERS_RTC_PERIOD {
+    # Calculated value: "CYGNUM_HAL_RTC_PERIOD"
+    # Flavor: data
+    # Current_value: CYGNUM_HAL_RTC_PERIOD
+};
+
+# <
+# Thread-related options
+# There are a number of configuration options related to the
+# implementation of threads, for example whether or not the
+# eCos kernel supports per-thread data.
+#
+cdl_component CYGPKG_KERNEL_THREADS {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_INSTRUMENT_THREAD
+    #     ActiveIf: CYGPKG_KERNEL_THREADS
+};
+
+# >
+# Allow per-thread timers
+# This option controls whether or not the kernel should support
+# per-thread clock and alarm related functions. Also some of
+# the synchronization primitives such as semaphore and
+# condition variable timed wait operations require per-thread
+# timer support. If none of these facilities are required then
+# the option can be disabled.
+#
+cdl_option CYGFUN_KERNEL_THREADS_TIMER {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT
+    #     Requires: CYGFUN_KERNEL_THREADS_TIMER
+    # option CYGSEM_LIBC_TIME_CLOCK_WORKING
+    #     Requires: CYGFUN_KERNEL_THREADS_TIMER
+};
+
+# Support optional name for each thread
+# Threads may optionally be supplied with a name string that is
+# used to identify them during debugging. This name is only
+# present if `this option is defined. Disabling it reduces both
+# code and data size.
+#
+cdl_option CYGVAR_KERNEL_THREADS_NAME {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Keep track of all threads using a linked list
+# Threads may optionally be placed on a housekeeping list so
+# that all threads may be located easily. This is useful mainly
+# in conjunction with source-level debugging.
+#
+cdl_option CYGVAR_KERNEL_THREADS_LIST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGFUN_KERNEL_ALL_THREADS_STACK_CHECKING
+    #     Requires: CYGVAR_KERNEL_THREADS_LIST
+    # option CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT
+    #     Requires: CYGVAR_KERNEL_THREADS_LIST
+};
+
+# Keep track of the base of each thread's stack
+# This option makes the kernel keep track of the lower limit on
+# each thread's stack. It allows the kernel to adjust the lower
+# limit, thus making space for per-thread data. Note that it
+# does not imply any form of run-time stack overflow checking.
+#
+cdl_option CYGFUN_KERNEL_THREADS_STACK_LIMIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGVAR_KERNEL_THREADS_DATA
+    #     Requires: CYGFUN_KERNEL_THREADS_STACK_LIMIT
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: CYGFUN_KERNEL_THREADS_STACK_LIMIT
+};
+
+# Check thread stacks for overflows
+# This option enables a variety of checks for stack overflow
+# including signatures at the top and base of thread stacks,
+# which are asserted for correctness whenever a thread switches.
+#
+cdl_component CYGFUN_KERNEL_THREADS_STACK_CHECKING {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_INFRA_DEBUG
+    #     CYGPKG_INFRA_DEBUG == 0
+    #   --> 0
+    # ActiveIf constraint: CYGDBG_USE_ASSERTS
+    #     CYGDBG_USE_ASSERTS == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Check all threads whenever possible
+# This option enables more active checking of all threads for
+# wrongdoing.  In theory, checking threads other than the old and new
+# executing threads in a thread-switch is pointless, because no other
+# thread has run, so no other stack can be exceeded.  But errors such
+# as memory scribbling, dangling pointers, overlapping use of store
+# or errors accessing objects adjacent to a stack which can be very
+# hard to find can be detected this way, saving debug time.
+#
+cdl_option CYGFUN_KERNEL_ALL_THREADS_STACK_CHECKING {
+    # This option is not active
+    # The parent CYGFUN_KERNEL_THREADS_STACK_CHECKING is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGVAR_KERNEL_THREADS_LIST
+    #     CYGVAR_KERNEL_THREADS_LIST == 1
+    #   --> 1
+};
+
+# Signature size in bytes, at stack top and bottom
+# This is the size of the area reserved for a signature at the top
+# and bottom of all stacks.  It also provides a buffer zone for
+# detecting overflow before external objects are corrupted, hence the
+# ability to vary it here.  But if you are short of stack, increasing
+# this value will make the overflow more, not less likely, of course.
+#
+cdl_option CYGNUM_KERNEL_THREADS_STACK_CHECK_DATA_SIZE {
+    # This option is not active
+    # The parent CYGFUN_KERNEL_THREADS_STACK_CHECKING is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 8 to 512
+};
+
+# <
+# Measure stack usage
+# This option allows measurement of each thread's stack by initializing
+# it to a predefined value at thread creation time. Later use of the
+# cyg_thread_measure_stack_usage() function allows the maximum stack
+# usage of the thread so far to be obtained. Note that this is not
+# necessarily the true maximum stack usage that the thread will ever
+# use since all that has been measured is the stack usage corresponding
+# to the code path followed this time, and not the code path that may
+# be followed in future.
+#
+cdl_component CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 != CYGPKG_INFRA_DEBUG 
+    #     CYGPKG_INFRA_DEBUG == 0
+    #   --> 0
+};
+
+# >
+# Output stack usage on thread exit
+# This will output the measured stack usage on the diagnostic
+# output when a thread exits.
+#
+cdl_option CYGDBG_KERNEL_THREADS_STACK_MEASUREMENT_VERBOSE_EXIT {
+    # This option is not active
+    # The parent CYGFUN_KERNEL_THREADS_STACK_MEASUREMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Support for per-thread data
+# doc: ref/kernel-thread-data.html
+# It is possible for the kernel to support per-thread data, in
+# other words an area of memory specific to each thread which
+# can be used to store data for that thread. This per-thread
+# data can be used by applications or by other packages such as
+# the ISO C library.
+#
+cdl_component CYGVAR_KERNEL_THREADS_DATA {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_KERNEL_THREADS_STACK_LIMIT
+    #     CYGFUN_KERNEL_THREADS_STACK_LIMIT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_PER_THREAD_RAND
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_LIBC_STRING_PER_THREAD_STRTOK
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_LIBC_STRING_PER_THREAD_STRTOK
+    #     DefaultValue: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_LIBC_I18N_PER_THREAD_MB
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_LIBC_I18N_PER_THREAD_MB
+    #     DefaultValue:  CYGVAR_KERNEL_THREADS_DATA != 0 
+    # option CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_LIBM_THREAD_SAFE_GAMMA_FUNCTIONS
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option _POSIX_THREADS
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+    # option CYGSEM_ERROR_PER_THREAD_ERRNO
+    #     Requires: CYGVAR_KERNEL_THREADS_DATA
+};
+
+# >
+# Number of words of per-thread data
+# It is possible for the kernel to support per-thread data, in
+# other words an area of memory specific to each thread which
+# can be used to store data for that thread. This per-thread
+# data can be used by applications or by other packages such as
+# the ISO C library. This configuration option controls the
+# number of words of per-thread data that the kernel will
+# allow. In the current implementation a bitmask is used to identify
+# used per-thread data slots and so the maximum legal value must
+# remain 32.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DATA_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 6
+    # value_source default
+    # Default value: 6
+    # Legal values: 4 to 32
+};
+
+# Bitmap of preallocated slots of thread data
+# Per thread data options. Per thread data support is based loosely
+# on that defined by POSIX. Each thread has an array of slots, up to
+# CYGNUM_KERNEL_THREADS_DATA_MAX, that may contain data. Some of the
+# slots have been preallocated to specific packages. Others may be
+# allocated dynamically.
+#
+cdl_component CYGNUM_KERNEL_THREADS_DATA_ALL {
+    # Calculated value: 15
+    # Flavor: data
+    # Current_value: 15
+};
+
+# >
+# Slot 0 preallocated for the kernel
+# This option defines the index of a per-thread data
+# slot which is reserved by
+# the eCos kernel
+# for private use.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DATA_KERNEL {
+    # Calculated value: 0
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Slot 1 preallocated for uITRON
+# This option defines the index of a per-thread data
+# slot which is reserved by
+# the uITRON compatibility layer
+# for private use.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DATA_ITRON {
+    # Calculated value: 1
+    # Flavor: data
+    # Current_value: 1
+};
+
+# Slot 2 preallocated for errno
+# This option defines the index of a per-thread data
+# slot which is reserved for use by an errno variable.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DATA_ERRNO {
+    # Calculated value: 2
+    # Flavor: data
+    # Current_value: 2
+};
+
+# Slot 3 preallocated for POSIX
+# This option defines the index of a per-thread data
+# slot which is reserved by
+# POSIX
+# for private use.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DATA_POSIX {
+    # Calculated value: 3
+    # Flavor: data
+    # Current_value: 3
+};
+
+# <
+# <
+# Thread destructors
+# doc: ref/kernel-thread-destructors.html
+# This option enables support for registered destructor functions to
+# be called on thread exit.
+#
+cdl_component CYGPKG_KERNEL_THREADS_DESTRUCTORS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: 0
+};
+
+# >
+# Number of possible destructors
+# This option gives the number of possible destructors allowed.
+# Increasing this will increase the size of every
+# thread control structure if per-thread destructors are
+# enabled.
+#
+cdl_option CYGNUM_KERNEL_THREADS_DESTRUCTORS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 1 to 65535
+};
+
+# Per-thread destructors
+# Enabling this option makes the thread destructors a per-thread
+# property, with each thread having its own list of destructors.
+# Disabling this option makes the thread destructor list
+# global so all threads have the same destructors.
+#
+cdl_option CYGSEM_KERNEL_THREADS_DESTRUCTORS_PER_THREAD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Stack size for the idle thread
+# This configuration option specifies the stack size in bytes
+# for the idle thread. Unless the HAL is configured to use a
+# separate interrupt stack this size must be sufficient to meet
+# the requirements of all interrupt handlers - these
+# requirements are cumulative if nested interrupted are
+# enabled. Depending on the target architecture, the stack size
+# typically has to be a multiple of eight or sixteen bytes.
+# This will be overridden where it is used if the
+# architectural HAL requires a minimum stack size
+# to handle interrupts correctly.
+#
+cdl_option CYGNUM_KERNEL_THREADS_IDLE_STACK_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2048
+    # value_source default
+    # Default value: 2048
+    # Legal values: 512 to 65536
+};
+
+# Maximal suspend count
+# This option provides for an assertion that the count value for
+# counted thread suspends do not exceed set limits.  This is to help
+# with debugging, to allow a runaway loop, for example, to be
+# detected more easily.
+# If the option is not defined, no assert is included.  Whether asserts
+# are themselves included depends on infrastructure configury in
+# infra.h
+#
+cdl_option CYGNUM_KERNEL_MAX_SUSPEND_COUNT_ASSERT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 500
+    # value_source default
+    # Default value: 500
+};
+
+# Maximal wake count
+# This option provides for an assertion that the count value for
+# counted thread wakeups do not exceed set limits.  This is to
+# help with debugging, to allow a runaaway loop, for example, to
+# be detected more easily.
+# If the option is not defined, no assert is included.  Whether asserts
+# are themselves included depends on infrastructure configury in
+# infra.h
+#
+cdl_option CYGNUM_KERNEL_MAX_COUNTED_WAKE_COUNT_ASSERT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 500
+    # value_source default
+    # Default value: 500
+};
+
+# Idle thread must always yield
+# If the scheduler configuration only has a single priority
+# level, then the idle thread must yield each time around its loop.
+#
+cdl_option CYGIMP_IDLE_THREAD_YIELD {
+    # This option is not active
+    # ActiveIf constraint: (CYGNUM_KERNEL_SCHED_PRIORITIES == 1)
+    #     CYGNUM_KERNEL_SCHED_PRIORITIES == 32
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# <
+# Synchronization primitives
+# The eCos kernel supports a number of different
+# synchronization primitives such as mutexes, semaphores,
+# condition variables, and message boxes. There are
+# configuration options to control the exact behaviour of some
+# of these synchronization primitives.
+#
+cdl_component CYGPKG_KERNEL_SYNCH {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+    # option CYGDBG_KERNEL_INSTRUMENT_MUTEX
+    #     ActiveIf: CYGPKG_KERNEL_SYNCH
+    # option CYGDBG_KERNEL_INSTRUMENT_CONDVAR
+    #     ActiveIf: CYGPKG_KERNEL_SYNCH
+    # option CYGDBG_KERNEL_INSTRUMENT_BINSEM
+    #     ActiveIf: CYGPKG_KERNEL_SYNCH
+    # option CYGDBG_KERNEL_INSTRUMENT_CNTSEM
+    #     ActiveIf: CYGPKG_KERNEL_SYNCH
+    # option CYGDBG_KERNEL_INSTRUMENT_MBOXT
+    #     ActiveIf: CYGPKG_KERNEL_SYNCH
+};
+
+# >
+# Priority inversion protection protocols
+# doc: ref/kernel-mutexes.html
+# This component controls the protocols used to protect mutexes against
+# priority inversion. If this option is enabled it defines which
+# algorithm is used to implement this protection. At present only
+# one such algorithm is defined: "SIMPLE". The implementation
+# will only work in the mlqueue scheduler, and it does not handle the
+# rare case of nested mutexes completely correctly. However it is
+# both fast and deterministic.
+#
+cdl_component CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL {
+    # ActiveIf constraint:  CYGSEM_KERNEL_SCHED_MLQUEUE 
+    #     CYGSEM_KERNEL_SCHED_MLQUEUE == 1
+    #   --> 1
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 SIMPLE
+    # value_source default
+    # Default value: 1 SIMPLE
+    # Legal values:  "SIMPLE" 
+    # Requires:  CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES == 0 
+    #     CYGINT_KERNEL_SCHEDULER_UNIQUE_PRIORITIES == 0
+    #   --> 1
+};
+
+# >
+# Enable priority inheritance protocol
+# This option enables priority inheritance protocol. This protocol
+# causes the owner of a mutex to be executed at the highest priority
+# of the threads waiting for access to the mutex.
+#
+cdl_option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT
+    #     DefaultValue:  CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT ?
+    #                             "INHERIT" :
+    #                             CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING ?
+    #                             "CEILING" : "NONE" 
+    # option _POSIX_THREAD_PRIO_INHERIT
+    #     Requires: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT
+};
+
+# Enable priority ceiling protocol
+# This option enables priority ceiling protocol. This protocol
+# causes the owner of a mutex to be executed at a  priority
+# associated with the mutex.
+#
+cdl_component CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY
+    #     ActiveIf: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT
+    #     DefaultValue:  CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT ?
+    #                             "INHERIT" :
+    #                             CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING ?
+    #                             "CEILING" : "NONE" 
+    # option _POSIX_THREAD_PRIO_PROTECT
+    #     Requires: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
+};
+
+# >
+# Default priority ceiling
+# This option defines the default priority ceiling to be
+# used if the chosen default priority inversion protocol is
+# priority ceoptioniling protocol. The default value for this is zero,
+# making all such mutexes boost threads to the maximum priority.
+#
+cdl_option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT_PRIORITY {
+    # ActiveIf constraint: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
+    #     CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING == 1
+    #   --> 1
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to  CYGNUM_KERNEL_SCHED_PRIORITIES - 1 
+    #     CYGNUM_KERNEL_SCHED_PRIORITIES == 32
+};
+
+# <
+# No priority inversion protocol
+# This option enables the ability to have no priority inversion protocol.
+# It is equivalent to disabling the priority inversion protocol at
+# the top level, but is necessary for the runtime and default
+# selection options.
+#
+cdl_option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_NONE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Default priority inversion protocol
+# This option defines the default inversion protocol used for mutexes that
+# are created without an explicit protocol being specified. The protocol
+# chosen by default is to use priority inheritance if it is present otherwise
+# priority ceiling, or none if neither is present.
+#
+cdl_option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT {
+    # ActiveIf constraint:  CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT > 1 
+    #     CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT == 3
+    #   --> 1
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value INHERIT
+    # value_source default
+    # Default value:  CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT ?
+    #                             "INHERIT" :
+    #                             CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING ?
+    #                             "CEILING" : "NONE" 
+    #     CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT == 1
+    #     CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING == 1
+    #   --> INHERIT
+    # Legal values:  "INHERIT" "CEILING" "NONE" 
+};
+
+# Specify mutex priority inversion protocol at runtime
+# This option controls whether the priority inversion protocol used by
+# a mutex can be specified when that mutex is created.
+#
+cdl_option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC {
+    # ActiveIf constraint:  CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT > 1 
+    #     CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT == 3
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Number of protocols selected
+#
+cdl_interface CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT {
+    # Implemented by CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT, active, enabled
+    # Implemented by CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING, active, enabled
+    # Implemented by CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_NONE, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 3
+
+    # The following properties are affected by this value
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DEFAULT
+    #     ActiveIf:  CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT > 1 
+    # option CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_DYNAMIC
+    #     ActiveIf:  CYGINT_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_COUNT > 1 
+};
+
+# <
+# Use mboxt_plain mbox implementation
+# Use the plain mboxt implementation instead of the mboxt2
+# implementation. The mboxt2 version is designed to provide
+# semantics compatible with UITRON, the plain implementation
+# is adquate in most other situations.
+#
+cdl_option CYGIMP_MBOX_USE_MBOXT_PLAIN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Message box blocking put support
+# doc: ref/kernel-mail-boxes.html
+# Message boxes can support three different versions of the
+# put-message operation. The first is tryput(), which will fail
+# if the message box is already full. The other two are the
+# ordinary put() function which will block if the message box
+# is full, and a timed put() operation which will block for
+# upto a certain length of time if the message box is currently
+# full. The blocking versions require extra memory in the
+# message box data structure and extra code in the other
+# message box functions, so they can be disabled if the
+# application does not require them. If this option is enabled
+# then the system will always provide the blocking put()
+# function, and it will also provide the timed put() function
+# if thread timers are enabled.
+#
+cdl_option CYGMFN_KERNEL_SYNCH_MBOXT_PUT_CAN_WAIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Message box queue size
+# doc: ref/kernel-mail-boxes.html
+# This configuration option controls the number of messages
+# that can be queued in a message box before a non-blocking
+# put() operation will fail or a blocking put() operation will
+# block. The cost in memory is one pointer per message box for
+# each possible message.
+#
+cdl_option CYGNUM_KERNEL_SYNCH_MBOX_QUEUE_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+    # Legal values: 1 to 65535
+};
+
+# Condition variable timed-wait support
+# doc: ref/kernel-condition-variables.html
+# This option enables the condition variable timed wait
+# facility.
+#
+cdl_option CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_KERNEL_THREADS_TIMER
+    #     CYGFUN_KERNEL_THREADS_TIMER == 1
+    #   --> 1
+};
+
+# Condition variable explicit mutex wait support
+# doc: ref/kernel-condition-variables.html
+# This option enables the condition variable explicit mutex wait
+# facility. By default condition variables in eCos are created with
+# a statically associated mutex. This option permits wait (and timed wait
+# if CYGMFN_KERNEL_SYNCH_CONDVAR_TIMED_WAIT is enabled) to provide a
+# different mutex as an argument. This makes no difference to the semantics
+# the wait operation except that a different mutex will be used during it.
+#
+cdl_option CYGMFN_KERNEL_SYNCH_CONDVAR_WAIT_MUTEX {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Avoid inlines in mqueue implementation
+# With this option disabled, the 'mqueue' message queue implementation
+# provides most of its implementation via inlines. However this can
+# adversely affect code size in application that make lots of mqueue
+# calls from different places, so enabling this option provides
+# non-inline versions to be used instead.
+#
+cdl_option CYGIMP_KERNEL_SYNCH_MQUEUE_NOT_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Kernel instrumentation
+# The current release of the kernel contains an initial version
+# of instrumentation support. The various parts of the kernel
+# will invoke instrumentation routines whenever appropriate
+# events occur, and these will be stored in a circular buffer
+# for later reference.
+#
+cdl_component CYGPKG_KERNEL_INSTRUMENT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+};
+
+# >
+# Use buffer provided by the application
+# In most circumstances the kernel should provide the
+# instrumentation circular buffer itself. Occasionally
+# application code may wish to provide the buffer instead,
+# giving the application code more convenient access to the
+# buffer. This also makes it possible to put the circular
+# buffer in special areas of memory, for example a region that
+# is shared with the host.
+#
+cdl_option CYGVAR_KERNEL_INSTRUMENT_EXTERNAL_BUFFER {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Size of instrumentation buffer size
+# If kernel instrumentation is enabled then the instrumentation
+# data goes into a circular buffer. A larger buffer allows
+# more data to be stored, but at a significant cost in memory.
+# The value of this option corresponds to the number of entries
+# in the table, and typically each entry will require 16 bytes
+# of memory.
+#
+cdl_option CYGNUM_KERNEL_INSTRUMENT_BUFFER_SIZE {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 256
+    # value_source default
+    # Default value: 256
+    # Legal values: 16 to 0x100000
+};
+
+# Wrap instrument buffer
+# When the instrumentation buffer is full it can either be restarted
+# from the beginning, overwriting older data, or it can stop at the
+# end. The former is useful if you want to look at the last entries
+# made while the latter is useful if you want to look at the first
+# few.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_BUFFER_WRAP {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Perform selective instrumentation
+# The kernel can either collect all instrumentation events, or
+# it can filter out events at runtime based on a set of flags.
+# For example it would be possible to decide at runtime that
+# only scheduler and interrupt instrumentation flags are of
+# interest and that all other flags should be ignored. This
+# flag mechanism involves extra code and processor cycle
+# overhead in the instrumentation code, so it can be disabled
+# if the application developer is interested in all
+# instrumentation events.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_FLAGS {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument the scheduler
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the scheduling code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_SCHED {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SCHED
+    #     CYGPKG_KERNEL_SCHED == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument thread operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the code that manipulates threads.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_THREAD {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_THREADS
+    #     CYGPKG_KERNEL_THREADS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument interrupts
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the interrupt handling code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_INTR {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_INTERRUPTS
+    #     CYGPKG_KERNEL_INTERRUPTS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument mutex operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the mutex code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_MUTEX {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SYNCH
+    #     CYGPKG_KERNEL_SYNCH == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument condition variable operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the condition variable code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_CONDVAR {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SYNCH
+    #     CYGPKG_KERNEL_SYNCH == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument binary semaphore operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the binary semaphore code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_BINSEM {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SYNCH
+    #     CYGPKG_KERNEL_SYNCH == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument counting semaphore operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the counting semaphore code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_CNTSEM {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SYNCH
+    #     CYGPKG_KERNEL_SYNCH == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument message box operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the message box code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_MBOXT {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGPKG_KERNEL_SYNCH
+    #     CYGPKG_KERNEL_SYNCH == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument clock operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the real-time clock code.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_CLOCK {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument alarm-related operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the code related to alarm operations.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_ALARM {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Instrument SMP-related operations
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not instrumentation support is compiled into
+# the code related to SMP operations.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_SMP {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+    # ActiveIf constraint: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Support application-level instrumentation
+# It is possible to perform selective instrumentation at
+# run-time. It is also possible to disable instrumentation
+# in various kernel components at compile-time, thus
+# reducing the code size overheads. This option controls
+# whether or not application-level instrumentation gets
+# compiled in.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_USER {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Print user friendly instrument messages
+# Include code which will convert the instrument type field 
+# into a more human understandable string
+#
+cdl_component CYGDBG_KERNEL_INSTRUMENT_MSGS {
+    # This option is not active
+    # The parent CYGPKG_KERNEL_INSTRUMENT is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Rebuild the header file
+# Make (using a shell script) include/cyg/kernel/instrument_desc.h in
+# your build tree; this is normally simply copied from the repository.
+# If you make a permanent change to include/instrmnt.h, such that
+# instrument_desc.h needs updating, it's up to you to first delete the
+# master file
+# ECOS_REPOSITORY/kernel/VERSION/include/instrument_desc.h
+# in your source repository, make the new version by enabling this
+# option then copy the new file
+# back from your build place to its source in
+# ECOS_REPOSITORY/kernel/VERSION/include/instrument_desc.h
+# and/or commit this to any version control system that you use.
+#
+cdl_option CYGDBG_KERNEL_INSTRUMENT_MSGS_BUILD_HEADERFILE {
+    # This option is not active
+    # The parent CYGDBG_KERNEL_INSTRUMENT_MSGS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Build the host tool to print out a dump
+# Generate a host program which can dump the instrumentation
+# data in a human readable format. You have to somehow get the
+# instrumentation buffer into a file on the host. 'Exercise for
+# the reader' as university lecturers tend to say.
+#
+cdl_component CYGDBG_KERNEL_INSTRUMENT_BUILD_HOST_DUMP {
+    # This option is not active
+    # The parent CYGDBG_KERNEL_INSTRUMENT_MSGS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# <
+# Source-level debugging support
+# If the source level debugger gdb is to be used for debugging
+# application code then it may be necessary to configure in support
+# for this in the kernel.
+#
+cdl_component CYGPKG_KERNEL_DEBUG {
+    # There is no associated value.
+};
+
+# >
+# Include GDB multi-threading debug support
+# This option enables some extra kernel code which is needed
+# to support multi-threaded source level debugging.
+#
+cdl_option CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGVAR_KERNEL_THREADS_LIST
+    #     CYGVAR_KERNEL_THREADS_LIST == 1
+    #   --> 1
+    # Requires: CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_ROM_MONITOR || CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT 
+};
+
+# <
+# Kernel APIs
+# The eCos kernel is implemented in C++, so a C++ interface
+# to the kernel is always available. There is also an optional
+# C API. Additional API's may be provided in future versions.
+#
+cdl_component CYGPKG_KERNEL_API {
+    # There is no associated value.
+};
+
+# >
+# Provide C API
+# The eCos kernel is implemented in C++, but there is an
+# optional C API for use by application code. This C API can be
+# disabled if the application code does not invoke the kernel
+# directly, but instead uses higher level code such as the
+# uITRON compatibility layer.
+#
+cdl_option CYGFUN_KERNEL_API_C {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+    # option CYGPKG_KERNEL_TESTS
+    #     Calculated:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+    # option CYGFUN_MEMALLOC_KAPI
+    #     DefaultValue: CYGFUN_KERNEL_API_C
+};
+
+# <
+# Kernel build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_KERNEL_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos kernel. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_KERNEL_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos kernel. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_KERNEL_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Kernel tests
+# This option specifies the set of tests for the eCos kernel.
+#
+cdl_option CYGPKG_KERNEL_TESTS {
+    # Calculated value:  
+    #                     "tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2" 
+    #                     . ((CYGFUN_KERNEL_API_C) ? " tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0" : "")
+    #                     . ((!CYGPKG_INFRA_DEBUG && !CYGPKG_KERNEL_INSTRUMENT && CYGFUN_KERNEL_API_C) ? " tests/dhrystone" : "")
+    #                     . ((CYGPKG_KERNEL_SMP_SUPPORT && CYGFUN_KERNEL_API_C) ? " tests/smp" : "")
+    #                     . ((!CYGINT_HAL_TESTS_NO_CACHES && CYGFUN_KERNEL_API_C) ? " tests/kcache1 tests/kcache2" : "")
+    #                 
+    #     CYGFUN_KERNEL_API_C == 1
+    #     CYGPKG_INFRA_DEBUG == 0
+    #     CYGPKG_KERNEL_INSTRUMENT == 0
+    #     CYGFUN_KERNEL_API_C == 1
+    #     CYGPKG_KERNEL_SMP_SUPPORT == 0
+    #     CYGFUN_KERNEL_API_C == 1
+    #     CYGINT_HAL_TESTS_NO_CACHES == 0
+    #     CYGFUN_KERNEL_API_C == 1
+    # Flavor: data
+    # Current_value: tests/bin_sem0 tests/bin_sem1 tests/bin_sem2 tests/bin_sem3 tests/clock0 tests/clock1 tests/clockcnv tests/clocktruth tests/cnt_sem0 tests/cnt_sem1 tests/except1 tests/flag0 tests/flag1 tests/intr0 tests/kill tests/mbox1 tests/mqueue1 tests/mutex0 tests/mutex1 tests/mutex2 tests/mutex3 tests/release tests/sched1 tests/sync2 tests/sync3 tests/thread0 tests/thread1 tests/thread2 tests/kclock0 tests/kclock1 tests/kexcept1 tests/kflag0 tests/kflag1 tests/kintr0 tests/klock tests/kmbox1 tests/kmutex0 tests/kmutex1 tests/kmutex3 tests/kmutex4 tests/ksched1 tests/ksem0 tests/ksem1 tests/kthread0 tests/kthread1 tests/stress_threads tests/thread_gdb tests/timeslice tests/tm_basic tests/fptest tests/kalarm0 tests/dhrystone tests/kcache1 tests/kcache2
+};
+
+# <
+# <
+# Dynamic memory allocation
+# doc: ref/memalloc.html
+# This package provides memory allocator infrastructure required for
+# dynamic memory allocators, including the ISO standard malloc
+# interface. It also contains some sample implementations.
+#
+cdl_package CYGPKG_MEMALLOC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# Memory allocator implementations
+# This component contains configuration options related to the 
+# various memory allocators available.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATORS {
+    # There is no associated value.
+};
+
+# >
+# Fixed block allocator
+# This component contains configuration options related to the 
+# fixed block memory allocator.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_FIXED {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_FIXED_THREADAWARE {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Simple variable block allocator
+# This component contains configuration options related to the 
+# simple variable block memory allocator. This allocator is not
+# very fast, and in particular does not scale well with large
+# numbers of allocations. It is however very compact in terms of
+# code size and does not have very much overhead per allocation.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_VARIABLE {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are added that allow a thread to wait until memory
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_THREADAWARE {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Coalesce memory
+# The variable-block memory allocator can perform coalescing
+# of memory whenever the application code releases memory back
+# to the pool. This coalescing reduces the possibility of
+# memory fragmentation problems, but involves extra code and
+# processor cycles.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE
+    #     Requires: CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE
+};
+
+# <
+# Doug Lea's malloc
+# This component contains configuration options related to the 
+# port of Doug Lea's memory allocator, normally known as
+# dlmalloc. dlmalloc has a reputation for being both fast
+# and space-conserving, as well as resisting fragmentation well.
+# It is a common choice for a general purpose allocator and
+# has been used in both newlib and Linux glibc.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_DLMALLOC {
+    # There is no associated value.
+};
+
+# >
+# Debug build
+# Doug Lea's malloc implementation has substantial amounts
+# of internal checking in order to verify the operation
+# and consistency of the allocator. However this imposes
+# substantial overhead on each operation. Therefore this
+# checking may be individually disabled.
+#
+cdl_option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 != CYGDBG_USE_ASSERTS 
+    #     CYGDBG_USE_ASSERTS == 0
+    #   --> 0
+    # Requires: CYGDBG_USE_ASSERTS
+    #     CYGDBG_USE_ASSERTS == 0
+    #   --> 0
+};
+
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_THREADAWARE {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+};
+
+# Support more than one instance
+# Having this option disabled allows important
+# implementation structures to be declared as a single
+# static instance, allowing faster access. However this
+# would fail if there is more than one instance of
+# the dlmalloc allocator class. Therefore this option can
+# be enabled if multiple instances are required. Note: as
+# a special case, if this allocator is used as the
+# implementation of malloc, and it can be determined there
+# is more than one malloc pool, then this option will be
+# silently enabled.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use system memcpy() and memset()
+# This may be used to control whether memset() and memcpy()
+# are used within the implementation. The alternative is
+# to use some macro equivalents, which some people report
+# are faster in some circumstances.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_ISOINFRA 
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+};
+
+# Minimum alignment of allocated blocks
+# This option controls the minimum alignment that the
+# allocated memory blocks are aligned on, specified as
+# 2^N. Note that using large mininum alignments can lead
+# to excessive memory wastage.
+#
+cdl_option CYGNUM_MEMALLOC_ALLOCATOR_DLMALLOC_ALIGNMENT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value: 3
+    # Legal values: 3 to 10
+};
+
+# <
+# Variable block allocator with separate metadata
+# This component contains configuration options related to the 
+# variable block memory allocator with separate metadata.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_SEPMETA {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_SEPMETA_THREADAWARE {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# <
+# Kernel C API support for memory allocation
+# This option must be enabled to provide the extensions required
+# to support integration into the kernel C API.
+#
+cdl_option CYGFUN_MEMALLOC_KAPI {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGFUN_KERNEL_API_C
+    #     CYGFUN_KERNEL_API_C == 1
+    #   --> 1
+};
+
+# malloc(0) returns NULL
+# This option controls the behavior of malloc(0) ( or calloc with
+# either argument 0 ). It is permitted by the standard to return
+# either a NULL pointer or a unique pointer. Enabling this option
+# forces a NULL pointer to be returned.
+#
+cdl_option CYGSEM_MEMALLOC_MALLOC_ZERO_RETURNS_NULL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Breakpoint site when running out of memory
+# Whenever the system runs out of memory, it invokes this function
+# before either going to sleep waiting for memory to become 
+# available or returning failure.
+#
+cdl_option CYGSEM_MEMALLOC_INVOKE_OUT_OF_MEMORY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# malloc() and supporting allocators
+# This component enables support for dynamic memory
+# allocation as supplied by the functions malloc(),
+# free(), calloc() and realloc(). As these
+# functions are often used, but can have quite an
+# overhead, disabling them here can ensure they
+# cannot even be used accidentally when static
+# allocation is preferred. Within this component are
+# various allocators that can be selected for use
+# as the underlying implementation of the dynamic
+# allocation functions.
+#
+cdl_component CYGPKG_MEMALLOC_MALLOC_ALLOCATORS {
+    # ActiveIf constraint: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Use external heap definition
+# This option allows other components in the
+# system to override the default system
+# provision of heap memory pools. This should
+# be set to a header which provides the equivalent
+# definitions to <pkgconf/heaps.hxx>.
+#
+cdl_component CYGBLD_MEMALLOC_MALLOC_EXTERNAL_HEAP_H {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# malloc() allocator implementations
+#
+cdl_interface CYGINT_MEMALLOC_MALLOC_ALLOCATORS {
+    # Implemented by CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE, active, disabled
+    # Implemented by CYGIMP_MEMALLOC_MALLOC_DLMALLOC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1 
+    #     CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_MEMALLOC_MALLOC_ALLOCATORS
+    #     Requires:  CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1 
+};
+
+# malloc() implementation instantiation data
+# Memory allocator implementations that are capable of being
+# used underneath malloc() must be instantiated. The code
+# to do this is set in this option. It is only intended to
+# be set by the implementation, not the user.
+#
+cdl_option CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value <cyg/memalloc/dlmalloc.hxx>
+    # value_source default
+    # Default value: <cyg/memalloc/dlmalloc.hxx>
+
+    # The following properties are affected by this value
+    # option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE
+    #     Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/memvar.hxx>" 
+    # option CYGIMP_MEMALLOC_MALLOC_DLMALLOC
+    #     Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/dlmalloc.hxx>" 
+};
+
+# Simple variable block implementation
+# This causes malloc() to use the simple
+# variable block allocator.
+#
+cdl_option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/memvar.hxx>" 
+    #     CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER == <cyg/memalloc/dlmalloc.hxx>
+    #   --> 0
+    # Requires: CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE
+    #     CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE == 1
+    #   --> 1
+};
+
+# Doug Lea's malloc implementation
+# This causes malloc() to use a version of Doug Lea's
+# malloc (dlmalloc) as the underlying implementation.
+#
+cdl_option CYGIMP_MEMALLOC_MALLOC_DLMALLOC {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/dlmalloc.hxx>" 
+    #     CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER == <cyg/memalloc/dlmalloc.hxx>
+    #   --> 1
+};
+
+# <
+# Size of the fallback dynamic memory pool in bytes
+# If *no* heaps are configured in your memory layout,
+# dynamic memory allocation by
+# malloc() and calloc() must be from a fixed-size,
+# contiguous memory pool (note here that it is the
+# pool that is of a fixed size, but malloc() is still
+# able to allocate variable sized chunks of memory
+# from it). This option is the size
+# of that pool, in bytes. Note that not all of
+# this is available for programs to
+# use - some is needed for internal information
+# about memory regions, and some may be lost to
+# ensure that memory allocation only returns
+# memory aligned on word (or double word)
+# boundaries - a very common architecture
+# constraint.
+#
+cdl_option CYGNUM_MEMALLOC_FALLBACK_MALLOC_POOL_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16384
+    # value_source default
+    # Default value: 16384
+    # Legal values: 32 to 0x7fffffff
+};
+
+# Common memory allocator package build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_MEMALLOC_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_MEMALLOC_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_MEMALLOC_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Tests
+# This option specifies the set of tests for this package.
+#
+cdl_option CYGPKG_MEMALLOC_TESTS {
+    # Calculated value:  "tests/dlmalloc1 tests/dlmalloc2 tests/heaptest tests/kmemfix1 tests/kmemvar1 tests/malloc1 tests/malloc2 tests/malloc3 tests/malloc4 tests/memfix1 tests/memfix2 tests/memvar1 tests/memvar2 tests/realloc tests/sepmeta1 tests/sepmeta2" 
+    # Flavor: data
+    # Current_value: tests/dlmalloc1 tests/dlmalloc2 tests/heaptest tests/kmemfix1 tests/kmemvar1 tests/malloc1 tests/malloc2 tests/malloc3 tests/malloc4 tests/memfix1 tests/memfix2 tests/memvar1 tests/memvar2 tests/realloc tests/sepmeta1 tests/sepmeta2
+};
+
+# <
+# <
+# ISO C library
+# doc: ref/libc.html
+# The packages under this package enable compatibility with the ISO C
+# standard - ISO/IEC 9899:1990. This allows the user application to use
+# well known standard C library functions, and in eCos starts a thread
+# to invoke the user function main(). This package is a top-level placeholder
+# to contain the implementations.
+#
+cdl_package CYGPKG_LIBC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # component CYGNUM_LIBM_COMPATIBILITY
+    #     Requires: CYGPKG_LIBC
+};
+
+# >
+# ISO C library date and time functions
+# doc: ref/libc.html
+# This package provides time functions specified by the
+# ISO C standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_TIME {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires:  CYGBLD_ISO_C_TIME_TYPES_HEADER == "<cyg/libc/time/time.h>" 
+    #     CYGBLD_ISO_C_TIME_TYPES_HEADER == <cyg/libc/time/time.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_C_CLOCK_FUNCS_HEADER ==  "<cyg/libc/time/time.h>" 
+    #     CYGBLD_ISO_C_CLOCK_FUNCS_HEADER == <cyg/libc/time/time.h>
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGINT_ISO_DIV
+    #     CYGINT_ISO_DIV == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ABS
+    #     CYGINT_ISO_ABS == 1
+    #   --> 1
+};
+
+# >
+# Working clock() function
+# This option controls whether clock() will
+# actually try and determine the process time
+# usage. With this option disabled, clock() does
+# not disappear, but will permanently return
+# (clock_t)-1 as mandated by the ISO C standard.
+#
+cdl_option CYGSEM_LIBC_TIME_CLOCK_WORKING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_KERNEL_THREADS_TIMER
+    #     CYGFUN_KERNEL_THREADS_TIMER == 1
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+};
+
+# Working time() function
+# This option controls whether time() will
+# actually try and determine the current calendar
+# time. With this option disabled, time() does
+# not disappear, but will permanently return
+# (time_t)-1 as mandated by the ISO C standard.
+#
+cdl_option CYGSEM_LIBC_TIME_TIME_WORKING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK == current
+    #   --> 1
+};
+
+# Working cyg_libc_time_settime() function
+# This option controls whether cyg_libc_time_settime()
+# will actually try and set the current calendar
+# time. With this option disabled,
+# cyg_libc_time_settime() does not disappear, but
+# will permanently return an error.
+#
+cdl_option CYGSEM_LIBC_TIME_SETTIME_WORKING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK == current
+    #   --> 1
+};
+
+# POSIX time functions
+# Enabling this option allows the use of the
+# following functions defined in POSIX 1003.1:
+# asctime_r(), ctime_r(), gmtime_r(), strptime(), and
+# localtime_r().
+#
+cdl_option CYGFUN_LIBC_TIME_POSIX {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGINT_ISO_STRING_BSD_FUNCS
+    #     CYGINT_ISO_STRING_BSD_FUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGIMP_LIBC_TIME_ASCTIME_R_INLINE
+    #     Requires: CYGFUN_LIBC_TIME_POSIX
+    # option CYGIMP_LIBC_TIME_CTIME_R_INLINE
+    #     Requires: CYGFUN_LIBC_TIME_POSIX
+    # option CYGIMP_LIBC_TIME_GMTIME_R_INLINE
+    #     Requires: CYGFUN_LIBC_TIME_POSIX
+    # option CYGIMP_LIBC_TIME_LOCALTIME_R_INLINE
+    #     Requires: CYGFUN_LIBC_TIME_POSIX
+    # option CYGPKG_LIBC_TIME_TESTS
+    #     Calculated:  
+    #                     "tests/asctime tests/clock tests/ctime tests/gmtime tests/localtime tests/mktime tests/strftime tests/time " 
+    #                     . (CYGFUN_LIBC_TIME_POSIX ? "tests/strptime" : "")
+    #                 
+};
+
+# Single UNIX extensions
+# Enabling this option allows the use of
+# certain additional conversion specifiers
+# in the strftime function.
+#
+cdl_option CYGFUN_LIBC_TIME_SUS_EXTNS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Time zone offsets
+# These options control the default STandarD (STD)
+# and Daylight Savings Time (DST)
+# time offsets so that dates can be set correctly
+# for the local environment.
+#
+cdl_component CYGPKG_LIBC_TIME_ZONES {
+    # There is no associated value.
+};
+
+# >
+# Default Daylight Savings Time state
+# This option controls whether the initial
+# time environment is set up as STD, DST or
+# unknown. Use the value 1 for DST, 0 for STD, 
+# and (-1) for unknown. This can also be set at
+# runtime using the cyg_libc_time_setdst()
+# function.
+#
+cdl_option CYGNUM_LIBC_TIME_DST_DEFAULT_STATE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -1
+    # value_source default
+    # Default value: -1
+    # Legal values: -1 to 1
+};
+
+# Default Standard Time offset
+# This option controls the offset from UTC in
+# seconds when in local Standard Time. This
+# value can be positive or negative. It
+# can also be set at run time using the
+# cyg_libc_time_setzoneoffsets() function.
+#
+cdl_option CYGNUM_LIBC_TIME_STD_DEFAULT_OFFSET {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: -90000 to 90000
+};
+
+# Default Daylight Savings Time offset
+# This option controls the offset from UTC in
+# seconds when in local Daylight Savings Time. This
+# value can be positive or negative. It
+# can also be set at run time using the
+# cyg_libc_time_setzoneoffsets() function.
+#
+cdl_option CYGNUM_LIBC_TIME_DST_DEFAULT_OFFSET {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3600
+    # value_source default
+    # Default value: 3600
+    # Legal values: -90000 to 90000
+};
+
+# <
+# Inline functions
+# These options control whether certain functions
+# are available in inline form. This may lead to
+# faster code at the expense of code space. But for
+# some functions, or some functions with constant
+# arguments, it may in fact lead to smaller code.
+#
+cdl_component CYGPKG_LIBC_TIME_INLINES {
+    # There is no associated value.
+};
+
+# >
+# asctime()
+# Allow the asctime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_ASCTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# ctime()
+# Allow the ctime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_CTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# difftime()
+# Allow the difftime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_DIFFTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# gmtime()
+# Allow the gmtime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_GMTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# localtime()
+# Allow the localtime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_LOCALTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# mktime()
+# Allow the mktime() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_MKTIME_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# asctime_r()
+# Allow the asctime_r() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_ASCTIME_R_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_LIBC_TIME_POSIX
+    #     CYGFUN_LIBC_TIME_POSIX == 1
+    #   --> 1
+};
+
+# ctime_r()
+# Allow the ctime_r() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_CTIME_R_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_LIBC_TIME_POSIX
+    #     CYGFUN_LIBC_TIME_POSIX == 1
+    #   --> 1
+};
+
+# gmtime_r()
+# Allow the gmtime_r() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_GMTIME_R_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGFUN_LIBC_TIME_POSIX
+    #     CYGFUN_LIBC_TIME_POSIX == 1
+    #   --> 1
+};
+
+# localtime_r()
+# Allow the localtime_r() function to be inlined
+#
+cdl_option CYGIMP_LIBC_TIME_LOCALTIME_R_INLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_LIBC_TIME_POSIX
+    #     CYGFUN_LIBC_TIME_POSIX == 1
+    #   --> 1
+};
+
+# <
+# clock() tracing level
+# Trace verbosity level for debugging the clock()
+# function. Increase this value to get
+# additional trace output when tracing is enabled.
+#
+cdl_option CYGNUM_LIBC_TIME_CLOCK_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# C library time functions build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_TIME_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_TIME_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wno-format
+    # value_source default
+    # Default value: -Wno-format
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_TIME_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library time and date function tests
+# This option specifies the set of tests for the C library
+# time and date functions.
+#
+cdl_option CYGPKG_LIBC_TIME_TESTS {
+    # Calculated value:  
+    #                     "tests/asctime tests/clock tests/ctime tests/gmtime tests/localtime tests/mktime tests/strftime tests/time " 
+    #                     . (CYGFUN_LIBC_TIME_POSIX ? "tests/strptime" : "")
+    #                 
+    #     CYGFUN_LIBC_TIME_POSIX == 1
+    # Flavor: data
+    # Current_value: tests/asctime tests/clock tests/ctime tests/gmtime tests/localtime tests/mktime tests/strftime tests/time tests/strptime
+};
+
+# <
+# <
+# ISO C library general utility functions
+# doc: ref/libc.html
+# This package provides general utility functions in <stdlib.h>
+# as specified by the ISO C standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_STDLIB {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGINT_ISO_CTYPE
+    #     CYGINT_ISO_CTYPE == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+};
+
+# >
+# Inline versions of <stdlib.h> functions
+# This option chooses whether some of the
+# particularly simple standard utility functions
+# from <stdlib.h> are available as inline
+# functions. This may improve performance, and as
+# the functions are small, may even improve code
+# size.
+#
+cdl_component CYGIMP_LIBC_STDLIB_INLINES {
+    # There is no associated value.
+};
+
+# >
+# abs() / labs()
+#
+cdl_option CYGIMP_LIBC_STDLIB_INLINE_ABS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STDLIB_ABS_HEADER ==  "<cyg/libc/stdlib/abs.inl>" 
+    #     CYGBLD_ISO_STDLIB_ABS_HEADER == <cyg/libc/stdlib/abs.inl>
+    #   --> 1
+};
+
+# div() / ldiv()
+#
+cdl_option CYGIMP_LIBC_STDLIB_INLINE_DIV {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STDLIB_DIV_HEADER ==  "<cyg/libc/stdlib/div.inl>" 
+    #     CYGBLD_ISO_STDLIB_DIV_HEADER == <cyg/libc/stdlib/div.inl>
+    #   --> 1
+};
+
+# atof() / atoi() / atol()
+#
+cdl_option CYGIMP_LIBC_STDLIB_INLINE_ATOX {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STDLIB_STRCONV_HEADER ==  "<cyg/libc/stdlib/atox.inl>" 
+    #     CYGBLD_ISO_STDLIB_STRCONV_HEADER == <cyg/libc/stdlib/atox.inl>
+    #   --> 1
+};
+
+# <
+# Random number generation
+# These options control the behaviour of the
+# functions rand(), srand() and rand_r()
+#
+cdl_component CYGPKG_LIBC_RAND {
+    # There is no associated value.
+};
+
+# >
+# Per-thread random seed
+# doc: ref/libc-thread-safety.html
+# This option controls whether the pseudo-random
+# number generation functions rand() and srand()
+# have their state recorded on a per-thread
+# basis rather than global. If this option is
+# disabled, some per-thread space can be saved.
+# Note there is also a POSIX-standard rand_r()
+# function to achieve a similar effect with user
+# support. Enabling this option will use one slot
+# of kernel per-thread data. You should ensure you
+# have enough slots configured for all your
+# per-thread data.
+#
+cdl_option CYGSEM_LIBC_PER_THREAD_RAND {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+};
+
+# Random number seed
+# This selects the initial random number seed for
+# rand()'s pseudo-random number generator. For
+# strict ISO standard compliance, this should be 1,
+# as per section 7.10.2.2 of the standard.
+#
+cdl_option CYGNUM_LIBC_RAND_SEED {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Legal values: 0 to 0x7fffffff
+};
+
+# Tracing level
+# Trace verbosity level for debugging the rand(),
+# srand() and rand_r() functions. Increase this
+# value to get additional trace output.
+#
+cdl_option CYGNUM_LIBC_RAND_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# Simplest implementation
+# This provides a very simple implementation of rand()
+# that does not perform well with randomness in the
+# lower significant bits. However it is exceptionally
+# fast. It uses the sample algorithm from the ISO C
+# standard itself.
+#
+cdl_option CYGIMP_LIBC_RAND_SIMPLEST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Simple implementation #1
+# This provides a very simple implementation of rand()
+# based on the simplest implementation above. However
+# it does try to work around the lack of randomness
+# in the lower significant bits, at the expense of a
+# little speed.
+#
+cdl_option CYGIMP_LIBC_RAND_SIMPLE1 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Knuth implementation #1
+# This implements a slightly more complex algorithm
+# published in Donald E. Knuth's Art of Computer
+# Programming Vol.2 section 3.6 (p.185 in the 3rd ed.).
+# This produces better random numbers than the
+# simplest approach but is slower.
+#
+cdl_option CYGIMP_LIBC_RAND_KNUTH1 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Provides strtod()
+# This option allows use of the utility function
+# strtod() (and consequently atof()) to convert
+# from string to double precision floating point
+# numbers. Disabling this option removes the
+# dependency on the math library package.
+#
+cdl_option CYGFUN_LIBC_strtod {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_LIBM 
+    #     CYGPKG_LIBM == current
+    #   --> 1
+    # Requires: CYGPKG_LIBM
+    #     CYGPKG_LIBM == current
+    #   --> 1
+};
+
+# Provides long long conversion functions
+# Enabling this option will provide support for the strtoll(),
+# strtoull() and atoll() conversion functions, which are
+# the long long variants of the standard versions of these
+# functions. Supporting this requires extra code and compile
+# time.
+#
+cdl_option CYGFUN_LIBC_STDLIB_CONV_LONGLONG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGFUN_LIBC_STDIO_LONGLONG
+    #     Requires: CYGFUN_LIBC_STDLIB_CONV_LONGLONG
+};
+
+# bsearch() tracing level
+# Trace verbosity level for debugging the <stdlib.h>
+# binary search function bsearch(). Increase this
+# value to get additional trace output.
+#
+cdl_option CYGNUM_LIBC_BSEARCH_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# qsort() tracing level
+# Trace verbosity level for debugging the <stdlib.h>
+# quicksort function qsort(). Increase this value
+# to get additional trace output.
+#
+cdl_option CYGNUM_LIBC_QSORT_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# C library stdlib build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_STDLIB_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_STDLIB_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_STDLIB_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library stdlib tests
+# This option specifies the set of tests for this package.
+#
+cdl_option CYGPKG_LIBC_STDLIB_TESTS {
+    # Calculated value:  "tests/abs tests/atoi tests/atol tests/bsearch tests/div tests/getenv tests/labs tests/ldiv tests/qsort tests/rand1 tests/rand2 tests/rand3 tests/rand4 tests/srand tests/strtol tests/strtoul" 
+    # Flavor: data
+    # Current_value: tests/abs tests/atoi tests/atol tests/bsearch tests/div tests/getenv tests/labs tests/ldiv tests/qsort tests/rand1 tests/rand2 tests/rand3 tests/rand4 tests/srand tests/strtol tests/strtoul
+};
+
+# <
+# <
+# ISO C library string functions
+# doc: ref/libc.html
+# This package provides string functions specified by the
+# ISO C standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_STRING {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires:  CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRING_MEMFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_MEMFUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRING_STRFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_STRFUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRTOK_R_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRTOK_R_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+};
+
+# >
+# Inline versions of <string.h> functions
+# This option chooses whether some of the
+# particularly simple string functions from
+# <string.h> are available as inline
+# functions. This may improve performance, and as
+# the functions are small, may even improve code
+# size.
+#
+cdl_option CYGIMP_LIBC_STRING_INLINES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Optimize string functions for code size
+# This option tries to reduce string function
+# code size at the expense of execution speed. The
+# same effect can be produced if the code is
+# compiled with the -Os option to the compiler.
+#
+cdl_option CYGIMP_LIBC_STRING_PREFER_SMALL_TO_FAST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide BSD compatibility functions
+# Enabling this option causes various compatibility functions
+# commonly found in the BSD UNIX operating system to be included.
+# These are functions such as bzero, bcmp, bcopy, bzero, strcasecmp,
+# strncasecmp, index, rindex and swab.
+#
+cdl_option CYGFUN_LIBC_STRING_BSD_FUNCS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STRING_BSD_FUNCS_HEADER ==  "<cyg/libc/string/bsdstring.h>" 
+    #     CYGBLD_ISO_STRING_BSD_FUNCS_HEADER == <cyg/libc/string/bsdstring.h>
+    #   --> 1
+    # Requires: CYGINT_ISO_CTYPE
+    #     CYGINT_ISO_CTYPE == 1
+    #   --> 1
+};
+
+# strtok
+# These options control the behaviour of the
+# strtok() and strtok_r() string tokenization
+# functions.
+#
+cdl_component CYGPKG_LIBC_STRING_STRTOK {
+    # There is no associated value.
+};
+
+# >
+# Per-thread strtok()
+# This option controls whether the string function
+# strtok() has its state recorded on a per-thread
+# basis rather than global. If this option is
+# disabled, some per-thread space can be saved.
+# Note there is also a POSIX-standard strtok_r()
+# function to achieve a similar effect with user
+# support. Enabling this option will use one slot
+# of kernel per-thread data. You should ensure you
+# have enough slots configured for all your
+# per-thread data.
+#
+cdl_option CYGSEM_LIBC_STRING_PER_THREAD_STRTOK {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+};
+
+# Tracing level
+# Trace verbosity level for debugging the <string.h>
+# functions strtok() and strtok_r(). Increase this
+# value to get additional trace output.
+#
+cdl_option CYGNUM_LIBC_STRING_STRTOK_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# <
+# strdup
+# This option indicates whether strdup() is to be supported.
+#
+cdl_option CYGFUN_LIBC_STRING_STRDUP {
+    # ActiveIf constraint: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# C library string functions build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_STRING_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_STRING_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_STRING_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library string function tests
+# This option specifies the set of tests for the C library
+# string functions.
+#
+cdl_option CYGPKG_LIBC_STRING_TESTS {
+    # Calculated value:  "tests/memchr tests/memcmp1 tests/memcmp2 tests/memcpy1 tests/memcpy2 tests/memmove1 tests/memmove2 tests/memset tests/strcat1 tests/strcat2 tests/strchr tests/strcmp1 tests/strcmp2 tests/strcoll1 tests/strcoll2 tests/strcpy1 tests/strcpy2 tests/strcspn tests/strcspn tests/strlen tests/strncat1 tests/strncat2 tests/strncpy1 tests/strncpy2 tests/strpbrk tests/strrchr tests/strspn tests/strstr tests/strtok tests/strxfrm1 tests/strxfrm2" 
+    # Flavor: data
+    # Current_value: tests/memchr tests/memcmp1 tests/memcmp2 tests/memcpy1 tests/memcpy2 tests/memmove1 tests/memmove2 tests/memset tests/strcat1 tests/strcat2 tests/strchr tests/strcmp1 tests/strcmp2 tests/strcoll1 tests/strcoll2 tests/strcpy1 tests/strcpy2 tests/strcspn tests/strcspn tests/strlen tests/strncat1 tests/strncat2 tests/strncpy1 tests/strncpy2 tests/strpbrk tests/strrchr tests/strspn tests/strstr tests/strtok tests/strxfrm1 tests/strxfrm2
+};
+
+# <
+# <
+# ISO C library internationalization functions
+# doc: ref/libc.html
+# This package provides internationalization functions specified by the
+# ISO C standard - ISO/IEC 9899:1990. These include locale-related
+# functionality and <ctype.h> functionality.
+#
+cdl_package CYGPKG_LIBC_I18N {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires: CYGPKG_LIBC_I18N
+};
+
+# >
+# Supported locales
+# These options determine which locales other than the "C" locale
+# are supported and hence contribute to the size of the executable.
+#
+cdl_component CYGPKG_LIBC_I18N_LOCALES {
+    # There is no associated value.
+};
+
+# >
+# Support for multiple locales required
+#
+cdl_interface CYGINT_LIBC_I18N_MB_REQUIRED {
+    # Implemented by CYGFUN_LIBC_I18N_LOCALE_C_SJIS, active, disabled
+    # Implemented by CYGFUN_LIBC_I18N_LOCALE_C_JIS, active, disabled
+    # Implemented by CYGFUN_LIBC_I18N_LOCALE_C_EUCJP, active, disabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  CYGBLD_ISO_STDLIB_MB_CUR_MAX_HEADER ==  "<cyg/libc/i18n/mb.h>" 
+    #     CYGBLD_ISO_STDLIB_MB_CUR_MAX_HEADER == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+};
+
+# C-SJIS locale support
+# This option controls if the "C-SJIS" locale will be
+# supported by setlocale().  The locale is a hybrid locale
+# that is mostly the "C" locale with Japanese SJIS multibyte
+# support added.
+#
+cdl_option CYGFUN_LIBC_I18N_LOCALE_C_SJIS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     LegalValues:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2))) to 0x7fffffff 
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     DefaultValue:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2)))  
+};
+
+# C-JIS locale support
+# This option controls if the "C-JIS" locale will be
+# supported by setlocale().  The locale is a hybrid locale
+# that is mostly the "C" locale with Japanese JIS multibyte
+# support added.
+#
+cdl_option CYGFUN_LIBC_I18N_LOCALE_C_JIS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     LegalValues:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2))) to 0x7fffffff 
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     DefaultValue:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2)))  
+};
+
+# C-EUCJP locale support
+# This option controls if the "C-EUCJP" locale will be
+# supported by setlocale().  The locale is a hybrid locale
+# that is mostly the "C" locale with Japanese EUCJP multibyte
+# support added.
+#
+cdl_option CYGFUN_LIBC_I18N_LOCALE_C_EUCJP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     LegalValues:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2))) to 0x7fffffff 
+    # option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE
+    #     DefaultValue:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2)))  
+};
+
+# <
+# Newlib's ctype implementation
+# This option enables the implementation of the ctype functions
+# that comes with newlib. It is table driven and therefore
+# exhibits different performance characteristics. It also offers
+# a limited amount of binary compatibility
+# with newlib so that programs linked against newlib ctype/locale
+# do not need to be recompiled when linked with eCos.
+#
+cdl_option CYGPKG_LIBC_I18N_NEWLIB_CTYPE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYGBLD_ISO_CTYPE_HEADER ==  "<cyg/libc/i18n/newlibctype.h>" 
+    #     CYGBLD_ISO_CTYPE_HEADER == <cyg/libc/i18n/ctype.inl>
+    #   --> 0
+};
+
+# Per-thread multibyte state
+# This option controls whether the multibyte character
+# handling functions mblen(), mbtowc(), and wctomb(),
+# have their state recorded on a per-thread
+# basis rather than global. If this option is
+# disabled, some per-thread space can be saved.
+# Enabling this option will use three slots
+# of kernel per-thread data. You should ensure you
+# have enough slots configured for all your
+# per-thread data.
+#
+cdl_option CYGSEM_LIBC_I18N_PER_THREAD_MB {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGVAR_KERNEL_THREADS_DATA != 0 
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+};
+
+# Size of locale name strings
+# This option controls the maximum size of
+# locale names and is used, among other things
+# to instantiate a static string used
+# as a return value from the
+# setlocale() function. When requesting the
+# current locale settings with LC_ALL, a string
+# must be constructed to contain this data, rather
+# than just returning a constant string. This
+# string data is stored in the static string.
+# This depends on the length of locale names,
+# hence this option. If just the C locale is
+# present, this option can be set as low as 2.
+#
+cdl_option CYGNUM_LIBC_I18N_MAX_LOCALE_NAME_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2
+    # value_source default
+    # Default value:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2)))  
+    #     CYGFUN_LIBC_I18N_LOCALE_C_EUCJP == 0
+    #     CYGFUN_LIBC_I18N_LOCALE_C_SJIS == 0
+    #     CYGFUN_LIBC_I18N_LOCALE_C_JIS == 0
+    #   --> 2
+    # Legal values:  (CYGFUN_LIBC_I18N_LOCALE_C_EUCJP ? 8 :  (CYGFUN_LIBC_I18N_LOCALE_C_SJIS ? 7 :   (CYGFUN_LIBC_I18N_LOCALE_C_JIS ? 6 : 2))) to 0x7fffffff 
+    #     CYGFUN_LIBC_I18N_LOCALE_C_EUCJP == 0
+    #     CYGFUN_LIBC_I18N_LOCALE_C_SJIS == 0
+    #     CYGFUN_LIBC_I18N_LOCALE_C_JIS == 0
+};
+
+# Inline versions of <ctype.h> functions
+# This option chooses whether the simple character
+# classification and conversion functions (e.g.
+# isupper(), isalpha(), toupper(), etc.)
+# from <ctype.h> are available as inline
+# functions. This may improve performance and as
+# the functions are small, may even improve code
+# size.
+#
+cdl_option CYGIMP_LIBC_I18N_CTYPE_INLINES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_CTYPE_HEADER ==  "<cyg/libc/i18n/ctype.inl>" 
+    #     CYGBLD_ISO_CTYPE_HEADER == <cyg/libc/i18n/ctype.inl>
+    #   --> 1
+};
+
+# C library i18n functions build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_I18N_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_I18N_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_I18N_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library i18n function tests
+# This option specifies the set of tests for the C library
+# i18n functions.
+#
+cdl_option CYGPKG_LIBC_I18N_TESTS {
+    # Calculated value:  "tests/ctype tests/setlocale tests/i18nmb" 
+    # Flavor: data
+    # Current_value: tests/ctype tests/setlocale tests/i18nmb
+};
+
+# <
+# <
+# ISO C library setjmp/longjmp functions
+# doc: ref/libc.html
+# This package provides non-local jumps based on setjmp() and
+# longjmp() in <setjmp.h> as specified by the ISO C
+# standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_SETJMP {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires:  CYGBLD_ISO_SETJMP_HEADER == "<cyg/libc/setjmp/setjmp.h>" 
+    #     CYGBLD_ISO_SETJMP_HEADER == <cyg/libc/setjmp/setjmp.h>
+    #   --> 1
+};
+
+# >
+# C library setjmp build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_SETJMP_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_SETJMP_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_SETJMP_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library setjmp tests
+# This option specifies the set of tests for this package.
+#
+cdl_option CYGPKG_LIBC_SETJMP_TESTS {
+    # Calculated value:  "tests/setjmp" 
+    # Flavor: data
+    # Current_value: tests/setjmp
+};
+
+# <
+# <
+# ISO environment startup/termination
+# doc: ref/c-library-startup.html
+# This package manages the control of the
+# environment (in the general sense) that an
+# application would require for full ISO C / POSIX
+# compatibility, including a main() entry point
+# supplied with arguments and an environment
+# (as retrievable by the getenv() function).
+# It also includes at the other end of things,
+# what happens when main() returns or exit() is
+# called.
+#
+cdl_package CYGPKG_LIBC_STARTUP {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires:  CYGINT_LIBC_STARTUP_CONTEXT == 1 
+    #     CYGINT_LIBC_STARTUP_CONTEXT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_MAIN_THREAD
+    #     Requires:  0 != CYGPKG_LIBC_STARTUP 
+};
+
+# >
+# main() can be invoked elsewhere
+# Implementors of this interface show that they
+# allow main() to be invoked elsewhere.
+#
+cdl_interface CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE {
+    # Implemented by CYGPKG_POSIX_MAIN_THREAD, active, enabled
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_STARTUP_MAIN_INITCONTEXT
+    #     DefaultValue:  0 == CYGPKG_KERNEL && 0 == 
+    #                                 CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    # component CYGSEM_LIBC_STARTUP_MAIN_THREAD
+    #     DefaultValue:  0 != CYGPKG_KERNEL && 0 ==  CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    # option CYGSEM_LIBC_STARTUP_MAIN_OTHER
+    #     DefaultValue:  0 !=  CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    # option CYGSEM_LIBC_STARTUP_MAIN_OTHER
+    #     Requires: CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE
+};
+
+# Arguments to main()
+# This option allows the setting of the arguments
+# to the main function. This only has any effect
+# when cyg_iso_c_start() is used to start the
+# ISO C compatibility. This will automatically
+# invoke main() in an ISO C compatible fashion.
+# This option is in fact used as argv, and so is
+# an n-tuple of string constants. The final
+# entry must be NULL. Conventionally if argv[0]
+# is supplied, it is used to inform the program
+# of its name.
+#
+cdl_option CYGDAT_LIBC_ARGUMENTS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "{\"\", NULL}"
+    # value_source default
+    # Default value: "{\"\", NULL}"
+};
+
+# Startup context for main()
+# This component describes the options available for
+# what context main() is invoked in, such as in a thread
+# etc.
+#
+cdl_component CYGPKG_LIBC_STARTUP_CONTEXT {
+    # There is no associated value.
+};
+
+# >
+# Startup context implementors
+#
+cdl_interface CYGINT_LIBC_STARTUP_CONTEXT {
+    # Implemented by CYGSEM_LIBC_STARTUP_MAIN_INITCONTEXT, active, disabled
+    # Implemented by CYGSEM_LIBC_STARTUP_MAIN_THREAD, active, disabled
+    # Implemented by CYGSEM_LIBC_STARTUP_MAIN_OTHER, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STARTUP
+    #     Requires:  CYGINT_LIBC_STARTUP_CONTEXT == 1 
+};
+
+# Invoked from initialization context
+# With this option selected, main() will be
+# called via cyg_user_start() (unless the program
+# overrides the default cyg_user_start()). This
+# means it is run in the context of the system
+# initialization code, without the eCos kernel
+# scheduler running, and using the startup stack.
+# This means that any functions that may require 
+# interactions with a running kernel will not
+# work (including libc functions, if configured
+# to be thread safe for example), so you should
+# restrict yourself to only calling fully
+# re-entrant functions from within main() in
+# this case.
+#
+cdl_option CYGSEM_LIBC_STARTUP_MAIN_INITCONTEXT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 == CYGPKG_KERNEL && 0 == 
+    #                                 CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    #     CYGPKG_KERNEL == current
+    #     CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE == 1
+    #   --> 0
+};
+
+# Invoked as eCos thread
+# With this option selected, main() is invoked from an eCos
+# thread.
+#
+cdl_component CYGSEM_LIBC_STARTUP_MAIN_THREAD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 != CYGPKG_KERNEL && 0 ==  CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    #     CYGPKG_KERNEL == current
+    #     CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE == 1
+    #   --> 0
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     Requires:  CYGSEM_LIBC_STARTUP_MAIN_THREAD ||  (CYGSEM_LIBC_STARTUP_MAIN_OTHER && CYGPKG_POSIX_PTHREAD) 
+};
+
+# >
+# System provides stack for main()'s thread
+# This option controls whether the stack of
+# main()'s thread is provided by the application or
+# provided by the system. When disabled, the
+# application must declare a pointer variable
+# cyg_libc_main_stack which is a pointer to an
+# appropriately aligned region of memory. The
+# application must also declare a variable of
+# type `int' called cyg_libc_main_stack_size
+# which contains the size of the stack in bytes.
+# This must be a multiple of 8.
+#
+cdl_option CYGSEM_LIBC_MAIN_STACK_FROM_SYSTEM {
+    # This option is not active
+    # The parent CYGSEM_LIBC_STARTUP_MAIN_THREAD is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Priority of main()'s thread
+# This option is used to provide the thread
+# priority which main()'s thread runs at. Be
+# sure to check that this number is appropriate
+# for the kernel scheduler chosen. Different
+# kernel schedulers impose different restrictions
+# on the usable priorities.
+#
+cdl_option CYGNUM_LIBC_MAIN_THREAD_PRIORITY {
+    # This option is not active
+    # The parent CYGSEM_LIBC_STARTUP_MAIN_THREAD is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+    # Legal values: 0 to 0x7fffffff
+};
+
+# <
+# Invoked elsewhere
+# With this option selected, main() must be
+# invoked by a separate package, or by the user.
+#
+cdl_option CYGSEM_LIBC_STARTUP_MAIN_OTHER {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 !=  CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE 
+    #     CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE == 1
+    #   --> 1
+    # Requires: CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE
+    #     CYGINT_LIBC_STARTUP_EXTERNAL_INVOKE_MAIN_POSSIBLE == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     Requires:  CYGSEM_LIBC_STARTUP_MAIN_THREAD ||  (CYGSEM_LIBC_STARTUP_MAIN_OTHER && CYGPKG_POSIX_PTHREAD) 
+    # component CYGPKG_POSIX_MAIN_THREAD
+    #     Requires: CYGSEM_LIBC_STARTUP_MAIN_OTHER
+};
+
+# <
+# Don't allow main()'s stack size to be set
+# This interface describes whether the stack size
+# value set in this package is supported by the
+# implementation that invokes main. If not, that
+# option is disabled.
+#
+cdl_interface CYGINT_LIBC_STARTUP_MAIN_NO_STACK_SIZE {
+    # Implemented by CYGSEM_LIBC_STARTUP_MAIN_INITCONTEXT, active, disabled
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE
+    #     ActiveIf: !CYGINT_LIBC_STARTUP_MAIN_NO_STACK_SIZE
+};
+
+# main()'s default thread stack size
+# This option sets the size of the stack used
+# in the context that invokes main(). For example,
+# with an eCos kernel, when the cyg_iso_c_start()
+# function is used to invoke the user-supplied
+# main() function in an ISO C compatible fashion,
+# a separate thread is created to call main().
+# This option controls the size of that thread's
+# stack, which is allocated in the BSS. It
+# must be a multiple of 8. Note, a low number
+# here may be overriden by the HAL if there is
+# a minimum requirement to process interrupts
+# etc. This option cannot be set if the implementation
+# that invokes main() does not use it.
+#
+cdl_option CYGNUM_LIBC_MAIN_DEFAULT_STACK_SIZE {
+    # ActiveIf constraint: !CYGINT_LIBC_STARTUP_MAIN_NO_STACK_SIZE
+    #     CYGINT_LIBC_STARTUP_MAIN_NO_STACK_SIZE == 0
+    #   --> 1
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8192
+    # value_source default
+    # Default value: 8192
+    # Legal values: 16 to 0x7fffffff
+};
+
+# Include atexit() function
+# This option enables the use of the atexit()
+# function, and ensure that the atexit handlers
+# are invoked from within exit() as defined in
+# the ISO C standard.
+#
+cdl_component CYGFUN_LIBC_ATEXIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Number of functions atexit() supports
+# This option sets the number of functions
+# that atexit() has room for. In other words,
+# the number of separate atexit() calls that
+# can be made before calling exit() or returning
+# from main() ( in an environment controlled by
+# cyg_iso_c_start() ). For strict compliance
+# with the ISO C standard this should be at
+# least 32.
+#
+cdl_option CYGNUM_LIBC_ATEXIT_HANDLERS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 1 to 0x7fffffff
+};
+
+# <
+# Make exit() call fflush()
+# This option will ensure that all output
+# streams are flushed when exitting using
+# exit() as prescribed by the ISO C standard.
+#
+cdl_option CYGSEM_LIBC_EXIT_CALLS_FFLUSH {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGINT_ISO_STDIO_FILEACCESS 
+    #     CYGINT_ISO_STDIO_FILEACCESS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STDIO_FILEACCESS
+    #     CYGINT_ISO_STDIO_FILEACCESS == 1
+    #   --> 1
+};
+
+# _exit() stops all threads
+# If this option is enabled then _exit(),
+# which is called from exit() which itself is
+# called on return from main(), stops the eCos
+# scheduler. For strict POSIX 1003.1
+# compatibility this would be the normal
+# behaviour. To allow the thread to simply
+# exit, without affecting other threads, simply
+# leave this option disabled. If there is no eCos
+# scheduler, then _exit() simply loops
+# irrespective of the setting of this option.
+#
+cdl_option CYGSEM_LIBC_EXIT_STOPS_SYSTEM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+};
+
+# Default environment
+# This option allows the setting of the default
+# contents of the environment. This is in fact
+# the contents of the global environment pointer
+# char **environ defined by POSIX 1003.1. Strings
+# must be of the form NAME=VALUE, and the final
+# entry must be NULL.
+#
+cdl_option CYGDAT_LIBC_DEFAULT_ENVIRONMENT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "{ NULL }"
+    # value_source default
+    # Default value: "{ NULL }"
+};
+
+# Invoke default static constructors
+# This option causes the C library to call
+# static constructors with default priority
+# from within the context of the main() thread,
+# working with the co-operation of the HAL.
+# This may be needed for environments that
+# expect static constructors to be run in a
+# thread context. Note that this uses an object
+# with priority 65534. Therefore do not use
+# priority 65534 for any other static objects
+# with this option enabled.
+#
+cdl_option CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG
+    #     CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG == 0
+    #   --> 0
+    # Requires:  CYGSEM_LIBC_STARTUP_MAIN_THREAD ||  (CYGSEM_LIBC_STARTUP_MAIN_OTHER && CYGPKG_POSIX_PTHREAD) 
+    #     CYGSEM_LIBC_STARTUP_MAIN_THREAD == 0
+    #     CYGSEM_LIBC_STARTUP_MAIN_OTHER == 1
+    #     CYGPKG_POSIX_PTHREAD == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG
+    #     Requires: CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+};
+
+# ISO environment startup/termination build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_STARTUP_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_STARTUP_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_STARTUP_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# ISO environment startup/termination tests
+# This option specifies the set of tests for this package.
+#
+cdl_option CYGPKG_LIBC_STARTUP_TESTS {
+    # Calculated value:  "tests/atexit" 
+    # Flavor: data
+    # Current_value: tests/atexit
+};
+
+# <
+# <
+# ISO C library standard input/output functions
+# doc: ref/libc.html
+# This package provides standard input/output functions associated
+# with the header file <stdio.h> as specified by the
+# ISO C standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_STDIO {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_IO
+    #     CYGPKG_IO == current
+    #   --> 1
+    # Requires: CYGPKG_LIBC_I18N
+    #     CYGPKG_LIBC_I18N == current
+    #   --> 1
+    # Requires:  (CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE == "\"/dev/ttydiag\"" ?  CYGPKG_IO_SERIAL_HALDIAG : 1) 
+    #     CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE == "\"/dev/ttydiag\""
+    #     CYGPKG_IO_SERIAL_HALDIAG == 1
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_FILETYPES_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_FILETYPES_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_FILEACCESS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_FILEACCESS_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_FILEPOS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_FILEPOS_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_FILEOPS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_FILEOPS_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_FORMATTED_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_FORMATTED_IO_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_CHAR_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_CHAR_IO_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_DIRECT_IO_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_DIRECT_IO_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_ERROR_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_ERROR_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STDIO_STREAMS_HEADER ==  "<cyg/libc/stdio/stdio.h>" 
+    #     CYGBLD_ISO_STDIO_STREAMS_HEADER == <cyg/libc/stdio/stdio.h>
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO_CODES
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRERROR
+    #     CYGINT_ISO_STRERROR == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_MEMFUNCS
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STDLIB_STRCONV
+    #     CYGINT_ISO_STDLIB_STRCONV == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBM_USE_STDERR
+    #     Requires: CYGPKG_LIBC_STDIO
+};
+
+# >
+# Inline versions of <stdio.h> functions
+# This option chooses whether some of the
+# particularly simple functions from
+# <stdio.h> are available as inline
+# functions. This may improve performance, and as
+# the functions are small, may even improve code
+# size.
+#
+cdl_option CYGIMP_LIBC_STDIO_INLINES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Permitted number of open files
+# This option controls the guaranteed minimum
+# number of simultaneously open files. The ISO
+# C standard requires it to be defined (para
+# 7.9.1), and if strictly compliant, it must be
+# at least 8 (para 7.9.3). In practice it can be
+# as low as 3 - for stdin, stdout and stderr.
+#
+cdl_option FOPEN_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 3 to 0x7fffffff
+};
+
+# Maximum length of filename
+# This option defines the maximum allowed size of
+# a filename in characters. The ISO C standard
+# requires it to be defined (para 7.9.1).
+#
+cdl_option FILENAME_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: 1 to 0x7fffffff
+};
+
+# Maximum length of filenames for temporary files
+# This option defines the maximum allowed size of
+# filenames for temporary files as generated by
+# tmpnam(). It is measured in characters, and the
+# ISO C standard requires it to be defined (para 
+# 7.9.1).
+#
+cdl_option L_tmpnam {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: 4 to 0x7fffffff
+};
+
+# Unique file names generated by tmpnam()
+# This option defines the minimum number of
+# unique file names generated by tmpnam(). The
+# ISO C standard requires it to be defined (para
+# 7.9.1) and for ISO compliance it should be at least
+# 25. Note that TMP_MAX names may not be generated
+# if L_tmpnam is too small.
+#
+cdl_option TMP_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 25
+    # value_source default
+    # Default value: 25
+    # Legal values: 1 to 0x7fffffff
+};
+
+# Buffered I/O
+# This option controls whether input/output
+# through the <stdio.h> functions is buffered.
+# This may save some memory per file. It
+# is equivalent to putting every file into
+# non-buffered mode (_IONBF) through setvbuf(),
+# except now it can never be altered back to
+# buffered mode. Disabling buffering is strictly 
+# non-compliant with the ISO C standard.
+#
+cdl_component CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option BUFSIZ
+    #     Calculated: CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO ? CYGNUM_LIBC_STDIO_BUFSIZE : 0
+    # option CYGPKG_LIBC_STDIO_FILEIO
+    #     Requires: CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
+};
+
+# >
+# Default buffer size
+# This option defines the default size of buffer
+# used with calls to setbuf(), and is the default
+# size for buffered streams that have not had
+# either setbuf() or setvbuf() invoked on them.
+# It is exactly equivalent to the standard
+# constant BUFSIZ, except that it is 0 if
+# CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO is disabled.
+# The ISO C standard requires this to be defined
+# (para 7.9.1), and says it must be at least 256
+# (para 7.9.2).
+#
+cdl_option CYGNUM_LIBC_STDIO_BUFSIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 256
+    # value_source default
+    # Default value: 256
+    # Legal values: 1 to 0x7fffffff
+
+    # The following properties are affected by this value
+    # option BUFSIZ
+    #     Calculated: CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO ? CYGNUM_LIBC_STDIO_BUFSIZE : 0
+};
+
+# setbuf()/setvbuf() allows dynamic setting
+# This option controls whether I/O buffers are
+# implemented dynamically within the stdio
+# implementation. Otherwise they will be static,
+# and cannot be changed by setbuf()/setvbuf(). If
+# they are static (i.e. this option is disabled),
+# any attempt to use an arbitrary buffer size, or
+# to pass a user-supplied buffer to setbuf() or
+# setvbuf() will fail - the buffer is implemented
+# internally as a static array taking the size
+# of the configuration option BUFSIZ. The only
+# exception is if a user buffer is not supplied,
+# and the buffer size requested is less than
+# BUFSIZ. In this case, the buffer will
+# be configured to only use that amount of
+# buffering. However the unused memory left over
+# will NOT be freed. If this option is enabled,
+# then setvbuf() can be used to assign a user supplied
+# buffer to the stream.
+# Either setting can be considered to
+# be compliant with the ISO C standard.
+#
+cdl_option CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBC_STDIO_SETVBUF_MALLOC
+    #     Requires: CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
+    # option CYGPKG_LIBC_STDIO_FILEIO
+    #     Requires: CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
+};
+
+# setbuf()/setvbuf() uses malloc()
+# This option controls whether buffers set by setbuf() and
+# setvbuf() may be allocated using malloc().
+#
+cdl_option CYGSEM_LIBC_STDIO_SETVBUF_MALLOC {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGINT_ISO_MALLOC 
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+    # Requires: CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
+    #     CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF == 1
+    #   --> 1
+};
+
+# <
+# Default buffer size (BUFSIZ)
+#
+cdl_option BUFSIZ {
+    # Calculated value: CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO ? CYGNUM_LIBC_STDIO_BUFSIZE : 0
+    #     CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO == 1
+    #     CYGNUM_LIBC_STDIO_BUFSIZE == 256
+    # Flavor: data
+    # Current_value: 256
+};
+
+# Support for ungetc()
+# This option controls whether ungetc() is
+# supported. If not, then some space can be
+# saved, and speed is improved. Note that you
+# MUST have this defined if you want to use the
+# scanf() family of functions.
+#
+cdl_option CYGFUN_LIBC_STDIO_ungetc {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Dynamic opening/closing of files
+# fopen() and fclose() use dynamic memory
+# allocation routines to allocate memory for
+# new FILE structure pointers. If a malloc
+# implementation is available, this option
+# may be enabled to use
+# fopen() and fclose(). If disabled, only the
+# default console streams - stdin, stdout and
+# stderr - will be available.
+#
+cdl_component CYGPKG_LIBC_STDIO_OPEN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGINT_ISO_MALLOC 
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+};
+
+# >
+# POSIX fdopen/fileno functions
+# This identifies to the rest of the system
+# whether the POSIX fdopen() and
+# fileno() functions are implemented.
+#
+cdl_option CYGFUN_LIBC_STDIO_OPEN_POSIX_FDFUNCS {
+    # ActiveIf constraint: CYGPKG_LIBC_STDIO_FILEIO
+    #     CYGPKG_LIBC_STDIO_FILEIO == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# <
+# Default console device
+# This option allows you to choose the
+# default console device. In the current
+# implementation, all these devices begin
+# with the prefix /dev/ and are followed by
+# the name of a device. The name of the device
+# depends on the device drivers you have
+# configured in your system. For example,
+# /dev/ttydiag could be the HAL diagnostic output
+# pseudo-device, or /dev/tty0 could be your
+# first serial driver, depending on your
+# configuration.
+#
+cdl_option CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE {
+    # Flavor: data
+    user_value "\"/dev/ttydiag\""
+    # value_source user
+    # Default value:  CYGDAT_IO_SERIAL_TTY_CONSOLE ? CYGDAT_IO_SERIAL_TTY_CONSOLE : "\"/dev/null\"" 
+    #     CYGDAT_IO_SERIAL_TTY_CONSOLE == "\"/dev/ttydiag\""
+    #     CYGDAT_IO_SERIAL_TTY_CONSOLE == "\"/dev/ttydiag\""
+    #   --> "\"/dev/ttydiag\""
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STDIO
+    #     Requires:  (CYGDAT_LIBC_STDIO_DEFAULT_CONSOLE == "\"/dev/ttydiag\"" ?  CYGPKG_IO_SERIAL_HALDIAG : 1) 
+};
+
+# Floating point support
+# This component allows floating point support
+# to be enabled in certain standard I/O
+# functions.
+#
+cdl_component CYGPKG_LIBC_STDIO_FLOATING_POINT {
+    # There is no associated value.
+};
+
+# >
+# printf() family
+# This option enables the use of floating point
+# number output in the printf() family (i.e.
+# printf(), sprintf(), vprintf(), etc.) of
+# functions. A substantial amount of code space
+# can be saved if this option is disabled. If it
+# is disabled then floating point specifiers
+# (%e, %f, %g) are ignored, and nothing is
+# output.
+#
+cdl_option CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_LIBM 
+    #     CYGPKG_LIBM == current
+    #   --> 1
+    # Requires: CYGPKG_LIBM
+    #     CYGPKG_LIBM == current
+    #   --> 1
+};
+
+# scanf() family
+# This option enables the use of floating point
+# number conversion in the scanf() family (i.e.
+# scanf(), sscanf(), vscanf(), etc.) of
+# functions. A substantial amount of code space
+# can be saved if this option is disabled. If it
+# is disabled then floating point specifiers
+# (%e, %f, %g) are ignored, and nothing is
+# converted.
+#
+cdl_option CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_LIBM &&
+    #                                 0 != CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+    #     CYGPKG_LIBM == current
+    #     CYGINT_ISO_STDLIB_STRCONV_FLOAT == 1
+    #   --> 1
+    # Requires: CYGPKG_LIBM
+    #     CYGPKG_LIBM == current
+    #   --> 1
+    # Requires: CYGINT_ISO_STDLIB_STRCONV_FLOAT
+    #     CYGINT_ISO_STDLIB_STRCONV_FLOAT == 1
+    #   --> 1
+};
+
+# <
+# Long long support
+# This option allows various functions in the C Standard I/O
+# library to support the 'long long' datatype. Doing so
+# will come with a noticeable code size penalty however.
+#
+cdl_option CYGFUN_LIBC_STDIO_LONGLONG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGFUN_LIBC_STDLIB_CONV_LONGLONG
+    #     CYGFUN_LIBC_STDLIB_CONV_LONGLONG == 1
+    #   --> 1
+};
+
+# Thread safe I/O streams
+# doc: ref/libc-thread-safety.html
+# This option controls whether standard I/O streams
+# are thread-safe. Having this option set allows
+# the streams to be locked when accessed by
+# multiple threads simultaneously.
+#
+cdl_option CYGSEM_LIBC_STDIO_THREAD_SAFE_STREAMS {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Enable use of FILEIO package for IO operations.
+# This CDL exists to control how the standard I/O functions
+# interface to the underlying I/O system. Either using the
+# File I/O package, or the generic I/O package which is used
+# by fewer devices.
+#
+cdl_option CYGPKG_LIBC_STDIO_FILEIO {
+    # ActiveIf constraint: CYGPKG_IO_FILEIO
+    #     CYGPKG_IO_FILEIO == current
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO
+    #     CYGSEM_LIBC_STDIO_WANT_BUFFERED_IO == 1
+    #   --> 1
+    # Requires: CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF
+    #     CYGSEM_LIBC_STDIO_DYNAMIC_SETVBUF == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGFUN_LIBC_STDIO_OPEN_POSIX_FDFUNCS
+    #     ActiveIf: CYGPKG_LIBC_STDIO_FILEIO
+};
+
+# C library stdio functions build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_STDIO_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_STDIO_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_STDIO_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library stdio function tests
+# This option specifies the set of tests for the C library
+# stdio functions.
+#
+cdl_option CYGPKG_LIBC_STDIO_TESTS {
+    # Calculated value:  
+    #                     "tests/sprintf1 tests/sprintf2 tests/sscanf tests/stdiooutput " 
+    #                     . ((CYGPKG_IO_FILEIO && CYGPKG_FS_RAM) ? "tests/fileio " : "")
+    #                 
+    #     CYGPKG_IO_FILEIO == current
+    #     CYGPKG_FS_RAM (unknown) == 0
+    # Flavor: data
+    # Current_value: tests/sprintf1 tests/sprintf2 tests/sscanf tests/stdiooutput 
+};
+
+# <
+# <
+# <
+# Math library
+# doc: ref/libc.html
+# ISO standard floating point mathematical library
+# containing many useful functions for mathematical
+# calculations.
+#
+cdl_package CYGPKG_LIBM {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # option CYGFUN_LIBC_strtod
+    #     Requires: CYGPKG_LIBM
+    # option CYGFUN_LIBC_strtod
+    #     DefaultValue:  0 != CYGPKG_LIBM 
+    # option CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
+    #     Requires: CYGPKG_LIBM
+    # option CYGSEM_LIBC_STDIO_PRINTF_FLOATING_POINT
+    #     DefaultValue:  0 != CYGPKG_LIBM 
+    # option CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
+    #     Requires: CYGPKG_LIBM
+    # option CYGSEM_LIBC_STDIO_SCANF_FLOATING_POINT
+    #     DefaultValue:  0 != CYGPKG_LIBM &&
+    #                                 0 != CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+};
+
+# >
+# Compatibility mode
+# These options deal with behaviour related to
+# the various compatibility modes - POSIX, IEEE,
+# X/OPEN and SVID.
+#
+cdl_component CYGPKG_LIBM_COMPATIBILITY {
+    # There is no associated value.
+};
+
+# >
+#
+cdl_interface CYGINT_LIBM_COMPAT {
+    # Implemented by CYGSEM_LIBM_COMPAT_IEEE_ONLY, active, disabled
+    # Implemented by CYGNUM_LIBM_COMPATIBILITY, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires: 1 == CYGINT_LIBM_COMPAT
+    #     CYGINT_LIBM_COMPAT == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_LIBM_COMPAT
+    #     Requires: 1 == CYGINT_LIBM_COMPAT
+};
+
+# IEEE-only
+# The math library can be hard-coded to only
+# behave in one compatibility mode - IEEE. This
+# cannot be changed at run-time. IEEE mode is the
+# most minimal of the compatibility modes, and so
+# this will best help code size and speed, as well
+# as omitting the code for other compatibility
+# modes. If not defined, the math library can be
+# set at run-time to any of the supported
+# compatibility modes.
+#
+cdl_option CYGSEM_LIBM_COMPAT_IEEE_ONLY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_LIBM_USE_STDERR
+    #     Requires: !CYGSEM_LIBM_COMPAT_IEEE_ONLY
+    # option CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE
+    #     Requires: !CYGSEM_LIBM_COMPAT_IEEE_ONLY
+};
+
+# Default mode
+# If you want to have support for more than one
+# compatibility mode settable at run-time, rather
+# than hard-coded IEEE mode, this component lets
+# you choose which mode should be the default.
+#
+cdl_component CYGNUM_LIBM_COMPATIBILITY {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 POSIX
+    # value_source default
+    # Default value: 1 POSIX
+    # Legal values:  "POSIX" "IEEE" "XOPEN" "SVID" 
+    # Requires: CYGPKG_LIBC
+    #     CYGPKG_LIBC == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBM_COMPAT_DEFAULT
+    #     Calculated:   CYGNUM_LIBM_COMPATIBILITY == "POSIX" ? "CYGNUM_LIBM_COMPAT_POSIX" : CYGNUM_LIBM_COMPATIBILITY == "IEEE"  ? "CYGNUM_LIBM_COMPAT_IEEE" : CYGNUM_LIBM_COMPATIBILITY == "XOPEN" ? "CYGNUM_LIBM_COMPAT_XOPEN" : CYGNUM_LIBM_COMPATIBILITY == "SVID"  ? "CYGNUM_LIBM_COMPAT_SVID" : "<undefined>"  
+    # option CYGNUM_LIBM_COMPAT_DEFAULT
+    #     Calculated:   CYGNUM_LIBM_COMPATIBILITY == "POSIX" ? "CYGNUM_LIBM_COMPAT_POSIX" : CYGNUM_LIBM_COMPATIBILITY == "IEEE"  ? "CYGNUM_LIBM_COMPAT_IEEE" : CYGNUM_LIBM_COMPATIBILITY == "XOPEN" ? "CYGNUM_LIBM_COMPAT_XOPEN" : CYGNUM_LIBM_COMPATIBILITY == "SVID"  ? "CYGNUM_LIBM_COMPAT_SVID" : "<undefined>"  
+    # option CYGNUM_LIBM_COMPAT_DEFAULT
+    #     Calculated:   CYGNUM_LIBM_COMPATIBILITY == "POSIX" ? "CYGNUM_LIBM_COMPAT_POSIX" : CYGNUM_LIBM_COMPATIBILITY == "IEEE"  ? "CYGNUM_LIBM_COMPAT_IEEE" : CYGNUM_LIBM_COMPATIBILITY == "XOPEN" ? "CYGNUM_LIBM_COMPAT_XOPEN" : CYGNUM_LIBM_COMPATIBILITY == "SVID"  ? "CYGNUM_LIBM_COMPAT_SVID" : "<undefined>"  
+    # option CYGNUM_LIBM_COMPAT_DEFAULT
+    #     Calculated:   CYGNUM_LIBM_COMPATIBILITY == "POSIX" ? "CYGNUM_LIBM_COMPAT_POSIX" : CYGNUM_LIBM_COMPATIBILITY == "IEEE"  ? "CYGNUM_LIBM_COMPAT_IEEE" : CYGNUM_LIBM_COMPATIBILITY == "XOPEN" ? "CYGNUM_LIBM_COMPAT_XOPEN" : CYGNUM_LIBM_COMPATIBILITY == "SVID"  ? "CYGNUM_LIBM_COMPAT_SVID" : "<undefined>"  
+};
+
+# >
+# Numeric representation
+# This option automatically defines the default compatibility
+# mode for numeric representation in terms of the values used
+# to set that mode at run-time.
+#
+cdl_option CYGNUM_LIBM_COMPAT_DEFAULT {
+    # Calculated value:   CYGNUM_LIBM_COMPATIBILITY == "POSIX" ? "CYGNUM_LIBM_COMPAT_POSIX" : CYGNUM_LIBM_COMPATIBILITY == "IEEE"  ? "CYGNUM_LIBM_COMPAT_IEEE" : CYGNUM_LIBM_COMPATIBILITY == "XOPEN" ? "CYGNUM_LIBM_COMPAT_XOPEN" : CYGNUM_LIBM_COMPATIBILITY == "SVID"  ? "CYGNUM_LIBM_COMPAT_SVID" : "<undefined>"  
+    #     CYGNUM_LIBM_COMPATIBILITY == POSIX
+    #     CYGNUM_LIBM_COMPATIBILITY == POSIX
+    #     CYGNUM_LIBM_COMPATIBILITY == POSIX
+    #     CYGNUM_LIBM_COMPATIBILITY == POSIX
+    # Flavor: data
+    # Current_value: CYGNUM_LIBM_COMPAT_POSIX
+};
+
+# <
+# SVID3-style scalb()
+# SVID3 defined the scalb() function as double
+# scalb(double, double) rather than double
+# scalb(double, int) which is used by IBM, DEC, and
+# probably others. Enabling this option chooses
+# the (double, double) version. Note there is a
+# function double scalbn(double, int) which is
+# unaffected by this choice.
+#
+cdl_option CYGFUN_LIBM_SVID3_scalb {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Reduce namespace pollution
+# If you do not want to use either the X/Open or
+# SVID3 compatibility modes, you may want to define
+# this option to reduce the chance of namespace
+# pollution. This is particularly likely to occur
+# here as these standards define symbols with
+# names that often appear in applications, such as
+# exception, DOMAIN, OVERFLOW, etc. If your
+# application also used these names, it may cause
+# problems.
+#
+cdl_option CYGSYM_LIBM_NO_XOPEN_SVID_NAMESPACE_POLLUTION {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Output to stderr for math errors
+# The SVID3 standard says that error
+# messages should be output on the stderr console
+# output stream. This option allows this ability
+# to be explicitly controlled. However, this still
+# only has an effect in SVID3 compatibility mode.
+#
+cdl_option CYGSEM_LIBM_USE_STDERR {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: !CYGSEM_LIBM_COMPAT_IEEE_ONLY
+    #     CYGSEM_LIBM_COMPAT_IEEE_ONLY == 0
+    #   --> 1
+    # Requires: CYGPKG_LIBC_STDIO
+    #     CYGPKG_LIBC_STDIO == current
+    #   --> 1
+};
+
+# <
+# Thread safety
+# This option controls whether the C library has
+# support for thread safe operation in general.
+# This requires eCos kernel support for per-thread
+# data, and adjustment of the stack limit.
+#
+cdl_component CYGPKG_LIBM_THREAD_SAFETY {
+    # There is no associated value.
+};
+
+# >
+# Compatibility mode setting
+# This option makes the setting of the compatiblity
+# mode be a per-thread property. This directly
+# implies that it also becomes thread-safe.
+#
+cdl_option CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: !CYGSEM_LIBM_COMPAT_IEEE_ONLY
+    #     CYGSEM_LIBM_COMPAT_IEEE_ONLY == 0
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBM_COMPATMODE_TRACE_LEVEL
+    #     Requires: CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE
+};
+
+# gamma() and lgamma()
+# This option makes the gamma() and lgamma()
+# functions be thread-safe. Note that these
+# functions are identical - they take the log of
+# the absolute value of their argument. The sign
+# of the argument is stored in a variable called
+# signgam. Enabling this option makes signgam
+# a per-thread variable. Note there are also
+# gamma_r() and lgamma_r() alternatives that
+# allow signgam to be passed in by reference as
+# an argument.
+#
+cdl_option CYGSEM_LIBM_THREAD_SAFE_GAMMA_FUNCTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_LIBM_SIGNGAM_TRACE_LEVEL
+    #     Requires: CYGSEM_LIBM_THREAD_SAFE_GAMMA_FUNCTIONS
+};
+
+# <
+# Tracing output levels in math library
+# Tracing support is useful for debugging. Some
+# Math library modules can be configured with
+# different levels of tracing verbosity. These
+# levels can be configured here.
+#
+cdl_component CYGPKG_LIBM_TRACE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+};
+
+# >
+# Compatibility mode get/set
+# Trace level for debugging the getting and
+# setting of the compatibility mode when it is
+# configured to be thread-safe.
+#
+cdl_option CYGNUM_LIBM_COMPATMODE_TRACE_LEVEL {
+    # This option is not active
+    # The parent CYGPKG_LIBM_TRACE is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+    # Requires: CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE
+    #     CYGSEM_LIBM_THREAD_SAFE_COMPAT_MODE == 0
+    #   --> 0
+};
+
+# signgam variable access
+# Trace level for debugging all accesses to the
+# signgam variable in thread-safe mode.
+#
+cdl_option CYGNUM_LIBM_SIGNGAM_TRACE_LEVEL {
+    # This option is not active
+    # The parent CYGPKG_LIBM_TRACE is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+    # Requires: CYGSEM_LIBM_THREAD_SAFE_GAMMA_FUNCTIONS
+    #     CYGSEM_LIBM_THREAD_SAFE_GAMMA_FUNCTIONS == 0
+    #   --> 0
+};
+
+# <
+# Bessel function limit of significance
+# For the Bessel functions (j0(), j1(), jn(),
+# y0(), y1(), yn()) this option defines the
+# maximum absolute value of the ordinate
+# before we assume total loss of significance.
+# This number must be a floating-point number (e.g.
+# contains a decimal point), and should be
+# large.
+#
+cdl_option X_TLOSS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1.41484755040569E+16
+    # value_source default
+    # Default value: 1.41484755040569E+16
+    # Legal values: 1 to 1e308
+};
+
+# Math library build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBM_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the math library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBM_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -ffloat-store
+    # value_source default
+    # Default value:  ((0 == CYGPKG_HAL_I386) && (0 == CYGPKG_HAL_SYNTH_I386)) ? "" : "-ffloat-store" 
+    #     CYGPKG_HAL_I386 == current
+    #     CYGPKG_HAL_SYNTH_I386 (unknown) == 0
+    #   --> -ffloat-store
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the math library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBM_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Math library tests
+# This option specifies the set of tests for the math library.
+#
+cdl_option CYGPKG_LIBM_TESTS {
+    # Calculated value:  "tests/vectors/acos tests/vectors/asin tests/vectors/atan tests/vectors/atan2 tests/vectors/ceil tests/vectors/cos tests/vectors/cosh tests/vectors/exp tests/vectors/fabs tests/vectors/floor tests/vectors/fmod tests/vectors/frexp tests/vectors/ldexp tests/vectors/log tests/vectors/log10 tests/vectors/modf tests/vectors/pow tests/vectors/sin tests/vectors/sinh tests/vectors/sqrt tests/vectors/tan tests/vectors/tanh" 
+    # Flavor: data
+    # Current_value: tests/vectors/acos tests/vectors/asin tests/vectors/atan tests/vectors/atan2 tests/vectors/ceil tests/vectors/cos tests/vectors/cosh tests/vectors/exp tests/vectors/fabs tests/vectors/floor tests/vectors/fmod tests/vectors/frexp tests/vectors/ldexp tests/vectors/log tests/vectors/log10 tests/vectors/modf tests/vectors/pow tests/vectors/sin tests/vectors/sinh tests/vectors/sqrt tests/vectors/tan tests/vectors/tanh
+};
+
+# <
+# <
+# POSIX compatibility layer
+# doc: ref/posix-compatibility.html
+# This package enables the POSIX compatibility
+# layer that implements IEEE 1003.1.
+#
+cdl_package CYGPKG_POSIX {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO_CODES
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #   --> 1
+    # Requires: CYGIMP_KERNEL_SCHED_SORTED_QUEUES
+    #     CYGIMP_KERNEL_SCHED_SORTED_QUEUES == 1
+    #   --> 1
+    # Requires:  CYGBLD_ISO_POSIX_LIMITS_HEADER ==  "<cyg/posix/limits.h>" 
+    #     CYGBLD_ISO_POSIX_LIMITS_HEADER == <cyg/posix/limits.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_PMUTEXTYPES_HEADER ==  "<cyg/posix/muttypes.h>" 
+    #     CYGBLD_ISO_PMUTEXTYPES_HEADER == <cyg/posix/muttypes.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_PTHREAD_MUTEX_HEADER ==  "<cyg/posix/mutex.h>" 
+    #     CYGBLD_ISO_PTHREAD_MUTEX_HEADER == <cyg/posix/mutex.h>
+    #   --> 1
+};
+
+# >
+# POSIX pthread mutexes
+# This component provides support for POSIX pthreads
+# mutexes.
+#
+cdl_component CYGPKG_POSIX_PTHREAD_MUTEX {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+};
+
+# >
+# POSIX mutex priority inheritance feature test macro
+# This option defines the POSIX feature test macro for
+# supporting priority inheritance protocol in mutexes.
+#
+cdl_option _POSIX_THREAD_PRIO_INHERIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT
+    #     CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_INHERIT == 1
+    #   --> 1
+};
+
+# POSIX mutex priority ceiling feature test macro
+# This option defines the POSIX feature test macro for 
+# supporting priority ceiling protocol in mutexes.
+#
+cdl_option _POSIX_THREAD_PRIO_PROTECT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING
+    #     CYGSEM_KERNEL_SYNCH_MUTEX_PRIORITY_INVERSION_PROTOCOL_CEILING == 1
+    #   --> 1
+};
+
+# <
+# POSIX scheduling configuration
+# This component provides controls over scheduling in POSIX.
+#
+cdl_component CYGPKG_POSIX_SCHED {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_POSIX_CLOCKS
+    #     CYGPKG_POSIX_CLOCKS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_PTHREAD_REQUIREMENTS
+    #     Requires: CYGPKG_POSIX_SCHED
+};
+
+# >
+# POSIX priority scheduling feature test macro
+# This option defines the POSIX feature test macro that 
+# indicates that priority scheduling is present. This 
+# should not be undefined.
+#
+cdl_option _POSIX_PRIORITY_SCHEDULING {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGSEM_KERNEL_SCHED_MLQUEUE
+    #     CYGSEM_KERNEL_SCHED_MLQUEUE == 1
+    #   --> 1
+};
+
+# <
+# POSIX pthread configuration
+# This component provides configuration controls for the 
+# POSIX pthreads package.
+#
+cdl_component CYGPKG_POSIX_PTHREAD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires: CYGPKG_POSIX_PTHREAD
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires: CYGPKG_POSIX_PTHREAD
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     Requires:  CYGSEM_LIBC_STARTUP_MAIN_THREAD ||  (CYGSEM_LIBC_STARTUP_MAIN_OTHER && CYGPKG_POSIX_PTHREAD) 
+};
+
+# >
+# Generic requirements of pthread package
+# This option exists merely to carry the pthread
+# package requirements.
+#
+cdl_option CYGPKG_POSIX_PTHREAD_REQUIREMENTS {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGPKG_POSIX_SCHED
+    #     CYGPKG_POSIX_SCHED == 1
+    #   --> 1
+    # Requires: CYGSEM_KERNEL_SCHED_TIMESLICE_ENABLE
+    #     CYGSEM_KERNEL_SCHED_TIMESLICE_ENABLE == 1
+    #   --> 1
+    # Requires: CYGSEM_KERNEL_SCHED_ASR_SUPPORT
+    #     CYGSEM_KERNEL_SCHED_ASR_SUPPORT == 1
+    #   --> 1
+    # Requires: CYGSEM_KERNEL_SCHED_ASR_GLOBAL
+    #     CYGSEM_KERNEL_SCHED_ASR_GLOBAL == 1
+    #   --> 1
+    # Requires: !CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL
+    #     CYGSEM_KERNEL_SCHED_ASR_DATA_GLOBAL == 0
+    #   --> 1
+    # Requires: CYGFUN_KERNEL_THREADS_STACK_LIMIT
+    #     CYGFUN_KERNEL_THREADS_STACK_LIMIT == 1
+    #   --> 1
+    # Requires:  CYGBLD_ISO_PTHREADTYPES_HEADER ==  "<cyg/posix/types.h>" 
+    #     CYGBLD_ISO_PTHREADTYPES_HEADER == <cyg/posix/types.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_PTHREAD_IMPL_HEADER ==  "<cyg/posix/pthread.h>" 
+    #     CYGBLD_ISO_PTHREAD_IMPL_HEADER == <cyg/posix/pthread.h>
+    #   --> 1
+};
+
+# Constant values used in pthread package
+# These are values that are either configurable, or derived
+# from system parameters.
+#
+cdl_component CYGPKG_POSIX_PTHREAD_VALUES {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Maximum number of iterations of key destructors
+# Maximum number of iterations of key destructors allowed.
+#
+cdl_option CYGNUM_POSIX_PTHREAD_DESTRUCTOR_ITERATIONS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 4 to 100
+};
+
+# Maximum number of per-thread data keys allowed
+# Number of per-thread data keys supported.
+#
+cdl_option CYGNUM_POSIX_PTHREAD_KEYS_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+    # Legal values: 128 to 65535
+};
+
+# Maximum number of threads allowed
+# Maximum number of threads supported.
+#
+cdl_option CYGNUM_POSIX_PTHREAD_THREADS_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 64
+    # value_source default
+    # Default value: 64
+    # Legal values: 64 to 1024
+};
+
+# <
+# Fixed Feature test macros for POSIX
+# These options define POSIX feature test macros that
+# describe the eCos implementation of pthreads. These
+# are not changeable configuration options.
+#
+cdl_component CYGPKG_POSIX_PTHREAD_FEATURES {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# POSIX thread support feature test macro
+# This option defines the POSIX feature test macro
+# for thread support.
+#
+cdl_option _POSIX_THREADS {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGSEM_KERNEL_SCHED_TIMESLICE
+    #     CYGSEM_KERNEL_SCHED_TIMESLICE == 1
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option _POSIX_THREAD_PRIORITY_SCHEDULING
+    #     Requires: _POSIX_THREADS
+};
+
+# POSIX thread priority scheduling feature test macro
+# This option defines the POSIX feature test macro
+# for thread priority scheduling support.
+#
+cdl_option _POSIX_THREAD_PRIORITY_SCHEDULING {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGSEM_KERNEL_SCHED_MLQUEUE
+    #     CYGSEM_KERNEL_SCHED_MLQUEUE == 1
+    #   --> 1
+    # Requires: _POSIX_THREADS
+    #     _POSIX_THREADS == 1
+    #   --> 1
+};
+
+# POSIX stack address attribute feature test macro
+# This option defines the POSIX feature test macro
+# for supporting the thread stack address in the thread
+# attribute object.
+#
+cdl_option _POSIX_THREAD_ATTR_STACKADDR {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# POSIX stack size attribute feature test macro
+# This option defines the POSIX feature test macro
+# for supporting the thread stack size in the thread
+# attribute object.
+#
+cdl_option _POSIX_THREAD_ATTR_STACKSIZE {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# POSIX process shared attribute feature test macro
+# This option defines the POSIX feature test macro
+# for supporting process shared mutexes. Since eCos
+# does not have processes, this attribute is undefined.
+#
+cdl_option _POSIX_THREAD_PROCESS_SHARED {
+    # Calculated value: 0
+    # Flavor: bool
+    # Current value: 0
+};
+
+# <
+# Main thread configuration
+# These options control the thread used to
+# run the main() application entry routine.
+#
+cdl_component CYGPKG_POSIX_MAIN_THREAD {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires:  0 != CYGPKG_LIBC_STARTUP 
+    #     CYGPKG_LIBC_STARTUP == current
+    #   --> 1
+    # Requires: CYGSEM_LIBC_STARTUP_MAIN_OTHER
+    #     CYGSEM_LIBC_STARTUP_MAIN_OTHER == 1
+    #   --> 1
+};
+
+# >
+# main()'s default thread priority
+# POSIX compatibility requires that the application's
+# main() function be invoked in a thread.
+# This option controls the priority of that thread. This
+# priority is the POSIX priority and is NOT the same as
+# an eCos thread priority. With POSIX thread priorities,
+# lower numbers are lower priority, and higher numbers are
+# higher priority.
+#
+cdl_option CYGNUM_POSIX_MAIN_DEFAULT_PRIORITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: 0 to 31
+};
+
+# <
+# <
+# POSIX clocks
+# This component provides configuration controls for
+# the POSIX clocks and the sleep(), nanosleep() and 
+# gettimeofday() functions.
+#
+cdl_option CYGPKG_POSIX_CLOCKS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_POSIX_CLOCK_TYPES_HEADER ==  "<cyg/posix/time.h>" 
+    #     CYGBLD_ISO_POSIX_CLOCK_TYPES_HEADER == <cyg/posix/time.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_POSIX_CLOCKS_HEADER ==  "<cyg/posix/time.h>" 
+    #     CYGBLD_ISO_POSIX_CLOCKS_HEADER == <cyg/posix/time.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRUCTTIMEVAL_HEADER ==  "<cyg/posix/sys/time.h>" 
+    #     CYGBLD_ISO_STRUCTTIMEVAL_HEADER == <cyg/posix/sys/time.h>
+    #   --> 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_SCHED
+    #     Requires: CYGPKG_POSIX_CLOCKS
+    # component CYGPKG_POSIX_MQUEUES
+    #     Requires: CYGPKG_POSIX_CLOCKS
+};
+
+# POSIX timers
+# This component provides configuration controls for
+# the POSIX timers.
+#
+cdl_option CYGPKG_POSIX_TIMERS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_POSIX_TIMER_TYPES_HEADER ==  "<cyg/posix/time.h>" 
+    #     CYGBLD_ISO_POSIX_TIMER_TYPES_HEADER == <cyg/posix/time.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_POSIX_TIMERS_HEADER ==  "<cyg/posix/time.h>" 
+    #     CYGBLD_ISO_POSIX_TIMERS_HEADER == <cyg/posix/time.h>
+    #   --> 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_PTHREAD
+    #     CYGPKG_POSIX_PTHREAD == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_SIGNALS
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_POSIX_CLOCKS
+    #     CYGINT_ISO_POSIX_CLOCKS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_POSIX_SIGNALS
+    #     Requires: CYGPKG_POSIX_TIMERS
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+};
+
+# POSIX semaphores
+# This component provides configuration controls for
+# POSIX semaphores.
+#
+cdl_option CYGPKG_POSIX_SEMAPHORES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_SEMAPHORES_HEADER ==  "<cyg/posix/semaphore.h>" 
+    #     CYGBLD_ISO_SEMAPHORES_HEADER == <cyg/posix/semaphore.h>
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+};
+
+# POSIX message queues
+# This component provides configuration controls for
+# POSIX message queues.
+#
+cdl_component CYGPKG_POSIX_MQUEUES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_PTHREAD_MUTEX
+    #     CYGINT_ISO_PTHREAD_MUTEX == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_CLOCKS
+    #     CYGPKG_POSIX_CLOCKS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+};
+
+# >
+# Maximum number of message queues
+#
+cdl_option CYGNUM_POSIX_MQUEUE_OPEN_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 1 to 999999
+
+    # The following properties are affected by this value
+    # option CYGNUM_ISO_MQUEUE_OPEN_MAX
+    #     DefaultValue:  CYGNUM_POSIX_MQUEUE_OPEN_MAX > 0 ? CYGNUM_POSIX_MQUEUE_OPEN_MAX : 0 
+    # option CYGNUM_ISO_MQUEUE_OPEN_MAX
+    #     DefaultValue:  CYGNUM_POSIX_MQUEUE_OPEN_MAX > 0 ? CYGNUM_POSIX_MQUEUE_OPEN_MAX : 0 
+};
+
+# Validate queue descriptors
+# This option turns on checking that message queue descriptors
+# (of type mqd_t) passed into mq_* functions are valid. If so,
+# the functions will fail with EBADF, as POSIX 1003.1 mandates.
+# If this option is disabled, if an invalid descriptor is used,
+# random corruption may occur, or the system may crash. If
+# you are confident invalid descriptors will not be used,
+# you may wish to be disable this to save some per-instance
+# memory and execution time.
+#
+cdl_option CYGIMP_POSIX_MQUEUE_VALIDATE_DESCRIPTOR {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Allow empty queue notification
+# Enabling this option adds the function mq_notify() to the
+# API. Without it, some code and per-message queue descriptor
+# space is saved, as well as no longer requiring POSIX realtime
+# signal support.
+#
+cdl_option CYGFUN_POSIX_MQUEUE_NOTIFY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGPKG_POSIX_SIGNALS
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_SIGNALS
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #   --> 1
+};
+
+# <
+# POSIX signals configuration
+# This component provides configuration controls for
+# the POSIX signals.
+#
+cdl_component CYGPKG_POSIX_SIGNALS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_KERNEL_EXCEPTIONS
+    #     CYGPKG_KERNEL_EXCEPTIONS == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_PTHREAD
+    #     CYGPKG_POSIX_PTHREAD == 1
+    #   --> 1
+    # Requires: CYGPKG_POSIX_TIMERS
+    #     CYGPKG_POSIX_TIMERS == 1
+    #   --> 1
+    # Requires:  CYGBLD_ISO_SIGSETJMP_HEADER ==  "<cyg/posix/sigsetjmp.h>" 
+    #     CYGBLD_ISO_SIGSETJMP_HEADER == <cyg/posix/sigsetjmp.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_SIGNAL_NUMBERS_HEADER ==  "<cyg/posix/signal.h>" 
+    #     CYGBLD_ISO_SIGNAL_NUMBERS_HEADER == <cyg/posix/signal.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_SIGNAL_IMPL_HEADER ==  "<cyg/posix/signal.h>" 
+    #     CYGBLD_ISO_SIGNAL_IMPL_HEADER == <cyg/posix/signal.h>
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_POSIX_TIMERS
+    #     Requires: CYGPKG_POSIX_SIGNALS
+    # option CYGFUN_POSIX_MQUEUE_NOTIFY
+    #     Requires: CYGPKG_POSIX_SIGNALS
+    # option CYGFUN_POSIX_MQUEUE_NOTIFY
+    #     DefaultValue: CYGPKG_POSIX_SIGNALS
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    # option CYGPKG_POSIX_TESTS
+    #     Calculated:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+};
+
+# POSIX utsname configuration
+# This component provides configuration controls for
+# the POSIX utsname structure and the uname() function.
+#
+cdl_component CYGPKG_POSIX_UTSNAME {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_UTSNAME_HEADER ==  "<cyg/posix/utsname.h>" 
+    #     CYGBLD_ISO_UTSNAME_HEADER == <cyg/posix/utsname.h>
+    #   --> 1
+};
+
+# >
+# Length of name strings in utsname structure
+#
+cdl_option CYG_POSIX_UTSNAME_LENGTH {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 65
+    # value_source default
+    # Default value: 65
+    # Legal values: 1 to 99999999
+
+    # The following properties are affected by this value
+    # option CYG_POSIX_UTSNAME_NODENAME_LENGTH
+    #     DefaultValue:  CYG_POSIX_UTSNAME_LENGTH 
+};
+
+# Length of nodename string in utsname structure
+#
+cdl_option CYG_POSIX_UTSNAME_NODENAME_LENGTH {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 65
+    # value_source default
+    # Default value:  CYG_POSIX_UTSNAME_LENGTH 
+    #     CYG_POSIX_UTSNAME_LENGTH == 65
+    #   --> 65
+    # Legal values: 1 to 99999999
+};
+
+# <
+# POSIX tests
+# This option specifies the set of tests for the POSIX package.
+#
+cdl_option CYGPKG_POSIX_TESTS {
+    # Calculated value:  
+    #                 (CYGPKG_POSIX_PTHREAD ? "tests/pthread1 tests/pthread2 tests/pthread3 " 
+    #                                       : "") .
+    #                 (CYGPKG_POSIX_PTHREAD_MUTEX ? "tests/mutex3 " : "") .
+    #                 (CYGPKG_POSIX_MQUEUES ? "tests/mqueue1 tests/mqueue2 " : "") .
+    #                 (CYGPKG_POSIX_SIGNALS ? "tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS && 
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/timer1 " : "") .
+    #                 ((CYGPKG_POSIX_SIGNALS && 
+    #                   CYGPKG_POSIX_TIMERS &&     
+    #                   CYGPKG_POSIX_PTHREAD &&
+    #                   CYGPKG_POSIX_SEMAPHORES) ? "tests/tm_basic " : "")
+    #                 
+    #     CYGPKG_POSIX_PTHREAD == 1
+    #     CYGPKG_POSIX_PTHREAD_MUTEX == 1
+    #     CYGPKG_POSIX_MQUEUES == 1
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #     CYGPKG_POSIX_TIMERS == 1
+    #     CYGPKG_POSIX_SEMAPHORES == 1
+    #     CYGPKG_POSIX_SIGNALS == 1
+    #     CYGPKG_POSIX_TIMERS == 1
+    #     CYGPKG_POSIX_PTHREAD == 1
+    #     CYGPKG_POSIX_SEMAPHORES == 1
+    # Flavor: data
+    # Current_value: tests/pthread1 tests/pthread2 tests/pthread3 tests/mutex3 tests/mqueue1 tests/mqueue2 tests/signal1 tests/signal2 tests/signal3  tests/sigsetjmp tests/timer1 tests/tm_basic 
+};
+
+# <
+# Watchdog IO device
+# The watchdog IO device allows applications to make use of a
+# timer facility. Depending on the underlying hardware device
+# driver, a watchdog timeout will either cause a board reset
+# or an action routine to be called. The application must call
+# the watchdog reset function at regular intervals, or else the
+# device will timeout. The assumption is that the watchdog timer
+# should never trigger unless there has been a serious fault in
+# either the hardware or the software.
+#
+cdl_package CYGPKG_IO_WATCHDOG {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: 1 == CYGINT_WATCHDOG_IMPLEMENTATIONS
+    #     CYGINT_WATCHDOG_IMPLEMENTATIONS == 1
+    #   --> 1
+};
+
+# >
+# Number of watchdog hardware implementations
+#
+cdl_interface CYGINT_WATCHDOG_HW_IMPLEMENTATIONS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_WATCHDOG_EMULATE
+    #     DefaultValue:  0 == CYGINT_WATCHDOG_HW_IMPLEMENTATIONS 
+};
+
+# Number of watchdog implementations
+#
+cdl_interface CYGINT_WATCHDOG_IMPLEMENTATIONS {
+    # Implemented by CYGPKG_WATCHDOG_EMULATE, active, enabled
+    # Implemented by CYGIMP_WATCHDOG_NONE, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_WATCHDOG
+    #     Requires: 1 == CYGINT_WATCHDOG_IMPLEMENTATIONS
+};
+
+# Watchdog implementation
+# Implementations of the watchdog device.
+#
+cdl_component CYGPKG_IO_WATCHDOG_IMPLEMENTATION {
+    # There is no associated value.
+};
+
+# >
+# Watchdog emulator
+# When this option is enabled, a watchdog device will be
+# emulated using the kernel real-time clock.
+#
+cdl_option CYGPKG_WATCHDOG_EMULATE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 == CYGINT_WATCHDOG_HW_IMPLEMENTATIONS 
+    #     CYGINT_WATCHDOG_HW_IMPLEMENTATIONS == 0
+    #   --> 1
+    # Requires: CYGVAR_KERNEL_COUNTERS_CLOCK
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK == 1
+    #   --> 1
+};
+
+# No watchdog
+# Disables the watchdog.
+#
+cdl_option CYGIMP_WATCHDOG_NONE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Set if device causes a reset on timeout
+#
+cdl_interface CYGINT_WATCHDOG_RESETS_ON_TIMEOUT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT
+    #     Calculated:  CYGINT_WATCHDOG_RESETS_ON_TIMEOUT == 1 
+};
+
+# Set if device causes a reset on timeout
+# Some watchdog devices reset the board on timeout - for these
+# implementations it does not make sense to register timeout
+# actions so the code gets disabled when this option is set.
+# When this option is not set, it is the application's
+# responsibility to register an action handler which can force
+# a board reset when it gets called.
+#
+cdl_option CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT {
+    # Calculated value:  CYGINT_WATCHDOG_RESETS_ON_TIMEOUT == 1 
+    #     CYGINT_WATCHDOG_RESETS_ON_TIMEOUT == 0
+    # Flavor: bool
+    # Current value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_IO_WATCHDOG_TESTS
+    #     Calculated:  CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST ? 
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2 tests/watchdog_reset" : "tests/watchdog tests/watchdog2 tests/watchdog_reset" :
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2" : "tests/watchdog tests/watchdog2" 
+    # option CYGPKG_IO_WATCHDOG_TESTS
+    #     Calculated:  CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST ? 
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2 tests/watchdog_reset" : "tests/watchdog tests/watchdog2 tests/watchdog_reset" :
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2" : "tests/watchdog tests/watchdog2" 
+};
+
+# Build interactive watchdog test
+# This option enables the building of a watchdog test
+# which can be used to test that the board resets on
+# watchdog timeout. This test is built separately since
+# it only makes sense to use interactively.
+#
+cdl_option CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_IO_WATCHDOG_TESTS
+    #     Calculated:  CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST ? 
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2 tests/watchdog_reset" : "tests/watchdog tests/watchdog2 tests/watchdog_reset" :
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2" : "tests/watchdog tests/watchdog2" 
+};
+
+# Watchdog build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_WATCHDOG_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the watchdog IO device. These flags are used
+# in addition to the set of global flags.
+#
+cdl_option CYGPKG_IO_WATCHDOG_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the watchdog IO device. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_WATCHDOG_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Watchdog tests
+# This option specifies the set of tests for the
+# watchdog IO device.
+#
+cdl_option CYGPKG_IO_WATCHDOG_TESTS {
+    # Calculated value:  CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST ? 
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2 tests/watchdog_reset" : "tests/watchdog tests/watchdog2 tests/watchdog_reset" :
+    #                              CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT ? "tests/watchdog2" : "tests/watchdog tests/watchdog2" 
+    #     CYGPKG_IO_WATCHDOG_BUILD_INTERACTIVE_TEST == 0
+    #     CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT == 0
+    #     CYGSEM_WATCHDOG_RESETS_ON_TIMEOUT == 0
+    # Flavor: data
+    # Current_value: tests/watchdog tests/watchdog2
+};
+
+# <
+# <
+# Wallclock device
+# The wallclock device provides real time stamps, as opposed
+# to the eCos kernel timers which typically just count the
+# number of clock ticks since the hardware was powered up.
+# Depending on the target platform this device may involve
+# interacting with a suitable clock chip, or it may be
+# emulated by using the kernel timers.
+#
+cdl_package CYGPKG_IO_WALLCLOCK {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+    #     ActiveIf: CYGPKG_IO_WALLCLOCK
+    # package CYGPKG_DEVICES_WALLCLOCK_I386_PC
+    #     ActiveIf: CYGPKG_IO_WALLCLOCK
+    # option CYGSEM_LIBC_TIME_TIME_WORKING
+    #     Requires: CYGPKG_IO_WALLCLOCK
+    # option CYGSEM_LIBC_TIME_SETTIME_WORKING
+    #     Requires: CYGPKG_IO_WALLCLOCK
+};
+
+# >
+# Number of wallclock hardware implementations
+#
+cdl_interface CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS {
+    # Implemented by CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_WALLCLOCK_EMULATE
+    #     DefaultValue:  0 == CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS 
+    # option CYGIMP_WALLCLOCK_NONE
+    #     DefaultValue:  !CYGPKG_KERNEL && 0 == CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS 
+};
+
+# Number of wallclock implementations
+#
+cdl_interface CYGINT_WALLCLOCK_IMPLEMENTATIONS {
+    # Implemented by CYGPKG_WALLCLOCK_EMULATE, active, disabled
+    # Implemented by CYGIMP_WALLCLOCK_NONE, active, disabled
+    # Implemented by CYGIMP_WALLCLOCK_HARDWARE, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires: 1 == CYGINT_WALLCLOCK_IMPLEMENTATIONS
+    #     CYGINT_WALLCLOCK_IMPLEMENTATIONS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_WALLCLOCK_IMPLEMENTATIONS
+    #     Requires: 1 == CYGINT_WALLCLOCK_IMPLEMENTATIONS
+};
+
+# Wallclock driver supports set/get mode
+#
+cdl_interface CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED {
+    # Implemented by CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_WALLCLOCK_MODE
+    #     DefaultValue:  CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED ?  "set_get" : "init_get" 
+    # option CYGSEM_WALLCLOCK_MODE
+    #     Requires:  CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED ||  CYGSEM_WALLCLOCK_MODE == "init_get" 
+};
+
+# Wallclock mode
+# The wallclock driver can be used in one of two
+# modes. Set/get mode allows time to be kept during power
+# off (assuming there's a battery backed clock). Init/get
+# mode is slightly smaller and can be used when there is no
+# battery backed clock - in this mode time 0 is the time of
+# the board power up.
+#
+cdl_option CYGSEM_WALLCLOCK_MODE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value set_get
+    # value_source default
+    # Default value:  CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED ?  "set_get" : "init_get" 
+    #     CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED == 1
+    #   --> set_get
+    # Legal values:  "init_get" "set_get" 
+    # Requires:  CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED ||  CYGSEM_WALLCLOCK_MODE == "init_get" 
+    #     CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED == 1
+    #     CYGSEM_WALLCLOCK_MODE == set_get
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_WALLCLOCK_MODE
+    #     Requires:  CYGINT_WALLCLOCK_SET_GET_MODE_SUPPORTED ||  CYGSEM_WALLCLOCK_MODE == "init_get" 
+    # option CYGSEM_WALLCLOCK_SET_GET_MODE
+    #     Calculated:  CYGSEM_WALLCLOCK_MODE == "set_get" ? 1 : 0 
+};
+
+# Wallclock set/get mode
+#
+cdl_option CYGSEM_WALLCLOCK_SET_GET_MODE {
+    # Calculated value:  CYGSEM_WALLCLOCK_MODE == "set_get" ? 1 : 0 
+    #     CYGSEM_WALLCLOCK_MODE == set_get
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Wallclock implementation
+# Implementations of the wallclock device.
+#
+cdl_component CYGPKG_IO_WALLCLOCK_IMPLEMENTATION {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Wallclock emulator
+# When this option is enabled, a wallclock device will be
+# emulated using the kernel real-time clock.
+#
+cdl_option CYGPKG_WALLCLOCK_EMULATE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 == CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS 
+    #     CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS == 1
+    #   --> 0
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+};
+
+# No wallclock
+# Disables the wallclock.
+#
+cdl_option CYGIMP_WALLCLOCK_NONE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  !CYGPKG_KERNEL && 0 == CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS 
+    #     CYGPKG_KERNEL == current
+    #     CYGINT_WALLCLOCK_HW_IMPLEMENTATIONS == 1
+    #   --> 0
+};
+
+# Hardware wallclock
+#
+cdl_option CYGIMP_WALLCLOCK_HARDWARE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+    #     ActiveIf: CYGIMP_WALLCLOCK_HARDWARE
+};
+
+# <
+# Wallclock build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_WALLCLOCK_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_WALLCLOCK_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_WALLCLOCK_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Wallclock tests
+# This option specifies the set of tests for the
+# wallclock device.
+#
+cdl_option CYGPKG_IO_WALLCLOCK_TESTS {
+    # Calculated value:  CYGPKG_KERNEL ? "tests/wallclock tests/wallclock2" : "" 
+    #     CYGPKG_KERNEL == current
+    # Flavor: data
+    # Current_value: tests/wallclock tests/wallclock2
+};
+
+# <
+# Wallclock device driver for Dallas 12887
+# This package provides a file with init, get and set functions
+# for the Dallas 12887 clock part.
+#
+cdl_package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK == current
+    #   --> 1
+    # ActiveIf constraint: CYGIMP_WALLCLOCK_HARDWARE
+    #     CYGIMP_WALLCLOCK_HARDWARE == 1
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVICES_WALLCLOCK_I386_PC
+    #     Requires: CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+};
+
+# >
+# DS12887 wallclock build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# PC board RTC Driver
+# RTC driver for PC.
+#
+cdl_package CYGPKG_DEVICES_WALLCLOCK_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK == current
+    #   --> 1
+    # ActiveIf constraint: CYGPKG_HAL_I386_PC
+    #     CYGPKG_HAL_I386_PC == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+    #     CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 == current
+    #   --> 1
+};
+
+# >
+# IO port address of the ADDRESS register
+# This option sets the io address of the address port for
+# accessing the PC RTC
+#
+cdl_option CYGDAT_DEVS_WALLCLOCK_I386_PC_RTC_ADDRESS_PORT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00000070
+    # value_source default
+    # Default value: 0x00000070
+};
+
+# IO port address of the DATA register
+# This option sets the io address of the data port for
+# accessing the PC RTC
+#
+cdl_option CYGDAT_DEVS_WALLCLOCK_I386_PC_RTC_DATA_PORT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00000071
+    # value_source default
+    # Default value: 0x00000071
+};
+
+# <
+# <
+# Common error code support
+# This package contains the common list of error and
+# status codes. It is held centrally to allow
+# packages to interchange error codes and status
+# codes in a common way, rather than each package
+# having its own conventions for error/status
+# reporting. The error codes are modelled on the
+# POSIX style naming e.g. EINVAL etc. This package
+# also provides the standard strerror() function to
+# convert error codes to textual representation, as
+# well as an implementation of the errno idiom.
+#
+cdl_package CYGPKG_ERROR {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires:  CYGBLD_ISO_ERRNO_CODES_HEADER == "<cyg/error/codes.h>" 
+    #     CYGBLD_ISO_ERRNO_CODES_HEADER == <cyg/error/codes.h>
+    #   --> 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_GENERIC_16X5X
+    #     Requires: CYGPKG_ERROR
+    # package CYGPKG_IO_SERIAL_I386_PC
+    #     Requires: CYGPKG_ERROR
+    # package CYGPKG_IO
+    #     Requires: CYGPKG_ERROR
+    # package CYGPKG_IO_SERIAL
+    #     Requires: CYGPKG_ERROR
+    # package CYGPKG_POSIX
+    #     Requires: CYGPKG_ERROR
+    # package CYGPKG_IO_FILEIO
+    #     Requires: CYGPKG_ERROR
+};
+
+# >
+# errno variable
+# This package controls the behaviour of the
+# errno variable (or more strictly, expression)
+# from <errno.h>.
+#
+cdl_component CYGPKG_ERROR_ERRNO {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_ERRNO_HEADER == "<cyg/error/errno.h>" 
+    #     CYGBLD_ISO_ERRNO_HEADER == <cyg/error/errno.h>
+    #   --> 1
+};
+
+# >
+# Per-thread errno
+# This option controls whether the standard error
+# code reporting variable errno is a per-thread
+# variable, rather than global.
+#
+cdl_option CYGSEM_ERROR_PER_THREAD_ERRNO {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA == 1
+    #   --> 1
+};
+
+# Tracing level
+# Trace verbosity level for debugging the errno
+# retrieval mechanism in errno.cxx. Increase this
+# value to get additional trace output.
+#
+cdl_option CYGNUM_ERROR_ERRNO_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# <
+# strerror function
+# This package controls the presence and behaviour of the
+# strerror() function from <string.h>
+#
+cdl_option CYGPKG_ERROR_STRERROR {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STRERROR_HEADER == "<cyg/error/strerror.h>" 
+    #     CYGBLD_ISO_STRERROR_HEADER == <cyg/error/strerror.h>
+    #   --> 1
+};
+
+# Error package build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_ERROR_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the error package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_ERROR_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the error package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_ERROR_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# POSIX File IO compatibility layer
+# doc: ref/fileio.html
+# This package enables the POSIX compatibility
+# layer that implements IEEE 1003.1 file IO.
+#
+cdl_package CYGPKG_IO_FILEIO {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR == current
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO
+    #     CYGINT_ISO_ERRNO == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_ERRNO_CODES
+    #     CYGINT_ISO_ERRNO_CODES == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+    # Requires:  CYGBLD_ISO_DIRENT_HEADER == "<cyg/fileio/dirent.h>" 
+    #     CYGBLD_ISO_DIRENT_HEADER == <cyg/fileio/dirent.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_OPEN_MAX_HEADER == "<cyg/fileio/limits.h>" 
+    #     CYGBLD_ISO_OPEN_MAX_HEADER == <cyg/fileio/limits.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_NAME_MAX_HEADER == "<cyg/fileio/limits.h>" 
+    #     CYGBLD_ISO_NAME_MAX_HEADER == <cyg/fileio/limits.h>
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_FILE_SUPPORT
+    #     ActiveIf: !CYGPKG_IO_FILEIO
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     Requires: CYGPKG_IO_FILEIO
+    # component CYGPKG_IO_SERIAL_TERMIOS
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA && 0 != CYGPKG_IO_FILEIO &&  0 != CYGINT_ISO_ERRNO_CODES &&  0 != CYGINT_ISO_ERRNO 
+    # option CYGPKG_IO_SERIAL_SELECT_SUPPORT
+    #     ActiveIf: CYGPKG_IO_FILEIO
+    # option CYGPKG_LIBC_STDIO_FILEIO
+    #     ActiveIf: CYGPKG_IO_FILEIO
+    # option CYGPKG_LIBC_STDIO_TESTS
+    #     Calculated:  
+    #                     "tests/sprintf1 tests/sprintf2 tests/sscanf tests/stdiooutput " 
+    #                     . ((CYGPKG_IO_FILEIO && CYGPKG_FS_RAM) ? "tests/fileio " : "")
+    #                 
+};
+
+# >
+# Filesystems interfacing to FILEIO
+# Each filesystem driver which FILEIO can use implements
+# this interface. You can use this to determine if there are
+# any filesystems configured in the system.
+#
+cdl_interface CYGINT_IO_FILEIO_FS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Enable support for select()
+# This option enables support for select().
+#
+cdl_option CYGFUN_IO_FILEIO_SELECT {
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPKG_IO_SERIAL_SELECT_SUPPORT
+    #     Requires:  CYGFUN_IO_FILEIO_SELECT == 1 
+};
+
+# Enable devfs support
+# This option enables support for the devfs file system.
+#
+cdl_option CYGPKG_IO_FILEIO_DEVFS_SUPPORT {
+    # ActiveIf constraint: CYGPKG_IO
+    #     CYGPKG_IO == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGPKG_REDBOOT ? 0 : 1 
+    #     CYGPKG_REDBOOT (unknown) == 0
+    #   --> 1
+};
+
+# Enable socket support
+# This option enables support for the socket interface. It is
+# only present if the NET package is included.
+#
+cdl_option CYGPKG_IO_FILEIO_SOCKET_SUPPORT {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Maximum number of open files
+# This option controls the number of open files
+# that are allowed for all filesystems.
+#
+cdl_option CYGNUM_FILEIO_NFILE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: 1 to 9999999
+
+    # The following properties are affected by this value
+    # option CYGNUM_FILEIO_NFD
+    #     LegalValues: CYGNUM_FILEIO_NFILE to 9999999
+};
+
+# Maximum number of open file descriptors
+# This option controls the number of open file descriptors
+# that are allowed for all filesystems.
+#
+cdl_option CYGNUM_FILEIO_NFD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: CYGNUM_FILEIO_NFILE to 9999999
+    #     CYGNUM_FILEIO_NFILE == 16
+};
+
+# Maximum number of installed filesystems
+# This option controls the maximum number of filesystems
+# that can be handled by the fileio system.
+#
+cdl_option CYGNUM_FILEIO_FSTAB_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 1 to 9999999
+};
+
+# Maximum number of mounted filesystems
+# This option controls the maximum number of mounted
+# filesystems that can be handled by the fileio system.
+#
+cdl_option CYGNUM_FILEIO_MTAB_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: CYGNUM_FILEIO_MTAB_EXTRA to 9999999
+    #     CYGNUM_FILEIO_MTAB_EXTRA == 8
+};
+
+# Number of dynamically mounted filesystems
+# This option controls the number of mounted
+# filesystems that can be created dynamically.
+#
+cdl_option CYGNUM_FILEIO_MTAB_EXTRA {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 0 to 9999999
+
+    # The following properties are affected by this value
+    # option CYGNUM_FILEIO_MTAB_MAX
+    #     LegalValues: CYGNUM_FILEIO_MTAB_EXTRA to 9999999
+};
+
+# Maximum number of installed network stacks
+# This option controls the maximum number of installed
+# network stacks that can be handled by the fileio system.
+#
+cdl_option CYGNUM_FILEIO_NSTAB_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Legal values: 1 to 9999999
+};
+
+# Enable current directory tracking
+# This option enables tracking of the name of the current
+# directory in the FILEIO package, to support the getcwd()
+# function. When this option is enabled the FILEIO package
+# will attempt to maintain a string that names the current
+# directory. It does this textually, dealing with "." and
+# ".." entries by textual manipulation. While this should
+# always provide a path for the current directory, it may not
+# be the best, if symbolic links are present. This tracked CWD
+# is only used if a filesystem does not support the
+# FS_INFO_GETCWD key. 
+#
+cdl_option CYGPKG_IO_FILEIO_TRACK_CWD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Generic inode support
+# This option enables generic inode support useful to
+# some filesystems. Not all filesystems require this
+# so it is not enabled by default.
+#
+cdl_component CYGPKG_IO_FILEIO_INODE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+};
+
+# >
+# Maximum space for unused cached inodes
+# The inode cache allows a maximum limit to be set
+# for the number of unused inodes still in the
+# cache before they are freed. It may be set to 0
+# to indicate no dead inode caching should be
+# provided.
+#
+cdl_option CYGNUM_IO_FILEIO_MAX_INODE_CACHE_DEAD {
+    # This option is not active
+    # The parent CYGPKG_IO_FILEIO_INODE is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+};
+
+# <
+# Maximum size of iovec used by readv/writev
+# This option controls the maximum size of the iovec
+# structure that can be used by readv()/writev().  This
+# limit is required because the iovec structure must be
+# invariant (to the user), thus a copy needs to be made
+# by the interface routines.  The limit is merely a 
+# control over the amount of stack space used by the
+# readv()/writev() functions.
+#
+cdl_option CYGNUM_FILEIO_IOVEC_MAX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+    # Legal values: 1 to 9999999
+};
+
+# cyg_fs_getinfo call for disk usage
+# Enabling this option includes code in some filesystems to
+# implement a call using cyg_fs_getinfo to return the current
+# filesystem block usage.
+#
+cdl_option CYGSEM_FILEIO_INFO_DISK_USAGE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Fileio tests
+# This option specifies the set of tests for the FileIO package.
+#
+cdl_option CYGPKG_IO_FILEIO_TESTS {
+    # Calculated value:  "tests/fileio1 tests/socket tests/select tests/stdio tests/pselect" 
+    # Flavor: data
+    # Current_value: tests/fileio1 tests/socket tests/select tests/stdio tests/pselect
+};
+
+# <
+# EtherCAT Master
+# EtherCAT Master protocol stack
+#
+cdl_package CYGPKG_NET_ETHERCATMASTER {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_ETH_DRIVERS_ETHERCATMASTER
+    #     ActiveIf: CYGPKG_NET_ETHERCATMASTER
+};
+
+# >
+# EtherCAT Master log level
+# "Verbosity of logging information messages. Log level
+# 0 prevents anything from being logged. Level 1 will
+# only show fatal errors, level 2 shows all errors. Level
+# 3 adds warnings, end, level 4 finally also shows mere
+# informational messages." 
+#
+cdl_option CYGNUM_ETHERCATMASTER_LOG_LEVEL {
+    # Flavor: data
+    user_value 3
+    # value_source user
+    # Default value: 0
+    # Legal values: 0 1 2 3 4
+};
+
+# Delivery thread stack size
+# The EtherCAT ethernet device driver implements a delivery thread
+# which responds to incoming packets and sends out queued packets
+# as soon as the device is available again. This option determines
+# the stack size of this delivery thread.
+#
+cdl_option CYGNUM_ETHERCATMASTER_DELIVERY_STACK_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16384
+    # value_source default
+    # Default value: 16384
+};
+
+# Delivery thread priority
+# The EtherCAT ethernet device driver implements a delivery thread
+# which responds to incoming packets and sends out queued packets
+# as soon as the device is available again. This option determines
+# the priority of this delivery thread.
+#
+cdl_option CYGNUM_ETHERCATMASTER_DELIVERY_PRIORITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+    # Legal values: 0 to 31
+};
+
+# Ethernet device
+# Ethernet device to be used by the EtherCAT master
+#
+cdl_option CYGDAT_ETHERCATMASTER_ETH_DEVICE {
+    # Flavor: data
+    user_value "\"eth1\""
+    # value_source user
+    # Default value: "\"eth0\""
+};
+
+# Timeout value
+# Due to its implementation where slaves process
+# the EtherCAT frames on-the-fly,  EtherCAT frames
+# should return to the master 'instantaneously'.
+# Due to hardware problems (e.g. disconnecting a
+# slave from the logical ring,  sometimes frames
+# don't get back.  For this reason, a the rx part
+# implements a timeout after which it gives up.
+# This option determines the value of this
+# timeout, expressed in nanoseconds.
+#
+cdl_option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 20000000
+    # value_source default
+    # Default value: 20000000
+
+    # The following properties are affected by this value
+    # option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+};
+
+# Timeout value in ticks
+#
+cdl_option CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY_TICKS {
+    # Calculated value: ((CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+    #     CYGNUM_ETHERCATMASTER_TIMEOUT_DELAY == 20000000
+    #     CYGNUM_HAL_RTC_DENOMINATOR == 100
+    #     CYGNUM_HAL_RTC_NUMERATOR == 1000000000
+    # Flavor: data
+    # Current_value: 2
+};
+
+# Route thread stack size
+# The EtherCAT ethernet device driver implements a
+# periodic route thread which is used to check if any
+# of the EtherCAT slaves has posted something in its
+# mailbox.  This option determines the stack size of this
+# thread.
+#
+cdl_option CYGNUM_ETHERCATMASTER_ROUTE_STACK_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16384
+    # value_source default
+    # Default value: 16384
+};
+
+# Route thread priority
+# The EtherCAT ethernet device driver implements a period
+# route thread which is used to check if any of the
+# EtherCAT slaves has posted something in its mailbox.
+# This option determines the thread priority of this
+# thread.
+#
+cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PRIORITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+    # Legal values: 0 to 31
+};
+
+# Route thread period
+# The EtherCAT ethernet device driver implements a period
+# route thread which is used to check if any of the
+# EtherCAT slaves has posted something in its mailbox.
+# This option determines the period of this thread (and
+# thus the responsiveness of ROUTE commands)
+# expressed in nanoseconds.
+#
+cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 100000000
+    # value_source default
+    # Default value: 100000000
+
+    # The following properties are affected by this value
+    # option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD_TICKS
+    #     Calculated: ((CYGNUM_ETHERCATMASTER_ROUTE_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+};
+
+# Route thread period in ticks
+#
+cdl_option CYGNUM_ETHERCATMASTER_ROUTE_PERIOD_TICKS {
+    # Calculated value: ((CYGNUM_ETHERCATMASTER_ROUTE_PERIOD * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR)
+    #     CYGNUM_ETHERCATMASTER_ROUTE_PERIOD == 100000000
+    #     CYGNUM_HAL_RTC_DENOMINATOR == 100
+    #     CYGNUM_HAL_RTC_NUMERATOR == 1000000000
+    # Flavor: data
+    # Current_value: 10
+};
+
+# <
+# <
+
diff --git a/tests/ecos/ecos-i386/redboot/redboot.ecc ./tests/ecos/ecos-i386/redboot/redboot.ecc
new file mode 100644
index 0000000..c4c8a13
--- /dev/null
+++ ./tests/ecos/ecos-i386/redboot/redboot.ecc
@@ -0,0 +1,9312 @@
+# eCos saved configuration
+
+# ---- commands --------------------------------------------------------
+# This section contains information about the savefile format.
+# It should not be edited. Any modifications made to this section
+# may make it impossible for the configuration tools to read
+# the savefile.
+
+cdl_savefile_version 1;
+cdl_savefile_command cdl_savefile_version {};
+cdl_savefile_command cdl_savefile_command {};
+cdl_savefile_command cdl_configuration { description hardware template package };
+cdl_savefile_command cdl_package { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_component { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_option { value_source user_value wizard_value inferred_value };
+cdl_savefile_command cdl_interface { value_source user_value wizard_value inferred_value };
+
+# ---- toplevel --------------------------------------------------------
+# This section defines the toplevel configuration object. The only
+# values that can be changed are the name of the configuration and
+# the description field. It is not possible to modify the target,
+# the template or the set of packages simply by editing the lines
+# below because these changes have wide-ranging effects. Instead
+# the appropriate tools should be used to make such modifications.
+
+cdl_configuration eCos {
+    description "" ;
+
+    # These fields should not be modified.
+    hardware    pc_rltk8139 ;
+    template    redboot ;
+    package -hardware CYGPKG_HAL_I386 current ;
+    package -hardware CYGPKG_HAL_I386_GENERIC current ;
+    package -hardware CYGPKG_HAL_I386_PC current ;
+    package -hardware CYGPKG_HAL_I386_PCMB current ;
+    package -hardware CYGPKG_IO_PCI current ;
+    package -hardware CYGPKG_IO_SERIAL_GENERIC_16X5X current ;
+    package -hardware CYGPKG_IO_SERIAL_I386_PC current ;
+    package -hardware CYGPKG_DEVS_ETH_RLTK_8139 current ;
+    package -hardware CYGPKG_DEVS_ETH_I386_PC_RLTK8139 current ;
+    package -hardware CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 current ;
+    package -hardware CYGPKG_DEVICES_WALLCLOCK_I386_PC current ;
+    package CYGPKG_HAL current ;
+    package CYGPKG_INFRA current ;
+    package CYGPKG_REDBOOT current ;
+    package CYGPKG_ISOINFRA current ;
+    package CYGPKG_LIBC_STRING current ;
+    package CYGPKG_CRC current ;
+    package CYGPKG_IO_ETH_DRIVERS current ;
+    package CYGPKG_COMPRESS_ZLIB current ;
+    package CYGPKG_NS_DNS current ;
+    package CYGPKG_MEMALLOC current ;
+};
+
+# ---- conflicts -------------------------------------------------------
+# There are no conflicts.
+
+# ---- contents --------------------------------------------------------
+# >
+# >
+# Global build options
+# Global build options including control over
+# compiler flags, linker flags and choice of toolchain.
+#
+cdl_component CYGBLD_GLOBAL_OPTIONS {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Global command prefix
+# This option specifies the command prefix used when
+# invoking the build tools. If your host operating system
+# is Linux you can set this to empty to use your native tools.
+# If so, your native gcc must be gcc-2.95.2 or later, and
+# "ld -v" must report a version more recent than 2.9.1.
+#
+cdl_option CYGBLD_GLOBAL_COMMAND_PREFIX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value i386-elf
+    # value_source default
+    # Default value: i386-elf
+};
+
+# Global compiler flags
+# This option controls the global compiler flags which
+# are used to compile all packages by
+# default. Individual packages may define
+# options which override these global flags.
+#
+cdl_option CYGBLD_GLOBAL_CFLAGS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    # value_source default
+    # Default value: "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+
+    # The following properties are affected by this value
+    # option CYGBLD_INFRA_CFLAGS_WARNINGS_AS_ERRORS
+    #     Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -Werror") 
+    # option CYGBLD_INFRA_CFLAGS_PIPE
+    #     Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -pipe") 
+};
+
+# Global linker flags
+# This option controls the global linker flags. Individual
+# packages may define options which override these global flags.
+#
+cdl_option CYGBLD_GLOBAL_LDFLAGS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-g -nostdlib -Wl,--gc-sections -Wl,-static"
+    # value_source default
+    # Default value: "-g -nostdlib -Wl,--gc-sections -Wl,-static"
+};
+
+# Build GDB stub loader image
+# This option enables the building of the GDB stubs for the
+# board. The common HAL controls takes care of most of the
+# build process, but the final conversion from ELF image to
+# binary data is handled by the platform CDL, allowing
+# relocation of the data if necessary.
+#
+cdl_option CYGBLD_BUILD_GDB_STUBS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 1
+    # Requires: CYGSEM_HAL_ROM_MONITOR
+    #     CYGSEM_HAL_ROM_MONITOR == 1
+    #   --> 1
+    # Requires: CYGBLD_BUILD_COMMON_GDB_STUBS
+    #     CYGBLD_BUILD_COMMON_GDB_STUBS == 0
+    #   --> 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT == 1
+    #   --> 0
+    # Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    #     CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    #     CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM == 0
+    #   --> 1
+};
+
+# Build common GDB stub ROM image
+# Unless a target board has specific requirements to the
+# stub implementation, it can use a simple common stub.
+# This option, which gets enabled by platform HALs as
+# appropriate, controls the building of the common stub.
+#
+cdl_option CYGBLD_BUILD_COMMON_GDB_STUBS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGBLD_BUILD_COMMON_GDB_STUBS
+};
+
+# <
+# PCI configuration library
+# doc: ref/io-pci.html
+# The PCI configuration library provides initialization of devices
+# on the PCI bus. Functions to find and access these devices are
+# also provided.
+#
+cdl_package CYGPKG_IO_PCI {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# PCI build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_PCI_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the PCI configuration library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_PCI_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the PCI configuration library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_PCI_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Enable debugging.
+# This option enables minimal debugging of the PCI library.
+# In particular, it will print information about devices as the
+# PCI bus is being scanned/searched.
+#
+cdl_option CYGPKG_IO_PCI_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# PCI tests
+# This option specifies the set of tests for the PCI configuration library.
+#
+cdl_option CYGPKG_IO_PCI_TESTS {
+    # Calculated value:  "tests/pci1 tests/pci2" 
+    # Flavor: data
+    # Current_value: tests/pci1 tests/pci2
+};
+
+# Writeback Interrupt Line register.
+# This option causes a PCI device interrupt vector to be
+# written to the Interrupt Line register in config space.
+# This is traditionally done by a BIOS so that device
+# drivers can read the interrupt vector directly from
+# device configuration space.
+#
+cdl_option CYGPKG_IO_PCI_CONFIGURE_INTLINE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# <
+# 16x5x generic serial device drivers
+# This option enables the serial device drivers for the
+# 16x5x compatiple controllers.
+#
+cdl_package CYGPKG_IO_SERIAL_GENERIC_16X5X {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_IO_SERIAL
+    #     CYGPKG_IO_SERIAL (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint: CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED
+    #     CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED == 0
+    #   --> 0
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR (unknown) == 0
+    #   --> 0
+};
+
+# >
+# 16x5x FIFO support
+# Options to configure the FIFO on a 16550 (or above) variant.
+#
+cdl_component CYGPKG_IO_SERIAL_GENERIC_16X5X_FIFO {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_GENERIC_16X5X is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Threshold for RX interrupt on 16550 FIFO
+# This options configures the threshold value at which
+# the RX interrupt occurs when a FIFO is used. (16550 and
+# above only), this may be after 1, 4, 8 or 14 characters.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_FIFO_RX_THRESHOLD {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_GENERIC_16X5X_FIFO is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Legal values:  14 8 4 1 
+};
+
+# <
+# Serial device driver build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_SERIAL_GENERIC_16X5X_OPTIONS {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_GENERIC_16X5X is not active
+
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are
+# used in addition to the set of global flags.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_CFLAGS_ADD {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_GENERIC_16X5X_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are
+# removed from the set of global flags if present.
+#
+cdl_option CYGPKG_IO_SERIAL_GENERIC_16X5X_CFLAGS_REMOVE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_GENERIC_16X5X_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# PC serial device drivers
+# This option enables the serial device drivers for the
+# PC.
+#
+cdl_package CYGPKG_IO_SERIAL_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_IO_SERIAL
+    #     CYGPKG_IO_SERIAL (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint: CYGPKG_HAL_I386_PCMB
+    #     CYGPKG_HAL_I386_PCMB == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ERROR
+    #     CYGPKG_ERROR (unknown) == 0
+    #   --> 0
+};
+
+# >
+# Generic 16x5x serial driver required
+#
+cdl_interface CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED {
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL0, inactive, enabled
+    # Implemented by CYGPKG_IO_SERIAL_I386_PC_SERIAL1, inactive, enabled
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC is not active
+
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_GENERIC_16X5X
+    #     ActiveIf: CYGINT_IO_SERIAL_GENERIC_16X5X_REQUIRED
+};
+
+# PC serial port 0 driver
+# This option includes the serial device driver for port 0 on the 
+# PC.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_SERIAL0 {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_IO_SERIAL_I386_PC_TESTING
+    #     ActiveIf: CYGPKG_IO_SERIAL_I386_PC_SERIAL0
+};
+
+# >
+# Device name for PC serial port 0
+# This option specifies the device name port 0 on the PC.
+#
+cdl_option CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser0\""
+    # value_source default
+    # Default value: "\"/dev/ser0\""
+
+    # The following properties are affected by this value
+    # option CYGPRI_SER_TEST_SER_DEV
+    #     DefaultValue:  CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME 
+};
+
+# Baud rate for the PC serial port 0 driver
+# This option specifies the default baud rate (speed) for the
+# PC port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_BAUD {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values:  50 75 110 "134_5" 150 200 300 600 1200 1800 2400 3600
+    #                           4800 7200 9600 14400 19200 38400 57600 115200 230400
+    #             
+};
+
+# Buffer size for the PC serial port 0 driver
+# This option specifies the size of the internal buffers used
+# for the PC port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_BUFSIZE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+    # Legal values: 0 to 8192
+};
+
+# I/O base address for the i386-PC serial port 0
+# This option specifies the I/O address of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IOBASE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000003F8
+    # value_source default
+    # Default value: 0x000003F8
+    # Legal values: 0 to 0xFF8
+};
+
+# IRQ for the i386-PC serial port 0
+# This option specifies the IRQ of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 0 to 15
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_INT
+    #     DefaultValue:  CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ + 32 
+};
+
+# INT for the i386-PC serial port 0
+# This option specifies the interrupt vector of the 8250 or 16550 for serial port 0.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL0_INT {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL0 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value:  CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ + 32 
+    #     CYGNUM_IO_SERIAL_I386_PC_SERIAL0_IRQ == 0
+    #   --> 32
+    # Legal values: 32 to 47
+};
+
+# <
+# PC serial port 1 driver
+# This option includes the serial device driver for port 1 on
+# the PC.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_SERIAL1 {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Device name for PC serial port 1
+# This option specifies the device name port 1 on the PC.
+#
+cdl_option CYGDAT_IO_SERIAL_I386_PC_SERIAL1_NAME {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"/dev/ser1\""
+    # value_source default
+    # Default value: "\"/dev/ser1\""
+};
+
+# Baud rate for the PC serial port 1 driver
+# This option specifies the default baud rate (speed) for the
+# PC port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_BAUD {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values:  50 75 110 "134_5" 150 200 300 600 1200 1800 2400 3600
+    #                           4800 7200 9600 14400 19200 38400 57600 115200 230400
+    #             
+};
+
+# Buffer size for the PC serial port 1 driver
+# This option specifies the size of the internal buffers used
+# for the PC port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_BUFSIZE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+    # Legal values: 0 to 8192
+};
+
+# I/O base address for the i386-PC serial port 1
+# This option specifies the I/O address of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IOBASE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000002F8
+    # value_source default
+    # Default value: 0x000002F8
+    # Legal values: 0 to 0xFF8
+};
+
+# IRQ for the i386-PC serial port 1
+# This option specifies the IRQ of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value: 3
+    # Legal values: 0 to 15
+
+    # The following properties are affected by this value
+    # option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_INT
+    #     DefaultValue:  CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ + 32 
+};
+
+# INT for the i386-PC serial port 1
+# This option specifies the interrupt vector of the 8250 or 16550 for serial port 1.
+#
+cdl_option CYGNUM_IO_SERIAL_I386_PC_SERIAL1_INT {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_SERIAL1 is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value:  CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ + 32 
+    #     CYGNUM_IO_SERIAL_I386_PC_SERIAL1_IRQ == 0
+    #   --> 32
+    # Legal values: 32 to 47
+};
+
+# <
+# Serial device driver build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_OPTIONS {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC is not active
+
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_SERIAL_I386_PC_CFLAGS_ADD {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building these serial device drivers. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_IO_SERIAL_I386_PC_CFLAGS_REMOVE {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# Testing parameters
+#
+cdl_component CYGPKG_IO_SERIAL_I386_PC_TESTING {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC is not active
+    # ActiveIf constraint: CYGPKG_IO_SERIAL_I386_PC_SERIAL0
+    #     CYGPKG_IO_SERIAL_I386_PC_SERIAL0 == 0
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Serial device used for testing
+#
+cdl_option CYGPRI_SER_TEST_SER_DEV {
+    # This option is not active
+    # The parent CYGPKG_IO_SERIAL_I386_PC_TESTING is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME 
+    #     CYGDAT_IO_SERIAL_I386_PC_SERIAL0_NAME == 0
+    #   --> 0
+};
+
+# <
+# <
+# Wallclock device driver for Dallas 12887
+# This package provides a file with init, get and set functions
+# for the Dallas 12887 clock part.
+#
+cdl_package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint: CYGIMP_WALLCLOCK_HARDWARE
+    #     CYGIMP_WALLCLOCK_HARDWARE == 1
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVICES_WALLCLOCK_I386_PC
+    #     Requires: CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+};
+
+# >
+# DS12887 wallclock build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_OPTIONS {
+    # This option is not active
+    # The parent CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 is not active
+
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_CFLAGS_ADD {
+    # This option is not active
+    # The parent CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the wallclock device. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_CFLAGS_REMOVE {
+    # This option is not active
+    # The parent CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887_OPTIONS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# Hardware wallclock
+#
+cdl_option CYGIMP_WALLCLOCK_HARDWARE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+    #     ActiveIf: CYGIMP_WALLCLOCK_HARDWARE
+};
+
+# PC board RTC Driver
+# RTC driver for PC.
+#
+cdl_package CYGPKG_DEVICES_WALLCLOCK_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_IO_WALLCLOCK
+    #     CYGPKG_IO_WALLCLOCK (unknown) == 0
+    #   --> 0
+    # ActiveIf constraint: CYGPKG_HAL_I386_PC
+    #     CYGPKG_HAL_I386_PC == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887
+    #     CYGPKG_DEVICES_WALLCLOCK_DALLAS_DS12887 == 0
+    #   --> 0
+};
+
+# >
+# IO port address of the ADDRESS register
+# This option sets the io address of the address port for
+# accessing the PC RTC
+#
+cdl_option CYGDAT_DEVS_WALLCLOCK_I386_PC_RTC_ADDRESS_PORT {
+    # This option is not active
+    # The parent CYGPKG_DEVICES_WALLCLOCK_I386_PC is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00000070
+    # value_source default
+    # Default value: 0x00000070
+};
+
+# IO port address of the DATA register
+# This option sets the io address of the data port for
+# accessing the PC RTC
+#
+cdl_option CYGDAT_DEVS_WALLCLOCK_I386_PC_RTC_DATA_PORT {
+    # This option is not active
+    # The parent CYGPKG_DEVICES_WALLCLOCK_I386_PC is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00000071
+    # value_source default
+    # Default value: 0x00000071
+};
+
+# <
+# ISO C library string functions
+# doc: ref/libc.html
+# This package provides string functions specified by the
+# ISO C standard - ISO/IEC 9899:1990.
+#
+cdl_package CYGPKG_LIBC_STRING {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires:  CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRING_MEMFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_MEMFUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRING_STRFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRING_STRFUNCS_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires:  CYGBLD_ISO_STRTOK_R_HEADER ==  "<cyg/libc/string/string.h>" 
+    #     CYGBLD_ISO_STRTOK_R_HEADER == <cyg/libc/string/string.h>
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+};
+
+# >
+# Inline versions of <string.h> functions
+# This option chooses whether some of the
+# particularly simple string functions from
+# <string.h> are available as inline
+# functions. This may improve performance, and as
+# the functions are small, may even improve code
+# size.
+#
+cdl_option CYGIMP_LIBC_STRING_INLINES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Optimize string functions for code size
+# This option tries to reduce string function
+# code size at the expense of execution speed. The
+# same effect can be produced if the code is
+# compiled with the -Os option to the compiler.
+#
+cdl_option CYGIMP_LIBC_STRING_PREFER_SMALL_TO_FAST {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide BSD compatibility functions
+# Enabling this option causes various compatibility functions
+# commonly found in the BSD UNIX operating system to be included.
+# These are functions such as bzero, bcmp, bcopy, bzero, strcasecmp,
+# strncasecmp, index, rindex and swab.
+#
+cdl_option CYGFUN_LIBC_STRING_BSD_FUNCS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # The inferred value should not be edited directly.
+    inferred_value 0
+    # value_source inferred
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_STRING_BSD_FUNCS_HEADER ==  "<cyg/libc/string/bsdstring.h>" 
+    #     CYGBLD_ISO_STRING_BSD_FUNCS_HEADER == <cyg/libc/string/bsdstring.h>
+    #   --> 1
+    # Requires: CYGINT_ISO_CTYPE
+    #     CYGINT_ISO_CTYPE == 0
+    #   --> 0
+};
+
+# strtok
+# These options control the behaviour of the
+# strtok() and strtok_r() string tokenization
+# functions.
+#
+cdl_component CYGPKG_LIBC_STRING_STRTOK {
+    # There is no associated value.
+};
+
+# >
+# Per-thread strtok()
+# This option controls whether the string function
+# strtok() has its state recorded on a per-thread
+# basis rather than global. If this option is
+# disabled, some per-thread space can be saved.
+# Note there is also a POSIX-standard strtok_r()
+# function to achieve a similar effect with user
+# support. Enabling this option will use one slot
+# of kernel per-thread data. You should ensure you
+# have enough slots configured for all your
+# per-thread data.
+#
+cdl_option CYGSEM_LIBC_STRING_PER_THREAD_STRTOK {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA (unknown) == 0
+    #   --> 0
+    # Requires: CYGVAR_KERNEL_THREADS_DATA
+    #     CYGVAR_KERNEL_THREADS_DATA (unknown) == 0
+    #   --> 0
+};
+
+# Tracing level
+# Trace verbosity level for debugging the <string.h>
+# functions strtok() and strtok_r(). Increase this
+# value to get additional trace output.
+#
+cdl_option CYGNUM_LIBC_STRING_STRTOK_TRACE_LEVEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to 1
+};
+
+# <
+# strdup
+# This option indicates whether strdup() is to be supported.
+#
+cdl_option CYGFUN_LIBC_STRING_STRDUP {
+    # ActiveIf constraint: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# C library string functions build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_LIBC_STRING_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_LIBC_STRING_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the C library. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_LIBC_STRING_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# C library string function tests
+# This option specifies the set of tests for the C library
+# string functions.
+#
+cdl_option CYGPKG_LIBC_STRING_TESTS {
+    # Calculated value:  "tests/memchr tests/memcmp1 tests/memcmp2 tests/memcpy1 tests/memcpy2 tests/memmove1 tests/memmove2 tests/memset tests/strcat1 tests/strcat2 tests/strchr tests/strcmp1 tests/strcmp2 tests/strcoll1 tests/strcoll2 tests/strcpy1 tests/strcpy2 tests/strcspn tests/strcspn tests/strlen tests/strncat1 tests/strncat2 tests/strncpy1 tests/strncpy2 tests/strpbrk tests/strrchr tests/strspn tests/strstr tests/strtok tests/strxfrm1 tests/strxfrm2" 
+    # Flavor: data
+    # Current_value: tests/memchr tests/memcmp1 tests/memcmp2 tests/memcpy1 tests/memcpy2 tests/memmove1 tests/memmove2 tests/memset tests/strcat1 tests/strcat2 tests/strchr tests/strcmp1 tests/strcmp2 tests/strcoll1 tests/strcoll2 tests/strcpy1 tests/strcpy2 tests/strcspn tests/strcspn tests/strlen tests/strncat1 tests/strncat2 tests/strncpy1 tests/strncpy2 tests/strpbrk tests/strrchr tests/strspn tests/strstr tests/strtok tests/strxfrm1 tests/strxfrm2
+};
+
+# <
+# <
+# Common ethernet support
+# doc: ref/io-eth-drv-generic.html
+# Platform independent ethernet drivers
+#
+cdl_package CYGPKG_IO_ETH_DRIVERS {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_RLTK_8139
+    #     ActiveIf: CYGPKG_IO_ETH_DRIVERS
+    # package CYGPKG_DEVS_ETH_I386_PC_RLTK8139
+    #     ActiveIf: CYGPKG_IO_ETH_DRIVERS
+    # component CYGPKG_REDBOOT_NETWORKING
+    #     ActiveIf: CYGPKG_IO_ETH_DRIVERS
+};
+
+# >
+# Network drivers
+#
+cdl_interface CYGHWR_NET_DRIVERS {
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0, active, enabled
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_REDBOOT_DEFAULT_NETWORK_DEVICE
+    #     ActiveIf:  !CYGSEM_REDBOOT_FLASH_CONFIG && CYGHWR_NET_DRIVERS > 1 
+    # option CYGNUM_REDBOOT_DEFAULT_NETWORK_DEVICE
+    #     LegalValues: 0 to CYGHWR_NET_DRIVERS-1
+    # option CYGSEM_REDBOOT_NETWORK_INIT_ONE_DEVICE
+    #     ActiveIf:  CYGHWR_NET_DRIVERS > 1 
+};
+
+# Driver supports multicast addressing
+# This interface defines whether or not a driver can handle
+# requests for multicast addressing.
+#
+cdl_interface CYGINT_IO_ETH_MULTICAST {
+    # Implemented by CYGPKG_DEVS_ETH_RLTK_8139, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# Support printing driver debug information
+# Selecting this option will include code to allow the driver to
+# print lots of information on diagnostic output such as full
+# packet dumps.
+#
+cdl_component CYGDBG_IO_ETH_DRIVERS_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Driver debug output verbosity
+# The value of this option indicates the default verbosity
+# level of debugging output. 0 means no debugging output
+# is made by default. Higher values indicate higher verbosity.
+# The verbosity level may also be changed at run time by
+# changing the variable cyg_io_eth_net_debug.
+#
+cdl_option CYGDBG_IO_ETH_DRIVERS_DEBUG_VERBOSITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Size of scatter-gather I/O lists
+# A scatter-gather list is used to pass requests to/from
+# the physical device driver.  This list can typically be
+# small, as the data is normally already packed into reasonable
+# chunks.
+#
+cdl_option CYGNUM_IO_ETH_DRIVERS_SG_LIST_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+};
+
+# Support for standard eCos TCP/IP stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_NET {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+};
+
+# >
+# Warn when there are no more mbufs
+# Warnings about running out of mbufs are printed to the
+# diagnostic output channel via diag_printf() if this option
+# is enabled.  Mbufs are the network stack's basic dynamic
+# memory objects that hold all packets in transit; running
+# out is bad for performance but not fatal, not a crash.
+# You might want to turn off the warnings to preserve realtime
+# properties of the system even in extremis.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_WARN_NO_MBUFS {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_NET is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Simulate network failures for testing
+# This package contains a suite of simulated failure modes
+# for the ethernet device layer, including dropping and/or
+# corrupting received packets, dropping packets queued for
+# transmission, and simulating a complete network break.
+# It requires the kernel as a source of time information.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_NET is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Drop incoming packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_DROP_RX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Corrupt incoming packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_CORRUPT_RX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Drop outgoing packets (percentage)
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_DROP_TX {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 10
+    # value_source default
+    # Default value: 1 10
+    # Legal values: 10 50 80
+};
+
+# Simulate a line cut from time to time
+# This option causes the system to drop all packets for a
+# short random period (10s of seconds), and then act
+# normally for up to 4 times that long.  This simulates your
+# sysadmin fiddling with plugs in the network switch
+# cupboard.
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_SIMULATE_LINE_CUT {
+    # This option is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is not active
+    # The parent CYGPKG_IO_ETH_DRIVERS_SIMULATED_FAILURES is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# <
+# Support for stand-alone network stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_STAND_ALONE {
+    # ActiveIf constraint: !CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGINT_ISO_STRING_MEMFUNCS
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+};
+
+# >
+# Pass packets to an alternate stack
+# Define this to allow packets seen by this layer to be
+# passed on to the previous logical layer, i.e. when
+# stand-alone processing replaces system (eCos) processing.
+#
+cdl_option CYGSEM_IO_ETH_DRIVERS_PASS_PACKETS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_REDBOOT_NETWORKING 
+    #     CYGPKG_REDBOOT_NETWORKING == 1
+    #   --> 1
+};
+
+# Number of [network] buffers
+# This option is used to allocate space to buffer incoming network
+# packets.  These buffers are used to hold data until they can be
+# logically processed by higher layers.
+#
+cdl_option CYGNUM_IO_ETH_DRIVERS_NUM_PKT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 2 to 32
+};
+
+# Show driver warnings
+# Selecting this option will allows the stand-alone ethernet driver
+# to display warnings on the system console when incoming network
+# packets are being discarded due to lack of buffer space.
+#
+cdl_option CYGSEM_IO_ETH_DRIVERS_WARN {
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Support for lwIP network stack.
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_LWIP {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET_LWIP
+    #     CYGPKG_NET_LWIP (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: !CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 1
+};
+
+# Interrupt support required
+# This interface is used to indicate to the low
+# level device drivers that interrupt driven operation
+# is required by higher layers.
+#
+cdl_interface CYGINT_IO_ETH_INT_SUPPORT_REQUIRED {
+    # Implemented by CYGPKG_IO_ETH_DRIVERS_NET, inactive, enabled
+    # Implemented by CYGPKG_IO_ETH_DRIVERS_LWIP, inactive, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+
+    # The following properties are affected by this value
+};
+
+# Common ethernet support build options
+#
+cdl_component CYGPKG_IO_ETH_DRIVERS_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the common ethernet support package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_IO_ETH_DRIVERS_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D_KERNEL -D__ECOS"
+    # value_source default
+    # Default value: "-D_KERNEL -D__ECOS"
+};
+
+# <
+# RealTek 8139 ethernet driver
+# Ethernet driver for RealTek 8139 controller.
+#
+cdl_package CYGPKG_DEVS_ETH_RLTK_8139 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+    # ActiveIf constraint: CYGINT_DEVS_ETH_RLTK_8139_REQUIRED
+    #     CYGINT_DEVS_ETH_RLTK_8139_REQUIRED == 1
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# Share interrupt with other devices
+# If this option is enabled, the driver does not assume that it is
+# in sole possession of the interrupt pin used by the 8139.
+#
+cdl_component CYGPKG_DEVS_ETH_RLTK_8139_SHARE_INTERRUPTS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Mask 8139 interrupts on chip
+# If this option is enabled, the driver masks interrupts in the 8139's
+# status register, and does not mask the interrupt vector. This is
+# only useful if the 8139 must share it's interrupt line with other
+# devices.
+#
+cdl_option CYGPKG_DEVS_ETH_RLTK_8139_MASK_INTERRUPTS_IN_8139 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Print debugging messages
+# If this option is set, a lot of debugging messages are printed
+# to the console to help debug the driver.
+#
+cdl_option CYGDBG_DEVS_ETH_RLTK_8139_CHATTER {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Size of the receive ring
+# The 8139 stores all received packets in a single 'rx ring'
+# located somewhere in physical memory. The size of this ring
+# can be varied from ~8k to ~64k; however the driver currently
+# supports a maximum buffer size of only ~32k (so we can use
+# the 8139's WRAP mode). The actual buffer size is
+# 8192<<x + 16 + 1536 bytes, with x being the value of this
+# option.
+#
+cdl_option CYGNUM_DEVS_ETH_RLTK_8139_RX_BUF_LEN_IDX {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGPKG_REDBOOT ? 0 : 2 
+    #     CYGPKG_REDBOOT == current
+    #   --> 0
+    # Legal values: 0 to 2
+};
+
+# RealTek 8139 ethernet driver build options
+#
+cdl_component CYGPKG_DEVS_ETH_RLTK_8139_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the RealTek 8139 ethernet driver package. These
+# flags are used in addition to the set of global flags.
+#
+cdl_option CYGPKG_DEVS_ETH_RLTK_8139_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D_KERNEL -D__ECOS"
+    # value_source default
+    # Default value: "-D_KERNEL -D__ECOS"
+};
+
+# <
+# <
+# PC RealTek 8139 ethernet driver
+# Ethernet driver for standard PC's.
+#
+cdl_package CYGPKG_DEVS_ETH_I386_PC_RLTK8139 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # ActiveIf constraint: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+    # ActiveIf constraint: CYGPKG_HAL_I386_PC
+    #     CYGPKG_HAL_I386_PC == current
+    #   --> 1
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# >
+# RealTek 8139 ethernet driver required
+#
+cdl_interface CYGINT_DEVS_ETH_RLTK_8139_REQUIRED {
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0, active, enabled
+    # Implemented by CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1, active, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_RLTK_8139
+    #     ActiveIf: CYGINT_DEVS_ETH_RLTK_8139_REQUIRED
+};
+
+# Ethernet port 0 driver
+#
+cdl_component CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH0 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Device name for the ETH0 ethernet port 0 driver
+# This option sets the name of the ethernet device for the
+# RealTek 8139 ethernet port 0.
+#
+cdl_option CYGDAT_DEVS_ETH_I386_PC_RLTK8139_ETH0_NAME {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"eth0\""
+    # value_source default
+    # Default value: "\"eth0\""
+};
+
+# <
+# Ethernet port 1 driver
+#
+cdl_component CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1 {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Device name for the ETH1 ethernet port 1 driver
+# This option sets the name of the ethernet device for the
+# RealTek 8139 ethernet port 1.
+#
+cdl_option CYGDAT_DEVS_ETH_I386_PC_RLTK8139_ETH1_NAME {
+    # This option is not active
+    # The parent CYGPKG_DEVS_ETH_I386_PC_RLTK8139_ETH1 is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "\"eth1\""
+    # value_source default
+    # Default value: "\"eth1\""
+};
+
+# <
+# <
+# <
+# <
+# eCos HAL
+# doc: ref/the-ecos-hardware-abstraction-layer.html
+# The eCos HAL package provide a porting layer for
+# higher-level parts of the system such as the kernel and the
+# C library. Each installation should have HAL packages for
+# one or more architectures, and for each architecture there
+# may be one or more supported platforms. It is necessary to
+# select one target architecture and one platform for that
+# architecture. There are also a number of configuration
+# options that are common to all HAL packages.
+#
+cdl_package CYGPKG_HAL {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_INFRA
+    #     CYGPKG_INFRA == current
+    #   --> 1
+
+    # The following properties are affected by this value
+};
+
+# >
+# Platform-independent HAL options
+# A number of configuration options are common to most or all
+# HAL packages, for example options controlling how much state
+# should be saved during a context switch. The implementations
+# of these options will vary from architecture to architecture.
+#
+cdl_component CYGPKG_HAL_COMMON {
+    # There is no associated value.
+};
+
+# >
+# Provide eCos kernel support
+# The HAL can be configured to either support the full eCos
+# kernel, or to support only very simple applications which do
+# not require a full kernel. If kernel support is not required
+# then some of the startup, exception, and interrupt handling
+# code can be eliminated.
+#
+cdl_option CYGFUN_HAL_COMMON_KERNEL_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+};
+
+# HAL exception support
+# When a processor exception occurs, for example an attempt to
+# execute an illegal instruction or to perform a divide by
+# zero, this exception may be handled in a number of different
+# ways. If the target system has gdb support then typically
+# the exception will be handled by gdb code. Otherwise if the
+# HAL exception support is enabled then the HAL will invoke a
+# routine deliver_exception(). Typically this routine will be
+# provided by the eCos kernel, but it is possible for
+# application code to provide its own implementation. If the
+# HAL exception support is not enabled and a processor
+# exception occurs then the behaviour of the system is
+# undefined.
+#
+cdl_option CYGPKG_HAL_EXCEPTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGPKG_KERNEL_EXCEPTIONS
+    #     CYGPKG_KERNEL_EXCEPTIONS (unknown) == 0
+    #   --> 0
+    # Requires: CYGPKG_KERNEL_EXCEPTIONS
+    #     CYGPKG_KERNEL_EXCEPTIONS (unknown) == 0
+    #   --> 0
+};
+
+# Stop calling constructors early
+# This option supports environments where some constructors
+# must be run in the context of a thread rather than at
+# simple system startup time. A boolean flag named
+# cyg_hal_stop_constructors is set to 1 when constructors
+# should no longer be invoked. It is up to some other
+# package to deal with the rest of the constructors.
+# In the current version this is only possible with the
+# C library.
+#
+cdl_option CYGSEM_HAL_STOP_CONSTRUCTORS_ON_FLAG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS
+    #     CYGSEM_LIBC_INVOKE_DEFAULT_STATIC_CONSTRUCTORS (unknown) == 0
+    #   --> 0
+};
+
+# HAL uses the MMU and allows for CDL manipulation of it's use
+#
+cdl_interface CYGINT_HAL_SUPPORTS_MMU_TABLES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     ActiveIf: CYGINT_HAL_SUPPORTS_MMU_TABLES
+};
+
+# Install MMU tables.
+# This option controls whether this application installs
+# its own Memory Management Unit (MMU) tables, or relies on the
+# existing environment to run.
+#
+cdl_option CYGSEM_HAL_INSTALL_MMU_TABLES {
+    # This option is not active
+    # ActiveIf constraint: CYGINT_HAL_SUPPORTS_MMU_TABLES
+    #     CYGINT_HAL_SUPPORTS_MMU_TABLES == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYG_HAL_STARTUP != "RAM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_STATIC_MMU_TABLES
+    #     Requires: CYGSEM_HAL_INSTALL_MMU_TABLES
+};
+
+# Use static MMU tables.
+# This option defines an environment where any Memory
+# Management Unit (MMU) tables are constant.  Normally used by ROM
+# based environments, this provides a way to save RAM usage which
+# would otherwise be required for these tables.
+#
+cdl_option CYGSEM_HAL_STATIC_MMU_TABLES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     CYGSEM_HAL_INSTALL_MMU_TABLES == 0
+    #   --> 0
+};
+
+# Route diagnostic output to debug channel
+# If not inheriting the console setup from the ROM monitor,
+# it is possible to redirect diagnostic output to the debug
+# channel by enabling this option. Depending on the debugger
+# used it may also be necessary to select a mangler for the
+# output to be displayed by the debugger.
+#
+cdl_component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN {
+    # ActiveIf constraint: !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE == 0
+    #   --> 1
+    # ActiveIf constraint:  CYGPKG_HAL_ARM || CYGPKG_HAL_POWERPC_MPC8xx  || CYGPKG_HAL_V85X_V850 || CYGSEM_HAL_VIRTUAL_VECTOR_DIAG 
+    #     CYGPKG_HAL_ARM (unknown) == 0
+    #     CYGPKG_HAL_POWERPC_MPC8xx (unknown) == 0
+    #     CYGPKG_HAL_V85X_V850 (unknown) == 0
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_DIAG == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+    #     Calculated:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+};
+
+# >
+# Mangler used on diag output
+# It is sometimes necessary to mangle (encode) the
+# diag ASCII text output in order for it to show up at the
+# other end. In particular, GDB may silently ignore raw
+# ASCII text.
+#
+cdl_option CYGSEM_HAL_DIAG_MANGLER {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value GDB
+    # value_source default
+    # Default value: GDB
+    # Legal values: "GDB" "None"
+};
+
+# <
+# <
+# HAL interrupt handling
+# A number of configuration options related to interrupt
+# handling are common to most or all HAL packages, even though
+# the implementations will vary from architecture to
+# architecture.
+#
+cdl_component CYGPKG_HAL_COMMON_INTERRUPTS {
+    # There is no associated value.
+};
+
+# >
+# Use separate stack for interrupts
+# When an interrupt occurs this interrupt can be handled either
+# on the current stack or on a separate stack maintained by the
+# HAL. Using a separate stack requires a small number of extra
+# instructions in the interrupt handling code, but it has the
+# advantage that it is no longer necessary to allow extra space
+# in every thread stack for the interrupt handlers. The amount
+# of extra space required depends on the interrupt handlers
+# that are being used.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # package CYGPKG_REDBOOT
+    #     Requires:  CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK == 0 
+};
+
+# Interrupt stack size
+# This configuration option specifies the stack size in bytes
+# for the interrupt stack. Typically this should be a multiple
+# of 16, but the exact requirements will vary from architecture
+# to architecture. The interrupt stack serves two separate
+# purposes. It is used as the stack during system
+# initialization. In addition, if the interrupt system is
+# configured to use a separate stack then all interrupts will
+# be processed on this stack. The exact memory requirements
+# will vary from application to application, and will depend
+# heavily on whether or not other interrupt-related options,
+# for example nested interrupts, are enabled. On most targets,
+# in a configuration with no kernel this stack will also be
+# the stack used to invoke the application, and must obviously
+# be appropriately large in that case.
+#
+cdl_option CYGNUM_HAL_COMMON_INTERRUPTS_STACK_SIZE {
+    # Flavor: data
+    user_value 4096
+    # value_source user
+    # Default value:  CYGPKG_KERNEL ? 4096 : 32768 
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 32768
+    # Legal values: 128 to 1048576
+};
+
+# Allow nested interrupts
+# When an interrupt occurs the HAL interrupt handling code can
+# either leave interrupts disabled for the duration of the
+# interrupt handling code, or by doing some extra work it can
+# reenable interrupts before invoking the interrupt handler and
+# thus allow nested interrupts to happen. If all the interrupt
+# handlers being used are small and do not involve any loops
+# then it is usually better to disallow nested interrupts.
+# However if any of the interrupt handlers are more complicated
+# than nested interrupts will usually be required.
+#
+cdl_option CYGSEM_HAL_COMMON_INTERRUPTS_ALLOW_NESTING {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Save minimum context on interrupt
+# The HAL interrupt handling code can exploit the calling conventions
+# defined for a given architecture to reduce the amount of state
+# that has to be saved. Generally this improves performance and
+# reduces code size. However it can make source-level debugging
+# more difficult.
+#
+cdl_option CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+};
+
+# Chain all interrupts together
+# Interrupts can be attached to vectors either singly, or be
+# chained together. The latter is necessary if there is no way
+# of discovering which device has interrupted without
+# inspecting the device itself. It can also reduce the amount
+# of RAM needed for interrupt decoding tables and code.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_CHAIN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Ignore spurious [fleeting] interrupts
+# On some hardware, interrupt sources may not be de-bounced or
+# de-glitched.  Rather than try to handle these interrupts (no
+# handling may be possible), this option allows the HAL to simply
+# ignore them.  In most cases, if the interrupt is real it will
+# reoccur in a detectable form.
+#
+cdl_option CYGIMP_HAL_COMMON_INTERRUPTS_IGNORE_SPURIOUS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# HAL context switch support
+# A number of configuration options related to thread contexts
+# are common to most or all HAL packages, even though the
+# implementations will vary from architecture to architecture.
+#
+cdl_component CYGPKG_HAL_COMMON_CONTEXT {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Use minimum thread context
+# The thread context switch code can exploit the calling
+# conventions defined for a given architecture to reduce the
+# amount of state that has to be saved during a context
+# switch. Generally this improves performance and reduces
+# code size. However it can make source-level debugging more
+# difficult.
+#
+cdl_option CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM {
+    # Flavor: bool
+    user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 0
+    # value_source user
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+};
+
+# <
+# Explicit control over cache behaviour
+# These options let the default behaviour of the caches 
+# be easily configurable.
+#
+cdl_component CYGPKG_HAL_CACHE_CONTROL {
+    # There is no associated value.
+};
+
+# >
+# Enable DATA cache on startup
+# Enabling this option will cause the data cache to be enabled
+# as soon as practicable when eCos starts up.  One would choose
+# to disable this if the data cache cannot safely be turned on,
+# such as a case where the cache(s) require additional platform
+# specific setup.
+#
+cdl_component CYGSEM_HAL_ENABLE_DCACHE_ON_STARTUP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# DATA cache mode on startup
+# This option controls the mode the cache will be set to
+# when enabled on startup.
+#
+cdl_option CYGSEM_HAL_DCACHE_STARTUP_MODE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value COPYBACK
+    # value_source default
+    # Default value: COPYBACK
+    # Legal values:  "COPYBACK" "WRITETHRU" 
+};
+
+# <
+# Enable INSTRUCTION cache on startup
+# Enabling this option will cause the instruction cache to be enabled
+# as soon as practicable when eCos starts up.  One would choose
+# to disable this if the instruction cache cannot safely be turned on,
+# such as a case where the cache(s) require additional platform
+# specific setup.
+#
+cdl_option CYGSEM_HAL_ENABLE_ICACHE_ON_STARTUP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Source-level debugging support
+# If the source level debugger gdb is to be used for debugging
+# application code then it may be necessary to configure in support
+# for this in the HAL.
+#
+cdl_component CYGPKG_HAL_DEBUG {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Support for GDB stubs
+# The HAL implements GDB stubs for the target.
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_STUBS {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     ActiveIf: CYGINT_HAL_DEBUG_GDB_STUBS
+    # option CYGBLD_BUILD_REDBOOT_WITH_GDB
+    #     ActiveIf: CYGINT_HAL_DEBUG_GDB_STUBS
+};
+
+# Include GDB stubs in HAL
+# This option causes a set of GDB stubs to be included into the
+# system. On some target systems the GDB support will be
+# provided by other means, for example by a ROM monitor. On
+# other targets, especially when building a ROM-booting system,
+# the necessary support has to go into the target library
+# itself. When GDB stubs are include in a configuration, HAL
+# serial drivers must also be included.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS {
+    # ActiveIf constraint: CYGINT_HAL_DEBUG_GDB_STUBS
+    #     CYGINT_HAL_DEBUG_GDB_STUBS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # The inferred value should not be edited directly.
+    inferred_value 1
+    # value_source inferred
+    # Default value: 0
+    # Requires: ! CYGSEM_HAL_USE_ROM_MONITOR
+    #     CYGSEM_HAL_USE_ROM_MONITOR == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    #     CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    #     CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM == 0
+    #   --> 1
+    # Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_DIAG == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     DefaultValue:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     DefaultValue: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     DefaultValue:  !CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGBLD_BUILD_COMMON_GDB_STUBS
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGPKG_HAL_GDB_FILEIO
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK
+    #     ActiveIf: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    # option CYGBLD_BUILD_REDBOOT_WITH_GDB
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+};
+
+# Support for external break support in GDB stubs
+# The HAL implements external break (or asynchronous interrupt)
+# in the GDB stubs for the target.
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_STUBS_BREAK {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     ActiveIf: CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+};
+
+# Include GDB external break support for stubs
+# This option causes the GDB stub to add a serial interrupt handler
+# which will listen for GDB break packets. This lets you stop the
+# target asynchronously when using GDB, usually by hitting Control+C
+# or pressing the STOP button. This option differs from
+# CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT in that it is used when
+# GDB stubs are present.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT {
+    # ActiveIf constraint: CYGINT_HAL_DEBUG_GDB_STUBS_BREAK
+    #     CYGINT_HAL_DEBUG_GDB_STUBS_BREAK == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     Requires: !CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    # option CYGBLD_BUILD_REDBOOT_WITH_GDB
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+};
+
+# Platform does not support CTRLC
+#
+cdl_interface CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0 
+};
+
+# Include GDB external break support when no stubs
+# This option adds an interrupt handler for the GDB serial line
+# which will listen for GDB break packets. This lets you stop the
+# target asynchronously when using GDB, usually by hitting Control+C
+# or pressing the STOP button. This option differs from
+# CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT in that it is used when the GDB
+# stubs are NOT present.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT {
+    # ActiveIf constraint:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGSEM_HAL_USE_ROM_MONITOR == 0
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+    # ActiveIf constraint:  CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0 
+    #     CYGINT_HAL_DEBUG_GDB_CTRLC_UNSUPPORTED == 0
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  !CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 0
+    # Requires: !CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT == 1
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+};
+
+# Include GDB multi-threading debug support
+# This option enables some extra HAL code which is needed
+# to support multi-threaded source level debugging.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT {
+    # ActiveIf constraint:  CYGSEM_HAL_ROM_MONITOR || CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT 
+    #     CYGSEM_HAL_ROM_MONITOR == 1
+    #     CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT (unknown) == 0
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: ! CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    # option CYGBLD_BUILD_REDBOOT_WITH_THREADS
+    #     Requires: CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+};
+
+# Number of times to retry sending a $O packet
+# This option controls the number of attempts that eCos programs
+# will make to send a $O packet to a host GDB process.  If it is
+# set non-zero, then the target process will attempt to resend the
+# $O packet data up to this number of retries.  Caution: use of
+# this option is not recommended as it can thoroughly confuse the
+# host GDB process.
+#
+cdl_option CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Timeout period for GDB packets
+# This option controls the time (in milliseconds) that eCos programs
+# will wait for a response when sending packets to a host GDB process.
+# If this time elapses, then the packet will be resent, up to some
+# maximum number of times (CYGNUM_HAL_DEBUG_GDB_PROTOCOL_RETRIES).
+#
+cdl_option CYGNUM_HAL_DEBUG_GDB_PROTOCOL_TIMEOUT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 500
+    # value_source default
+    # Default value: 500
+};
+
+# Location of CRC32 table
+# The stubs use a 1 kilobyte CRC table that can either be pregenerated
+# and placed in ROM, or generated at runtime in RAM. Depending on
+# your memory constraints, one of these options may be better.
+#
+cdl_option CYGDBG_HAL_CRCTABLE_LOCATION {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value RAM
+    # value_source default
+    # Default value: RAM
+    # Legal values: "ROM" "RAM"
+};
+
+# Enable initial breakpoint
+# This option causes an application that has GDB stubs built in
+# to take a breakpoint immediately before calling cyg_start().
+# This gives the developer a chance to set any breakpoints or
+# inspect the system state before it proceeds.
+#
+cdl_option CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK {
+    # ActiveIf constraint: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  !CYGPKG_REDBOOT 
+    #     CYGPKG_REDBOOT == current
+    #   --> 0
+};
+
+# <
+# ROM monitor support
+# Support for ROM monitors can be built in to your application. 
+# It may also be relevant to build your application as a ROM monitor
+# itself. Such options are contained here if relevant for your chosen
+# platform. The options and ROM monitors available to choose are
+# platform-dependent.
+#
+cdl_component CYGPKG_HAL_ROM_MONITOR {
+    # There is no associated value.
+
+    # The following properties are affected by this value
+};
+
+# >
+# Target has virtual vector support
+#
+cdl_interface CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT {
+    # Implemented by CYGPKG_HAL_I386_PC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # component CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+    #     ActiveIf: CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+};
+
+# Target supports baud rate control via vectors
+# Whether this target supports the __COMMCTL_GETBAUD
+# and __COMMCTL_SETBAUD virtual vector comm control operations.
+#
+cdl_interface CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_REDBOOT_VARIABLE_BAUD_RATE
+    #     ActiveIf: CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+};
+
+# Enable use of virtual vector calling interface
+# Virtual vector support allows the HAL to let the ROM
+# monitor handle certain operations. The virtual vector table
+# defines a calling interface between applications running in
+# RAM and the ROM monitor.
+#
+cdl_component CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT {
+    # ActiveIf constraint: CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT
+    #     CYGINT_HAL_VIRTUAL_VECTOR_SUPPORT == 1
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+
+    # The following properties are affected by this value
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+};
+
+# >
+# Inherit console settings from ROM monitor
+# When this option is set, the application will inherit
+# the console as set up by the ROM monitor. This means
+# that the application will use whatever channel and
+# mangling style was used by the ROM monitor when
+# the application was launched.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE {
+    # This option is not active
+    # ActiveIf constraint: CYGSEM_HAL_USE_ROM_MONITOR
+    #     CYGSEM_HAL_USE_ROM_MONITOR == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  !CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 1
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     ActiveIf: !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE
+    #     Calculated:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+};
+
+# Debug channel is configurable
+# This option is a configuration hint - it is enabled
+# when the HAL initialization code will make use
+# of the debug channel configuration option.
+#
+cdl_option CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE {
+    # Calculated value:  CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Console channel is configurable
+# This option is a configuration hint - it is enabled
+# when the HAL initialization code will make use
+# of the console channel configuration option.
+#
+cdl_option CYGPRI_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_CONFIGURABLE {
+    # Calculated value:  !CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE  && !CYGDBG_HAL_DIAG_TO_DEBUG_CHAN 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE == 0
+    #     CYGDBG_HAL_DIAG_TO_DEBUG_CHAN == 1
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Initialize whole of virtual vector table
+# This option will cause the whole of the virtual
+# vector table to be initialized with dummy values on
+# startup. When this option is enabled, all the
+# options below must also be enabled - or the
+# table would be empty when the application
+# launches.
+# On targets where older ROM monitors without
+# virtual vector support may still be in use, it is
+# necessary for RAM applictions to initialize the
+# table (since all HAL diagnostics and debug IO
+# happens via the table).
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYGSEM_HAL_USE_ROM_MONITOR == 0
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA == 1
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT
+    #     ActiveIf: !CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_VERSION
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+};
+
+# Claim virtual vector table entries by default
+# By default most virtual vectors will be claimed by
+# RAM startup configurations, meaning that the RAM
+# application will provide the services. The
+# exception is COMMS support (HAL
+# diagnostics/debugging IO) which is left in the
+# control of the ROM monitor.
+# The reasoning behind this is to get as much of the
+# code exercised during regular development so it
+# is known to be working the few times a new ROM
+# monitor or a ROM production configuration is used
+# - COMMS are excluded only by necessity in order to
+# avoid breaking an existing debugger connections
+# (there may be ways around this).
+# For production RAM configurations this option can
+# be switched off, causing the appliction to rely on
+# the ROM monitor for these services, thus
+# saving some space.
+# Individual vectors may also be left unclaimed,
+# controlled by the below options (meaning that the
+# associated service provided by the ROM monitor
+# will be used).
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT {
+    # This option is not active
+    # ActiveIf constraint: !CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+    #     DefaultValue:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+};
+
+# Claim reset virtual vectors
+# This option will cause the reset and kill_by_reset
+# virtual vectors to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_RESET
+};
+
+# Claim version virtual vectors
+# This option will cause the version
+# virtual vectors to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_VERSION {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #   --> 1
+};
+
+# Claim delay_us virtual vector
+# This option will cause the delay_us
+# virtual vector to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DELAY_US
+};
+
+# Claim cache virtual vectors
+# This option will cause the cache virtual vectors
+# to be claimed.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_CACHE
+};
+
+# Claim data virtual vectors
+# This option will cause the data virtual vectors
+# to be claimed. At present there is only one, used
+# by the RedBoot ethernet driver to share diag output.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DEFAULT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_DATA
+};
+
+# Claim comms virtual vectors
+# This option will cause the communication tables
+# that are part of the virtual vectors mechanism to
+# be claimed. Note that doing this may cause an
+# existing ROM monitor communication connection to
+# be closed. For this reason, the option is disabled
+# per default for normal application
+# configurations.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value:  CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE  || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE == 1
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     DefaultValue:  !CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGPRI_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_CONFIGURABLE
+    #     Calculated:  CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     Requires: CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS
+};
+
+# Do diagnostic IO via virtual vector table
+# All HAL IO happens via the virtual vector table / comm
+# tables when those tables are supported by the HAL.
+# If so desired, the low-level IO functions can
+# still be provided by the RAM application by
+# enabling the CLAIM_COMMS option.
+#
+cdl_option CYGSEM_HAL_VIRTUAL_VECTOR_DIAG {
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+
+    # The following properties are affected by this value
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     ActiveIf:  CYGPKG_HAL_ARM || CYGPKG_HAL_POWERPC_MPC8xx  || CYGPKG_HAL_V85X_V850 || CYGSEM_HAL_VIRTUAL_VECTOR_DIAG 
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires:  !CYGSEM_HAL_VIRTUAL_VECTOR_DIAG  || CYGSEM_HAL_VIRTUAL_VECTOR_CLAIM_COMMS 
+};
+
+# <
+# Behave as a ROM monitor
+# Enable this option if this program is to be used as a ROM monitor,
+# i.e. applications will be loaded into RAM on the board, and this
+# ROM monitor may process exceptions or interrupts generated from the
+# application. This enables features such as utilizing a separate
+# interrupt stack when exceptions are generated.
+#
+cdl_option CYGSEM_HAL_ROM_MONITOR {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 1
+    # Requires:  !CYGHWR_HAL_I386_FPU_SWITCH_LAZY 
+    #     CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires: CYGSEM_HAL_ROM_MONITOR
+    # option CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_ROM_MONITOR || CYGDBG_KERNEL_DEBUG_GDB_THREAD_SUPPORT 
+    # option CYGPRI_REDBOOT_ROM_MONITOR
+    #     Requires: CYGSEM_HAL_ROM_MONITOR
+};
+
+# Work with a ROM monitor
+# Support can be enabled for different varieties of ROM monitor.
+# This support changes various eCos semantics such as the encoding
+# of diagnostic output, or the overriding of hardware interrupt
+# vectors.
+# Firstly there is "Generic" support which prevents the HAL
+# from overriding the hardware vectors that it does not use, to
+# instead allow an installed ROM monitor to handle them. This is
+# the most basic support which is likely to be common to most
+# implementations of ROM monitor.
+# "GDB_stubs" provides support when GDB stubs are included in
+# the ROM monitor or boot ROM.
+#
+cdl_option CYGSEM_HAL_USE_ROM_MONITOR {
+    # Flavor: booldata
+    user_value 0 0
+    # value_source user
+    # Default value:  CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0 0
+    # Legal values:  "Generic" "GDB_stubs" 
+    # Requires:  CYG_HAL_STARTUP == "RAM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     Requires: ! CYGSEM_HAL_USE_ROM_MONITOR
+    # option CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     ActiveIf:  CYGSEM_HAL_USE_ROM_MONITOR || CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS 
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INHERIT_CONSOLE
+    #     ActiveIf: CYGSEM_HAL_USE_ROM_MONITOR
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+};
+
+# <
+# Platform defined I/O channels.
+# Platforms which provide additional I/O channels can implement
+# this interface, indicating that the function plf_if_init()
+# needs to be called.
+#
+cdl_interface CYGINT_HAL_PLF_IF_INIT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+};
+
+# Platform IDE I/O support.
+# Platforms which provide IDE controllers can implement
+# this interface, indicating that IDE I/O macros are
+# available.
+#
+cdl_interface CYGINT_HAL_PLF_IF_IDE {
+    # Implemented by CYGPKG_HAL_I386_PCMB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # component CYGSEM_REDBOOT_DISK_IDE
+    #     ActiveIf:  CYGINT_HAL_PLF_IF_IDE != 0 
+};
+
+# File I/O operations via GDB
+# This option enables support for various file I/O
+# operations using the GDB remote protocol to communicate
+# with GDB. The operations are then performed on the
+# debugging host by proxy. These operations are only
+# currently available by using a system call interface
+# to RedBoot. This may change in the future.
+#
+cdl_option CYGPKG_HAL_GDB_FILEIO {
+    # ActiveIf constraint: CYGSEM_REDBOOT_BSP_SYSCALLS
+    #     CYGSEM_REDBOOT_BSP_SYSCALLS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+};
+
+# Build Compiler sanity checking tests
+# Enabling this option causes compiler tests to be built.
+#
+cdl_option CYGPKG_HAL_BUILD_COMPILER_TESTS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_TESTS
+    #     Calculated:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+};
+
+# Common HAL tests
+# This option specifies the set of tests for the common HAL.
+#
+cdl_component CYGPKG_HAL_TESTS {
+    # Calculated value:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+    #     CYGINT_HAL_TESTS_NO_CACHES == 0
+    #     CYGPKG_HAL_BUILD_COMPILER_TESTS == 0
+    #     CYGVAR_KERNEL_COUNTERS_CLOCK (unknown) == 0
+    # Flavor: data
+    # Current_value: tests/context tests/basic tests/cache tests/intr
+};
+
+# >
+# Interface for cache presence
+# Some architectures and/or platforms do not have caches. By
+# implementing this interface, these can disable the various
+# cache-related tests.
+#
+cdl_interface CYGINT_HAL_TESTS_NO_CACHES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_TESTS
+    #     Calculated:   "tests/context tests/basic"
+    #                           . ((!CYGINT_HAL_TESTS_NO_CACHES) ? " tests/cache" : "")
+    #                           . ((CYGPKG_HAL_BUILD_COMPILER_TESTS) ? " tests/cpp1 tests/vaargs" : "")
+    #                           . ((!CYGVAR_KERNEL_COUNTERS_CLOCK) ?   " tests/intr" : "") 
+};
+
+# <
+# i386 architecture
+# The i386 architecture HAL package provides generic
+# support for this processor architecture. It is also
+# necessary to select a specific target platform HAL
+# package.
+#
+cdl_package CYGPKG_HAL_I386 {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+};
+
+# >
+# SMP support
+#
+cdl_component CYGPKG_HAL_SMP_SUPPORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0 
+    #     CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT
+    #     ActiveIf:  CYGPKG_HAL_SMP_SUPPORT 
+    # component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT
+    #     Calculated:  CYGPKG_HAL_SMP_SUPPORT 
+};
+
+# >
+# Max number of CPUs supported
+#
+cdl_option CYGPKG_HAL_SMP_CPU_MAX {
+    # This option is not active
+    # The parent CYGPKG_HAL_SMP_SUPPORT is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 2
+    # value_source default
+    # Default value: 2
+};
+
+# <
+# Enable I386 FPU support
+# This component enables support for the
+# I386 floating point unit.
+#
+cdl_component CYGHWR_HAL_I386_FPU {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Use lazy FPU state switching
+# This option enables lazy FPU state switching.
+# The default behaviour for eCos is to save and
+# restore FPU state on every thread switch, interrupt
+# and exception. While simple and deterministic, this
+# approach can be expensive if the FPU is not used by
+# all threads. The alternative, enabled by this option,
+# is to use hardware features that allow the FPU state
+# of a thread to be left in the FPU after it has been
+# descheduled, and to allow the state to be switched to
+# a new thread only if it actually uses the FPU. Where
+# only one or two threads use the FPU this can avoid a
+# lot of unnecessary state switching.
+#
+cdl_option CYGHWR_HAL_I386_FPU_SWITCH_LAZY {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_HAL_SMP_SUPPORT
+    #     Requires:  CYGHWR_HAL_I386_FPU_SWITCH_LAZY == 0 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  !CYGHWR_HAL_I386_FPU_SWITCH_LAZY 
+};
+
+# <
+# Enable Pentium class CPU features
+# This component enables support for various
+# features of Pentium class CPUs.
+#
+cdl_component CYGHWR_HAL_I386_PENTIUM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Save/Restore SSE registers on context switch
+# This option enables SSE state switching. The default
+# behaviour for eCos is to ignore the SSE registers.
+# Enabling this option adds SSE state information to
+# every thread context.
+#
+cdl_option CYGHWR_HAL_I386_PENTIUM_SSE {
+    # This option is not active
+    # The parent CYGHWR_HAL_I386_PENTIUM is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Support extra Pentium registers in GDB stub
+# This option enables support for extra Pentium registers
+# in the GDB stub. These are registers such as CR0-CR4, and
+# all MSRs. Not all GDBs support these registers, so the
+# default behaviour for eCos is to not include them in the
+# GDB stub support code.
+#
+cdl_option CYGHWR_HAL_I386_PENTIUM_GDB_REGS {
+    # This option is not active
+    # The parent CYGHWR_HAL_I386_PENTIUM is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Linker script
+#
+cdl_option CYGBLD_LINKER_SCRIPT {
+    # Calculated value:  "src/i386.ld" 
+    # Flavor: data
+    # Current_value: src/i386.ld
+};
+
+# Implementations of hal_i386_mem_real_region_top()
+#
+cdl_interface CYGINT_HAL_I386_MEM_REAL_REGION_TOP {
+    # Implemented by CYGPKG_HAL_I386_PCMB, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+};
+
+# i386 generic target
+# This package provides support for generic IA32 CPU variants.
+# Any CPU from an 80386 to the latest Pentium/Athlon should work
+# with this variant HAL. Essentially this variant is empty, it
+# just avoids providing any configuration to the generic architecture
+# support in the architecture HAL.
+#
+cdl_package CYGPKG_HAL_I386_GENERIC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+};
+
+# i386 PC Target
+# The i386 PC Target HAL package provides the 
+# support needed to run eCos binaries on an i386 PC.
+#
+cdl_package CYGPKG_HAL_I386_PC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_DEVS_ETH_I386_PC_RLTK8139
+    #     ActiveIf: CYGPKG_HAL_I386_PC
+    # package CYGPKG_DEVICES_WALLCLOCK_I386_PC
+    #     ActiveIf: CYGPKG_HAL_I386_PC
+};
+
+# >
+# Startup type
+# It is possible to configure eCos for the PC target to build for:
+# RAM startup (generally when being run under an existing
+# Monitor program like RedBoot); FLOPPY startup (for writing
+# to a floppy disk, which can then be used for booting
+# on PCs with a standard BIOS), GRUB startup (for being booted
+# by the GRUB bootloader) ROM startup (for writing
+# straight to a boot ROM/Flash). ROM startup is experimental
+# at this time.
+#
+cdl_component CYG_HAL_STARTUP {
+    # Flavor: data
+    user_value GRUB
+    # value_source user
+    # Default value: RAM
+    # Legal values: "RAM" "FLOPPY" "ROM" "GRUB"
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_I386_ROMBOOT
+    #     Calculated:  CYG_HAL_STARTUP == "ROM" 
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGBLD_BUILD_GDB_STUBS
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGHWR_HAL_I386_PC_LOAD_HIGH
+    #     Requires:  CYG_HAL_STARTUP == "RAM" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ? "i386_pc_grub" :  "i386_pc_floppy" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ? "i386_pc_grub" :  "i386_pc_floppy" 
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ? "i386_pc_grub" :  "i386_pc_floppy" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.ldi>" :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.ldi>" :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.ldi>" :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.h>" :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.h>" :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.h>" :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "FLOPPY" || CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "GRUB" 
+    # option CYGSEM_HAL_USE_ROM_MONITOR
+    #     DefaultValue:  CYG_HAL_STARTUP == "RAM" ? "GDB_stubs" : 0 
+    # option CYGSEM_HAL_USE_ROM_MONITOR
+    #     Requires:  CYG_HAL_STARTUP == "RAM" 
+    # option CYGBLD_BUILD_REDBOOT_BIN_FLOPPY
+    #     ActiveIf:  CYG_HAL_STARTUP == "FLOPPY" 
+    # option CYGBLD_BUILD_REDBOOT_BIN_ROM
+    #     ActiveIf:  CYG_HAL_STARTUP == "ROM" 
+    # option CYGSEM_HAL_INSTALL_MMU_TABLES
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" 
+    # component CYGDBG_HAL_DIAG_TO_DEBUG_CHAN
+    #     DefaultValue:  (CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS  || CYG_HAL_STARTUP == "RAM") ? 1 : 0
+    # option CYGSEM_HAL_VIRTUAL_VECTOR_INIT_WHOLE_TABLE
+    #     DefaultValue:  CYG_HAL_STARTUP != "RAM" || !CYGSEM_HAL_USE_ROM_MONITOR 
+    # option CYGBLD_BUILD_REDBOOT_WITH_THREADS
+    #     ActiveIf:  CYG_HAL_STARTUP != "RAM" 
+    # option CYGPRI_REDBOOT_ROM_MONITOR
+    #     ActiveIf:  CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" 
+    # option CYGPRI_REDBOOT_ROM_MONITOR
+    #     ActiveIf:  CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" 
+};
+
+# Build ROM bootstrap code
+#
+cdl_option CYGBLD_BUILD_I386_ROMBOOT {
+    # Calculated value:  CYG_HAL_STARTUP == "ROM" 
+    #     CYG_HAL_STARTUP == GRUB
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Diagnostic serial port baud rate
+# This option selects the baud rate used for the diagnostic port.
+# Note: this should match the value chosen for the GDB port if the
+# diagnostic and GDB port are the same.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values: 9600 19200 38400 57600 115200
+};
+
+# GDB serial port baud rate
+# This option controls the baud rate used for the GDB connection.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL_BAUD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 38400
+    # value_source default
+    # Default value: 38400
+    # Legal values: 9600 19200 38400 57600 115200
+};
+
+# Number of communication channels on the board
+# This define the number of serial ports that will be used by the HAL.
+# Ports 0 and 1 equate to COM1 and COM2 and port 2 is the PC screen and
+# keyboard.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value:  CYGSEM_HAL_I386_PC_DIAG_SCREEN ? 3 : 2 
+    #     CYGSEM_HAL_I386_PC_DIAG_SCREEN == 1
+    #   --> 3
+    # Legal values: 1 to 3
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL
+    #     LegalValues: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+};
+
+# Debug serial port
+# On PCs with two serial ports, this option
+# chooses which port will be used to connect to a host
+# running GDB.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_DEBUG_CHANNEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+};
+
+# Default console channel.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL
+    #     DefaultValue: CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+};
+
+# Diagnostic serial port
+# On PCs with two serial ports, this option
+# chooses which port will be used for diagnostic output.
+# Selecting port 2 will cause the PC screen to be used.
+#
+cdl_option CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_CONSOLE_CHANNEL_DEFAULT == 0
+    #   --> 0
+    # Legal values: 0 to CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS-1
+    #     CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS == 3
+};
+
+# Output to PC screen
+# This option enables use of the PC screen and keyboard as a
+# third virtual serial device.
+#
+cdl_option CYGSEM_HAL_I386_PC_DIAG_SCREEN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_VIRTUAL_VECTOR_COMM_CHANNELS
+    #     DefaultValue:  CYGSEM_HAL_I386_PC_DIAG_SCREEN ? 3 : 2 
+    # option CYGNUM_HAL_I386_PC_STARTUP_VIDEO_MODE
+    #     Requires:  !CYGSEM_HAL_I386_PC_DIAG_SCREEN 
+};
+
+# Load into higher memory (2MB)
+# This option enables building RAM applications
+# which have a start address outside of the area
+# used by redboot_GRUB.
+#
+cdl_option CYGHWR_HAL_I386_PC_LOAD_HIGH {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYG_HAL_STARTUP == "RAM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGHWR_MEMORY_LAYOUT
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ? "i386_pc_grub" :  "i386_pc_floppy" 
+    # option CYGHWR_MEMORY_LAYOUT_LDI
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.ldi>" :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    # option CYGHWR_MEMORY_LAYOUT_H
+    #     Calculated:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.h>" :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+};
+
+# Memory layout
+#
+cdl_component CYGHWR_MEMORY_LAYOUT {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?   (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "i386_pc_ram_hi" :  "i386_pc_ram") :  CYG_HAL_STARTUP == "ROM"  ? "i386_pc_rom" :  CYG_HAL_STARTUP == "GRUB" ? "i386_pc_grub" :  "i386_pc_floppy" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 0
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    # Flavor: data
+    # Current_value: i386_pc_grub
+};
+
+# >
+# Memory layout linker script fragment
+#
+cdl_option CYGHWR_MEMORY_LAYOUT_LDI {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.ldi>" :  "<pkgconf/mlt_i386_pc_ram.ldi>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.ldi>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.ldi>" :  "<pkgconf/mlt_i386_pc_floppy.ldi>" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 0
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    # Flavor: data
+    # Current_value: <pkgconf/mlt_i386_pc_grub.ldi>
+};
+
+# Memory layout header file
+#
+cdl_option CYGHWR_MEMORY_LAYOUT_H {
+    # Calculated value:  CYG_HAL_STARTUP == "RAM"  ?  (CYGHWR_HAL_I386_PC_LOAD_HIGH ?  "<pkgconf/mlt_i386_pc_ram_hi.h>" :  "<pkgconf/mlt_i386_pc_ram.h>") :  CYG_HAL_STARTUP == "ROM"  ? "<pkgconf/mlt_i386_pc_rom.h>" :  CYG_HAL_STARTUP == "GRUB" ? "<pkgconf/mlt_i386_pc_grub.h>" :  "<pkgconf/mlt_i386_pc_floppy.h>" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYGHWR_HAL_I386_PC_LOAD_HIGH == 0
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    # Flavor: data
+    # Current_value: <pkgconf/mlt_i386_pc_grub.h>
+};
+
+# <
+# <
+# i386 PC Motherboard Support
+# The i386 PC Motherboard HAL package provides the
+# support needed to run eCos binaries on an i386 PC
+# using a standard motherboard. This package provides
+# support for the standard PC devices: timers, interrupt
+# controller, serial ports, ASCII display, keyboard, PCI
+# bus etc. that are found on all PC compatible platforms.
+# It does not provide support for devices that may also be
+# found on modern motherboards, such as ethernet, sound and
+# video devices. These are supported by drivers elsewhere.
+#
+cdl_package CYGPKG_HAL_I386_PCMB {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_IO_SERIAL_I386_PC
+    #     ActiveIf: CYGPKG_HAL_I386_PCMB
+};
+
+# >
+# Real-time clock constants.
+# The RTC period is based on the clock input
+# to the 8254, which is 1193180 Hz.
+# CYGNUM_HAL_RTC_PERIOD is set for 100 ticks
+# per second.
+#
+cdl_component CYGNUM_HAL_RTC_CONSTANTS {
+    # There is no associated value.
+};
+
+# >
+# Real-time clock numerator
+#
+cdl_option CYGNUM_HAL_RTC_NUMERATOR {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1000000000
+    # value_source default
+    # Default value: 1000000000
+};
+
+# Real-time clock denominator
+#
+cdl_option CYGNUM_HAL_RTC_DENOMINATOR {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 100
+    # value_source default
+    # Default value: 100
+};
+
+# Real-time clock period
+#
+cdl_option CYGNUM_HAL_RTC_PERIOD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 11932
+    # value_source default
+    # Default value: 11932
+};
+
+# <
+# How to discover the size of available RAM.
+# It is possible for the HAL to discover the 
+# size of RAM In several ways. Currently this
+# can be done by querying the BIOS or by 
+# hardcoding the values into the executable.
+#
+cdl_component CYGPKG_HAL_I386_PCMB_MEMSIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value BIOS
+    # value_source default
+    # Default value: BIOS
+    # Legal values: "BIOS" "HARDCODE"
+
+    # The following properties are affected by this value
+    # option CYGNUM_HAL_I386_PCMB_MEMSIZE_BASE
+    #     ActiveIf:  CYGPKG_HAL_I386_PCMB_MEMSIZE == "HARDCODE" 
+    # option CYGNUM_HAL_I386_PCMB_MEMSIZE_EXTENDED
+    #     ActiveIf:  CYGPKG_HAL_I386_PCMB_MEMSIZE == "HARDCODE" 
+};
+
+# >
+# Amount of Base RAM available.
+#
+cdl_option CYGNUM_HAL_I386_PCMB_MEMSIZE_BASE {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_I386_PCMB_MEMSIZE == "HARDCODE" 
+    #     CYGPKG_HAL_I386_PCMB_MEMSIZE == BIOS
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x000F0000
+    # value_source default
+    # Default value: 0x000F0000
+};
+
+# Amount of Extended RAM available.
+#
+cdl_option CYGNUM_HAL_I386_PCMB_MEMSIZE_EXTENDED {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_I386_PCMB_MEMSIZE == "HARDCODE" 
+    #     CYGPKG_HAL_I386_PCMB_MEMSIZE == BIOS
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x00100000
+    # value_source default
+    # Default value: 0x00100000
+};
+
+# <
+# Search entire PCI space
+# This option enables searching the entire PCI address space, including
+# up to 256 busses, etc.  Probably only useful when there are bridges or
+# other PCI expanding devices (such as a board with it's own PCI bus)
+# in the system.  If disabled, the system will revert to the default
+# PCI space size (typically 8 busses).
+#
+cdl_option CYGSEM_HAL_I386_PC_LARGE_PCI_SPACE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Switch the display to an alternative video mode
+# This option can be used when building RedBoot to switch
+# the display to a suitable mode, typically before running
+# an eCos graphical application. The mode switch involves
+# calling the PC Video BIOS, so needs to happen while the
+# processor is still running in real mode. Some information
+# about the video BIOS, the current mode, and the available
+# modes will be written to video memory so that the eCos
+# application knows what happened.
+# Different graphics cards use different numbers for the
+# various modes, so there is no simple way of knowing which
+# mode should be specified to achieve the desired resolution.
+# Instead RedBoot can be built with a suitable default, for
+# example 0x0100, and then a simple eCos application can be
+# built using an appropriate eCos configuration and
+# run to find out about all the available mode. RedBoot can
+# then be reconfigured and rebuilt to use a suitable mode.
+# The PC motherboard support package comes with a simple
+# eCos program gfxmode.c which can be used for this.
+#
+cdl_option CYGNUM_HAL_I386_PC_STARTUP_VIDEO_MODE {
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT == current
+    #   --> 1
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+    # Requires:  !CYGSEM_HAL_I386_PC_DIAG_SCREEN 
+    #     CYGSEM_HAL_I386_PC_DIAG_SCREEN == 1
+    #   --> 0
+};
+
+#
+cdl_component CYGPKG_HAL_I386_PCMB_SMP_SUPPORT {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_HAL_SMP_SUPPORT 
+    #     CYGPKG_HAL_SMP_SUPPORT == 0
+    #   --> 0
+
+    # Calculated value:  CYGPKG_HAL_SMP_SUPPORT 
+    #     CYGPKG_HAL_SMP_SUPPORT == 0
+    # Flavor: bool
+    # Current value: 0
+};
+
+# Enable PC screen support
+# This option enables support for the PC screen and
+# keyboard. These are combined into a virtual serial
+# device that may be used for diagnostic output.
+# Note that there is little point in trying to use it
+# as a debug channel.
+#
+cdl_interface CYGINT_HAL_I386_PCMB_SCREEN_SUPPORT {
+    # Implemented by CYGSEM_HAL_I386_PC_DIAG_SCREEN, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGHWR_REDBOOT_I386_TRAMPOLINE_ADDRESS
+    #     Requires: CYGINT_HAL_I386_PCMB_SCREEN_SUPPORT
+};
+
+# <
+# <
+# <
+# Infrastructure
+# Common types and useful macros.
+# Tracing and assertion facilities.
+# Package startup options.
+#
+cdl_package CYGPKG_INFRA {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_HAL
+    #     Requires: CYGPKG_INFRA
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGPKG_INFRA
+};
+
+# >
+# Asserts & Tracing
+# The eCos source code contains a significant amount of
+# internal debugging support, in the form of assertions and
+# tracing.
+# Assertions check at runtime that various conditions are as
+# expected; if not, execution is halted.
+# Tracing takes the form of text messages that are output
+# whenever certain events occur, or whenever functions are
+# called or return.
+# The most important property of these checks and messages is
+# that they are not required for the program to run.
+# It is prudent to develop software with assertions enabled,
+# but disable them when making a product release, thus
+# removing the overhead of that checking.
+# It is possible to enable assertions and tracing
+# independently.
+# There are also options controlling the exact behaviour of
+# the assertion and tracing facilities, thus giving users
+# finer control over the code and data size requirements.
+#
+cdl_component CYGPKG_INFRA_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Use asserts
+# If this option is defined, asserts in the code are tested.
+# Assert functions (CYG_ASSERT()) are defined in
+# 'include/cyg/infra/cyg_ass.h' within the 'install' tree.
+# If it is not defined, these result in no additional
+# object code and no checking of the asserted conditions.
+#
+cdl_component CYGDBG_USE_ASSERTS {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    #     CYGINT_INFRA_DEBUG_TRACE_IMPL == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG
+    #     Requires: CYGDBG_USE_ASSERTS
+    # option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG
+    #     DefaultValue:  0 != CYGDBG_USE_ASSERTS 
+};
+
+# >
+# Preconditions
+# This option allows individual control of preconditions.
+# A precondition is one type of assert, which it is
+# useful to control separately from more general asserts.
+# The function is CYG_PRECONDITION(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_PRECONDITIONS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Postconditions
+# This option allows individual control of postconditions.
+# A postcondition is one type of assert, which it is
+# useful to control separately from more general asserts.
+# The function is CYG_POSTCONDITION(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_POSTCONDITIONS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Loop invariants
+# This option allows individual control of loop invariants.
+# A loop invariant is one type of assert, which it is
+# useful to control separately from more general asserts,
+# particularly since a loop invariant is typically evaluated
+# a great many times when used correctly.
+# The function is CYG_LOOP_INVARIANT(condition,msg).
+#
+cdl_option CYGDBG_INFRA_DEBUG_LOOP_INVARIANTS {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use assert text
+# All assertions within eCos contain a text message
+# which should give some information about the condition
+# being tested.
+# These text messages will end up being embedded in the
+# application image and hence there is a significant penalty
+# in terms of image size.
+# It is possible to suppress the use of these messages by
+# disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information if an assertion actually gets
+# triggered.
+#
+cdl_option CYGDBG_INFRA_DEBUG_ASSERT_MESSAGE {
+    # This option is not active
+    # The parent CYGDBG_USE_ASSERTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Use tracing
+# If this option is defined, tracing operations
+# result in output or logging, depending on other options.
+# This may have adverse effects on performance, if the time
+# taken to output message overwhelms the available CPU
+# power or output bandwidth.
+# Trace functions (CYG_TRACE()) are defined in
+# 'include/cyg/infra/cyg_trac.h' within the 'install' tree.
+# If it is not defined, these result in no additional
+# object code and no trace information.
+#
+cdl_component CYGDBG_USE_TRACING {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    #     CYGINT_INFRA_DEBUG_TRACE_IMPL == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_WRAP
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_HALT
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT
+    #     ActiveIf: CYGDBG_USE_TRACING
+    # option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT_ON_ASSERT
+    #     ActiveIf: CYGDBG_USE_TRACING
+};
+
+# >
+# Trace function reports
+# This option allows individual control of
+# function entry/exit tracing, independent of
+# more general tracing output.
+# This may be useful to remove clutter from a
+# trace log.
+#
+cdl_option CYGDBG_INFRA_DEBUG_FUNCTION_REPORTS {
+    # This option is not active
+    # The parent CYGDBG_USE_TRACING is not active
+    # The parent CYGDBG_USE_TRACING is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use trace text
+# All trace calls within eCos contain a text message
+# which should give some information about the circumstances.
+# These text messages will end up being embedded in the
+# application image and hence there is a significant penalty
+# in terms of image size.
+# It is possible to suppress the use of these messages by
+# disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information available in the trace output,
+# possibly only filenames and line numbers.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_MESSAGE {
+    # This option is not active
+    # The parent CYGDBG_USE_TRACING is not active
+    # The parent CYGDBG_USE_TRACING is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Trace output implementations
+#
+cdl_interface CYGINT_INFRA_DEBUG_TRACE_IMPL {
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_NULL, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY, inactive, disabled
+    # Implemented by CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER, inactive, enabled
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # component CYGDBG_USE_ASSERTS
+    #     Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+    # component CYGDBG_USE_TRACING
+    #     Requires:  1 == CYGINT_INFRA_DEBUG_TRACE_IMPL 
+};
+
+# Null output
+# A null output module which is useful when
+# debugging interactively; the output routines
+# can be breakpointed rather than have them actually
+# 'print' something.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_NULL {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Simple output
+# An output module which produces simple output
+# from tracing and assertion events.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_SIMPLE {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Fancy output
+# An output module which produces fancy output
+# from tracing and assertion events.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_ASSERT_FANCY {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Buffered tracing
+# An output module which buffers output
+# from tracing and assertion events. The stored
+# messages are output when an assert fires, or
+# CYG_TRACE_PRINT() (defined in <cyg/infra/cyg_trac.h>)
+# is called.
+# Of course, there will only be stored messages
+# if tracing per se (CYGDBG_USE_TRACING)
+# is enabled above.
+#
+cdl_component CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Trace buffer size
+# The size of the trace buffer. This counts the number
+# of trace records stored. When the buffer fills it
+# either wraps, stops recording, or generates output.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 32
+    # value_source default
+    # Default value: 32
+    # Legal values: 5 to 65535
+};
+
+# Wrap trace buffer when full
+# When the trace buffer has filled with records it
+# starts again at the beginning. Hence only the last
+# CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE messages will
+# be recorded.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_WRAP {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Halt trace buffer when full
+# When the trace buffer has filled with records it
+# stops recording. Hence only the first
+# CYGDBG_INFRA_DEBUG_TRACE_BUFFER_SIZE messages will
+# be recorded.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_HALT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Print trace buffer when full
+# When the trace buffer has filled with records it
+# prints the contents of the buffer. The buffer is then
+# emptied and the system continues.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Print trace buffer on assert fail
+# When an assertion fails the trace buffer will be 
+# printed to the default diagnostic device.
+#
+cdl_option CYGDBG_INFRA_DEBUG_TRACE_BUFFER_PRINT_ON_ASSERT {
+    # This option is not active
+    # The parent CYGDBG_INFRA_DEBUG_TRACE_ASSERT_BUFFER is not active
+    # ActiveIf constraint: CYGDBG_USE_TRACING
+    #     CYGDBG_USE_TRACING == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Use function names
+# All trace and assert calls within eCos contain a
+# reference to the builtin macro '__PRETTY_FUNCTION__',
+# which evaluates to a string containing
+# the name of the current function.
+# This is useful when reading a trace log.
+# It is possible to suppress the use of the function name
+# by disabling this option.
+# This results in smaller code size, but there is less
+# human-readable information available in the trace output,
+# possibly only filenames and line numbers.
+#
+cdl_option CYGDBG_INFRA_DEBUG_FUNCTION_PSEUDOMACRO {
+    # This option is not active
+    # The parent CYGPKG_INFRA_DEBUG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Startup options
+# Some packages require a startup routine to be called.
+# This can be carried out by application code, by supplying
+# a routine called cyg_package_start() which calls the
+# appropriate package startup routine(s).
+# Alternatively, this routine can be constructed automatically
+# and configured to call the startup routines of your choice.
+#
+cdl_component CYGPKG_INFRA_STARTUP {
+    # There is no associated value.
+};
+
+# >
+# Start uITRON subsystem
+# Generate a call to initialize the
+# uITRON compatibility subsystem
+# within the system version of cyg_package_start().
+# This enables compatibility with uITRON.
+# You must configure uITRON with the correct tasks before
+# starting the uItron subsystem.
+# If this is disabled, and you want to use uITRON,
+# you must call cyg_uitron_start() from your own
+# cyg_package_start() or cyg_userstart().
+#
+cdl_option CYGSEM_START_UITRON_COMPATIBILITY {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_UITRON
+    #     CYGPKG_UITRON (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires: CYGPKG_UITRON
+    #     CYGPKG_UITRON (unknown) == 0
+    #   --> 0
+};
+
+# <
+# Smaller slower memcpy()
+# Enabling this option causes the implementation of
+# the standard memcpy() routine to reduce code
+# size at the expense of execution speed. This
+# option is automatically enabled with the use of
+# the -Os option to the compiler. Also note that
+# the compiler will try to use its own builtin
+# version of memcpy() if possible, ignoring the
+# implementation in this package, unless given
+# the -fno-builtin compiler option.
+#
+cdl_option CYGIMP_INFRA_PREFER_SMALL_TO_FAST_MEMCPY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Smaller slower memset()
+# Enabling this option causes the implementation of
+# the standard memset() routine to reduce code
+# size at the expense of execution speed. This
+# option is automatically enabled with the use of
+# the -Os option to the compiler. Also note that
+# the compiler will try to use its own builtin
+# version of memset() if possible, ignoring the
+# implementation in this package, unless given
+# the -fno-builtin compiler option.
+#
+cdl_option CYGIMP_INFRA_PREFER_SMALL_TO_FAST_MEMSET {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide empty C++ delete functions
+# To deal with virtual destructors, where the correct delete()
+# function must be called for the derived class in question, the
+# underlying delete is called when needed, from destructors.  This
+# is regardless of whether the destructor is called by delete itself.
+# So there is a reference to delete() from all destructors.  The
+# default builtin delete() attempts to call free() if there is
+# one defined.  So, if you have destructors, and you have free(),
+# as in malloc() and free(), any destructor counts as a reference
+# to free().  So the dynamic memory allocation code is linked
+# in regardless of whether it gets explicitly called. This
+# increases code and data size needlessly.
+# To defeat this undesirable behaviour, we define empty versions
+# of delete and delete.  But doing this prevents proper use
+# of dynamic memory in C++ programs via C++'s new and delete
+# operators.
+# Therefore, this option is provided
+# for explicitly disabling the provision of these empty functions,
+# so that new and delete can be used, if that is what is required.
+#
+cdl_option CYGFUN_INFRA_EMPTY_DELETE_FUNCTIONS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Provide dummy abort() function
+# This option controls the inclusion of a dummy abort() function.
+# Parts of the C and C++ compiler runtime systems contain references
+# to abort(), particulary in the C++ exception handling code. It is
+# not possible to eliminate these references, so this dummy function
+# in included to satisfy them. It is not expected that this function
+# will ever be called, so its current behaviour is to simply loop.
+#
+cdl_option CYGFUN_INFRA_DUMMY_ABORT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGINT_ISO_EXIT == 0 
+    #     CYGINT_ISO_EXIT == 0
+    #   --> 1
+    # Requires: !CYGINT_ISO_EXIT
+    #     CYGINT_ISO_EXIT == 0
+    #   --> 1
+};
+
+# Reset platform at end of test case execution
+# If this option is set then test case programs will reset the platform
+# when they terminate, as opposed to the default which is to just hang
+# in a loop.
+#
+cdl_option CYGSEM_INFRA_RESET_ON_TEST_EXIT {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Provide dummy strlen() function
+# This option controls the inclusion of a dummy strlen() function.
+# Parts of the C and C++ compiler runtime systems contain references
+# to strlen(), particulary in the C++ exception handling code. It is
+# not possible to eliminate these references, so this dummy function
+# in included to satisfy them. While it is not expected that this function
+# will ever be called, it is functional but uses the simplest, smallest
+# algorithm. There is a faster version of strlen() in the C library.
+#
+cdl_option CYGFUN_INFRA_DUMMY_STRLEN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGINT_ISO_STRING_STRFUNCS == 0 
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 0
+    # Requires: !CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 0
+};
+
+# Make all compiler warnings show as errors
+# Enabling this option will cause all compiler warnings to show
+# as errors and bring the library build to a halt. This is used
+# to ensure that the code base is warning free, and thus ensure
+# that newly introduced warnings stand out and get fixed before
+# they show up as weird run-time behavior.
+#
+cdl_option CYGBLD_INFRA_CFLAGS_WARNINGS_AS_ERRORS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -Werror") 
+    #     CYGBLD_GLOBAL_CFLAGS == "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    #   --> 0
+};
+
+# Make compiler and assembler communicate by pipe
+# Enabling this option will cause the compiler to feed the
+# assembly output the the assembler via a pipe instead of
+# via a temporary file. This normally reduces the build
+# time.
+#
+cdl_option CYGBLD_INFRA_CFLAGS_PIPE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  is_substr(CYGBLD_GLOBAL_CFLAGS, " -pipe") 
+    #     CYGBLD_GLOBAL_CFLAGS == "-Wall -Wpointer-arith -Wstrict-prototypes -Winline -Wundef -Woverloaded-virtual -g -O2 -ffunction-sections -fdata-sections -fno-rtti -fno-exceptions -fvtable-gc -finit-priority"
+    #   --> 0
+};
+
+# Infra build options
+# Package specific build options including control over
+# compiler flags used only in building this package.
+#
+cdl_component CYGPKG_INFRA_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos infra package. These flags are used
+# in addition to the set of global flags.
+#
+cdl_option CYGPKG_INFRA_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the eCos infra package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed linker flags
+# This option modifies the set of linker flags for
+# building the eCos infra package tests. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_LDFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wl,--gc-sections
+    # value_source default
+    # Default value: -Wl,--gc-sections
+};
+
+# Additional linker flags
+# This option modifies the set of linker flags for
+# building the eCos infra package tests. These flags are added to
+# the set of global flags if present.
+#
+cdl_option CYGPKG_INFRA_LDFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wl,--fatal-warnings
+    # value_source default
+    # Default value: -Wl,--fatal-warnings
+};
+
+# Infra package tests
+#
+cdl_component CYGPKG_INFRA_TESTS {
+    # Calculated value:  "tests/cxxsupp tests/diag_sprintf1 tests/diag_sprintf2" 
+    # Flavor: data
+    # Current_value: tests/cxxsupp tests/diag_sprintf1 tests/diag_sprintf2
+};
+
+# >
+# Number of times a test runs
+# This option controls the number of times tests will execute their
+# basic function.  Not all tests will honor this setting, but those
+# that do will execute the test N times before terminating.  A value
+# less than 0 indicates to run forever.
+#
+cdl_option CYGNUM_TESTS_RUN_COUNT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# <
+# <
+# Redboot ROM monitor
+# doc: ref/redboot.html
+# This package supports the Redboot [stand-alone debug monitor]
+# using eCos as the underlying board support mechanism.
+#
+cdl_package CYGPKG_REDBOOT {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires:  CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK == 0 
+    #     CYGIMP_HAL_COMMON_INTERRUPTS_USE_INTERRUPT_STACK == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGDBG_HAL_DEBUG_GDB_INITIAL_BREAK
+    #     DefaultValue:  !CYGPKG_REDBOOT 
+    # component CYGPKG_REDBOOT_HAL_OPTIONS
+    #     ActiveIf: CYGPKG_REDBOOT
+    # option CYGNUM_HAL_I386_PC_STARTUP_VIDEO_MODE
+    #     ActiveIf: CYGPKG_REDBOOT
+    # option CYGNUM_DEVS_ETH_RLTK_8139_RX_BUF_LEN_IDX
+    #     DefaultValue:  CYGPKG_REDBOOT ? 0 : 2 
+    # option CYGSEM_IO_ETH_DRIVERS_WARN
+    #     ActiveIf: CYGPKG_REDBOOT
+};
+
+# >
+# Include support for ELF file format
+#
+cdl_component CYGSEM_REDBOOT_ELF {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Use the virtual address in the ELF headers
+# The ELF headers contain both a virtual and a physical address
+# for where code/data should be loaded. By default the physical
+# address is used but sometimes it is necassary to use the
+# virtual address because of bugy toolchains
+#
+cdl_option CYGOPT_REDBOOT_ELF_VIRTUAL_ADDRESS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Methods of loading images using redboot
+#
+cdl_interface CYGINT_REDBOOT_LOAD_METHOD {
+    # Implemented by CYGBLD_BUILD_REDBOOT_WITH_XYZMODEM, active, enabled
+    # Implemented by CYGPKG_REDBOOT_NETWORKING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 2
+
+    # The following properties are affected by this value
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGINT_REDBOOT_LOAD_METHOD
+};
+
+# Build Redboot ROM ELF image
+# This option enables the building of the Redboot ELF image.
+# The image may require further relocation or symbol
+# stripping before being converted to a binary image.
+# This is handled by a rule in the target CDL.
+#
+cdl_component CYGBLD_BUILD_REDBOOT {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+    # Requires: CYGPKG_INFRA
+    #     CYGPKG_INFRA == current
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_CTRLC_SUPPORT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT
+    #     CYGDBG_HAL_COMMON_INTERRUPTS_SAVE_MINIMUM_CONTEXT == 0
+    #   --> 1
+    # Requires: ! CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM
+    #     CYGDBG_HAL_COMMON_CONTEXT_SAVE_MINIMUM == 0
+    #   --> 1
+    # Requires: CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT
+    #     CYGSEM_HAL_VIRTUAL_VECTOR_SUPPORT == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_MEMFUNCS
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+    # Requires: CYGINT_REDBOOT_LOAD_METHOD
+    #     CYGINT_REDBOOT_LOAD_METHOD == 2
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGBLD_BUILD_REDBOOT_BIN_FLOPPY
+    #     ActiveIf: CYGBLD_BUILD_REDBOOT
+    # option CYGBLD_BUILD_REDBOOT_BIN_ROM
+    #     ActiveIf: CYGBLD_BUILD_REDBOOT
+};
+
+# >
+# Include GDB support in RedBoot
+# RedBoot normally includes support for the GDB debugging protocols.
+# This option allows this to be disabled which may yield a substantial
+# savings in terms of code and memory usage by RedBoot.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_GDB {
+    # ActiveIf constraint: CYGINT_HAL_DEBUG_GDB_STUBS
+    #     CYGINT_HAL_DEBUG_GDB_STUBS == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS
+    #     CYGDBG_HAL_DEBUG_GDB_INCLUDE_STUBS == 1
+    #   --> 1
+    # Requires: CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_BREAK_SUPPORT == 1
+    #   --> 1
+};
+
+# Threads debugging support
+# Enabling this option will include special code in the GDB stubs to
+# support debugging of threaded programs.  In the case of eCos programs,
+# this support allows GDB to have complete access to the eCos threads
+# in the program.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_THREADS {
+    # ActiveIf constraint:  CYG_HAL_STARTUP != "RAM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 1
+
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+    # Requires: CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT
+    #     CYGDBG_HAL_DEBUG_GDB_THREAD_SUPPORT == 1
+    #   --> 1
+};
+
+# Customized version string
+# Use this option to define a customized version "string" for
+# RedBoot.  Note: this value is only cosmetic, displayed by the
+# "version" command, but is useful for providing site specific
+# information about the RedBoot configuration.
+#
+cdl_option CYGDAT_REDBOOT_CUSTOM_VERSION {
+    # Flavor: booldata
+    user_value 1 FMTC
+    # value_source user
+    # Default value: 0 0
+};
+
+# Enable command line editing
+# If this option is non-zero, RedBoot will remember the last N command
+# lines.  These lines may be reused.  Enabling this history will also
+# enable rudimentary editting of the lines themselves.
+#
+cdl_option CYGNUM_REDBOOT_CMD_LINE_EDITING {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16
+    # value_source default
+    # Default value: 16
+
+    # The following properties are affected by this value
+    # option CYGBLD_REDBOOT_CMD_LINE_HISTORY
+    #     Requires:  CYGNUM_REDBOOT_CMD_LINE_EDITING > 0 
+};
+
+# Enable history command and expansion
+# Enabling this option will allow RedBoot to provide a history command
+# to list previous commands. Also enables history expansion via '!'
+# character similar to bash shell.
+#
+cdl_option CYGBLD_REDBOOT_CMD_LINE_HISTORY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGNUM_REDBOOT_CMD_LINE_EDITING > 0 
+    #     CYGNUM_REDBOOT_CMD_LINE_EDITING == 16
+    #   --> 1
+};
+
+# Number of unique RAM segments on platform
+# Change this option to be the number of memory segments which are
+# supported by the platform.  If the value is greater than 1, then
+# a platform specific function must provide information about the
+# additional segments.
+#
+cdl_option CYGBLD_REDBOOT_MAX_MEM_SEGMENTS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include support gzip/zlib decompression
+#
+cdl_component CYGBLD_BUILD_REDBOOT_WITH_ZLIB {
+    # ActiveIf constraint: CYGPKG_COMPRESS_ZLIB
+    #     CYGPKG_COMPRESS_ZLIB == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGOPT_REDBOOT_FIS_ZLIB_COMMON_BUFFER
+    #     ActiveIf:  CYGBLD_BUILD_REDBOOT_WITH_ZLIB &&  CYGOPT_REDBOOT_FIS 
+};
+
+# >
+# Implement a simple memory management system
+# If enabled, this option will tell Redboot to implement a simple memory
+# allocator that allows using zlib without inclusing the Dynamic
+# Memory Allocation Package.
+#
+cdl_option CYGBLD_REDBOOT_ZLIB_LOCAL_ALLOC {
+    # This option is not active
+    # ActiveIf constraint: !CYGPKG_MEMALLOC
+    #     CYGPKG_MEMALLOC == current
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Size of zlib decompression buffer
+# This is the size of the buffer filled with incoming data
+# during load before calls are made to the decompressor
+# function. For ethernet downloads this can be made bigger
+# (at the cost of memory), but for serial downloads on slow
+# processors it may be necessary to reduce the size to
+# avoid serial overruns. zlib appears to bail out if less than
+# five bytes are available initially so this is the minimum.
+#
+cdl_option CYGNUM_REDBOOT_LOAD_ZLIB_BUFFER {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 64
+    # value_source default
+    # Default value: 64
+    # Legal values: 5 to 256
+};
+
+# Support compression of Flash images
+# This CDL indicates whether flash images can
+# be decompressed from gzip/zlib format into RAM.
+#
+cdl_option CYGPRI_REDBOOT_ZLIB_FLASH {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_REDBOOT_FLASH
+    #     CYGPKG_REDBOOT_FLASH == 0
+    #   --> 0
+    # ActiveIf constraint: !CYGSEM_IO_FLASH_READ_INDIRECT
+    #     CYGSEM_IO_FLASH_READ_INDIRECT (unknown) == 0
+    #   --> 1
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# <
+# Include support for xyzModem downloads
+# doc: ref/download-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_XYZMODEM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include POSIX checksum command
+# doc: ref/cksum-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_CKSUM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include memory fill command
+# doc: ref/mfill-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_MFILL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include memory compare command
+# doc: ref/mcmp-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_MCMP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include memory copy command
+# doc: ref/mcopy-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_MCOPY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include memory dump command
+# doc: ref/dump-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_DUMP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include cache command
+# doc: ref/cache-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_CACHES {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Include exec command
+# doc: ref/exec-command.html
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_EXEC {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_REDBOOT_I386_LINUX_EXEC
+    #     ActiveIf: CYGBLD_BUILD_REDBOOT_WITH_EXEC
+};
+
+# Include I/O Memory commands 'iopeek' and 'iopoke'
+#
+cdl_option CYGBLD_BUILD_REDBOOT_WITH_IOMEM {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Granularity of timer/ticks
+# This option controls the granularity of the timers.
+# Faster CPUs can afford higher granularity (lower values)
+# which should give higher network performance since the stack
+# is purely polled.
+#
+cdl_option CYGDBG_REDBOOT_TICK_GRANULARITY {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 250
+    # value_source default
+    # Default value: 250
+    # Legal values:  50 100 250 500 1000 
+};
+
+# Redboot Networking
+# This option includes networking support in RedBoot.
+#
+cdl_component CYGPKG_REDBOOT_NETWORKING {
+    # ActiveIf constraint: CYGPKG_IO_ETH_DRIVERS
+    #     CYGPKG_IO_ETH_DRIVERS == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_IO_ETH_DRIVERS_PASS_PACKETS
+    #     DefaultValue:  0 != CYGPKG_REDBOOT_NETWORKING 
+};
+
+# >
+# Print net debug information
+# This option is overriden by the configuration stored in flash.
+#
+cdl_option CYGDBG_REDBOOT_NET_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Support TFTP for download
+# This option enables the use of the TFTP protocol for download
+#
+cdl_option CYGSEM_REDBOOT_NET_TFTP_DOWNLOAD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Support HTTP for download
+# This option enables the use of the HTTP protocol for download
+#
+cdl_option CYGSEM_REDBOOT_NET_HTTP_DOWNLOAD {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Default IP address
+# This IP address is the default used by RedBoot if a BOOTP/DHCP
+# server does not respond. The numbers should be separated by
+# *commas*, and not dots. If an IP address is configured into
+# the Flash configuration, that will be used in preference.
+#
+cdl_component CYGDAT_REDBOOT_DEFAULT_IP_ADDR {
+    # Flavor: booldata
+    user_value 1 "192, 168, 246, 5"
+    # value_source user
+    # Default value: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 1 "0, 0, 0, 0"
+};
+
+# >
+# Do not try to use BOOTP
+# By default Redboot tries to use BOOTP to get an IP
+# address. If there's no BOOTP server on your network
+# use this option to avoid to wait until the
+# timeout. This option is overriden by the
+# configuration stored in flash.
+#
+cdl_option CYGSEM_REDBOOT_DEFAULT_NO_BOOTP {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+};
+
+# Default bootp server
+# This IP address is the default server
+# address used by RedBoot if a BOOTP/DHCP
+# server does not respond. The numbers should
+# be separated by *commas*, and not dots. If
+# an IP address is configured into the Flash
+# configuration, that will be used in
+# preference.
+#
+cdl_option CYGDAT_REDBOOT_DEFAULT_BOOTP_SERVER_IP_ADDR {
+    # Flavor: booldata
+    user_value 0 "0, 0, 0, 0"
+    # value_source user
+    # Default value: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 1 "0, 0, 0, 0"
+};
+
+# <
+# Use DHCP to get IP information
+# Use DHCP protocol to obtain pertinent IP addresses, such as
+# the client, server, gateway, etc.
+#
+cdl_component CYGSEM_REDBOOT_NETWORKING_DHCP {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGSEM_REDBOOT_NETWORKING_USE_GATEWAY
+    #     Requires: CYGSEM_REDBOOT_NETWORKING_DHCP
+};
+
+# Use a gateway for non-local IP traffic
+# Enabling this option will allow the RedBoot networking
+# stack to use a [single] gateway to reach a non-local
+# IP address.  If disabled, RedBoot will only be able to
+# reach nodes on the same subnet.
+#
+cdl_component CYGSEM_REDBOOT_NETWORKING_USE_GATEWAY {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+    # Requires: CYGSEM_REDBOOT_NETWORKING_DHCP
+    #     CYGSEM_REDBOOT_NETWORKING_DHCP == 0
+    #   --> 0
+};
+
+# >
+# Default gateway IP address
+# This IP address is the default used by RedBoot if a BOOTP/DHCP
+# server does not respond. The numbers should be separated by
+# *commas*, and not dots. If an IP address is configured into
+# the Flash configuration, that will be used in preference.
+#
+cdl_component CYGDAT_REDBOOT_DEFAULT_GATEWAY_IP_ADDR {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_NETWORKING_USE_GATEWAY is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 "0, 0, 0, 0"
+    # value_source default
+    # Default value: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 1 "0, 0, 0, 0"
+};
+
+# Default IP address mask
+# This IP address mask is the default used by RedBoot if a BOOTP/DHCP
+# server does not respond. The numbers should be separated by
+# *commas*, and not dots. If an IP address is configured into
+# the Flash configuration, that will be used in preference.
+#
+cdl_component CYGDAT_REDBOOT_DEFAULT_IP_ADDR_MASK {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_NETWORKING_USE_GATEWAY is disabled
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 "255, 255, 255, 0"
+    # value_source default
+    # Default value: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "255, 255, 255, 0" 
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 1 "255, 255, 255, 0"
+};
+
+# <
+# TCP port to listen for incoming connections
+# RedBoot will 'listen' on this port for incoming TCP connections.
+# This allows outside connections to be made to the platform, either
+# for GDB or RedBoot commands.
+#
+cdl_option CYGNUM_REDBOOT_NETWORKING_TCP_PORT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 9000
+    # value_source default
+    # Default value: 9000
+};
+
+# Number of [network] packet buffers
+# RedBoot may need to buffer network data to support various connections.
+# This option allows control over the number of such buffered packets,
+# and in turn, controls the amount of memory used by RedBoot (which
+# is not available to user applications).  Each packet buffer takes up
+# about 1514 bytes.  Note: there is little need to make this larger
+# than the default.
+#
+cdl_option CYGNUM_REDBOOT_NETWORKING_MAX_PKTBUF {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4
+    # value_source default
+    # Default value: 4
+    # Legal values: 3 to 8
+};
+
+# DNS support
+# When this option is enabled, RedBoot will be built with
+# support for DNS, allowing use of hostnames on the command
+# line.
+#
+cdl_component CYGPKG_REDBOOT_NETWORKING_DNS {
+    # ActiveIf constraint: CYGPKG_NS_DNS
+    #     CYGPKG_NS_DNS == current
+    #   --> 1
+
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 1
+    # Requires: !CYGPKG_NS_DNS_BUILD
+    #     CYGPKG_NS_DNS_BUILD == 0
+    #   --> 1
+};
+
+# >
+# Default DNS IP
+# This option sets the IP of the default DNS. The IP can be
+# changed at runtime as well.
+#
+cdl_option CYGPKG_REDBOOT_NETWORKING_DNS_IP {
+    # ActiveIf constraint: !CYGSEM_REDBOOT_FLASH_CONFIG
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 1
+
+    # Flavor: data
+    user_value 192.168.246.1
+    # value_source user
+    # Default value: 0.0.0.0
+};
+
+# Timeout in DNS lookup
+# This option sets the timeout used when looking up an
+# address via the DNS. Default is 10 seconds.
+#
+cdl_option CYGNUM_REDBOOT_NETWORKING_DNS_TIMEOUT {
+    # Flavor: data
+    user_value 10
+    # value_source user
+    # Default value: 10
+};
+
+# <
+# Default network device driver
+# This is the index of the first network device driver that
+# RedBoot will try to initialize.
+#
+cdl_option CYGNUM_REDBOOT_DEFAULT_NETWORK_DEVICE {
+    # This option is not active
+    # ActiveIf constraint:  !CYGSEM_REDBOOT_FLASH_CONFIG && CYGHWR_NET_DRIVERS > 1 
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #     CYGHWR_NET_DRIVERS == 1
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Legal values: 0 to CYGHWR_NET_DRIVERS-1
+    #     CYGHWR_NET_DRIVERS == 1
+};
+
+# Initialize only one net device
+# This option tells RedBoot to stop initializing network
+# devices when it finds the first device which is
+# successfully initialized. The default behavior causes
+# all network devices to be initialized.
+#
+cdl_option CYGSEM_REDBOOT_NETWORK_INIT_ONE_DEVICE {
+    # This option is not active
+    # ActiveIf constraint:  CYGHWR_NET_DRIVERS > 1 
+    #     CYGHWR_NET_DRIVERS == 1
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Allow RedBoot to use any I/O channel for its console.
+# If this option is enabled then RedBoot will attempt to use all
+# defined serial I/O channels for its console device.  Once input
+# arrives at one of these channels then the console will use only
+# that port.
+#
+cdl_option CYGPKG_REDBOOT_ANY_CONSOLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Allow RedBoot to adjust the baud rate on the serial console.
+# If this option is enabled then RedBoot will support commands to set
+# and query the baud rate on the selected console.
+#
+cdl_option CYGSEM_REDBOOT_VARIABLE_BAUD_RATE {
+    # This option is not active
+    # ActiveIf constraint: CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT
+    #     CYGINT_HAL_VIRTUAL_VECTOR_COMM_BAUD_SUPPORT == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Run a platform specific startup function.
+# If this option is enabled then RedBoot will execute a platform
+# specific startup function before entering into its command line
+# processing.  This allows the platform to perform any special
+# setups before RedBoot actually starts running.  Note: the entire
+# RedBoot environment will already be initialized at this point.
+#
+cdl_option CYGSEM_REDBOOT_PLF_STARTUP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Run a platform specific ESA validation function.
+# If this option is enabled then RedBoot will execute a platform
+# specific function to validate an ethernet ESA.  This would be
+# useful if the address must conform to standards set by the
+# hardware manufacturer, etc.
+#
+cdl_option CYGSEM_REDBOOT_PLF_ESA_VALIDATE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Maximum command line length
+# This option allows control over how long the CLI command line
+# should be.  This space will be allocated statically
+# rather than from RedBoot's stack.
+#
+cdl_option CYGPKG_REDBOOT_MAX_CMD_LINE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 256
+    # value_source default
+    # Default value: 256
+};
+
+# Command processing idle timeout (ms)
+# This option controls the timeout period before the
+# command processing is considered 'idle'.  Making this
+# number smaller will cause idle processing to take place
+# more often, etc.  The default value of 10ms is a reasonable
+# tradeoff between responsiveness and overhead.
+#
+cdl_option CYGNUM_REDBOOT_CLI_IDLE_TIMEOUT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+};
+
+# Dynamic memory pool size
+# Redboot as well as the memalloc packages use the HEAP definition from the
+# memory map as their work memory. This option determines which fraction goes
+# to redboot and which one goes to the dynamic memory allocator.
+#
+cdl_option CYGNUM_REDBOOT_MEMALLOC_POOL_SIZE {
+    # ActiveIf constraint:  CYGPKG_MEMALLOC 
+    #     CYGPKG_MEMALLOC == current
+    #   --> 1
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16384
+    # value_source default
+    # Default value: 16384
+};
+
+# Validate RAM addresses during load
+# This option controls whether or not RedBoot will make sure that
+# memory being used by the "load" command is in fact in user RAM.
+# Leaving the option enabled makes for a safer environment, but this
+# check may not be valid on all platforms, thus the ability to
+# disable it.  ** Disable this only with great care **
+#
+cdl_option CYGSEM_REDBOOT_VALIDATE_USER_RAM_LOADS {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+};
+
+# Allow RedBoot to support FLASH programming
+# If this option is enabled then RedBoot will provide commands
+# to manage images in FLASH memory.  These images can be loaded
+# into memory for execution or executed in place.
+#
+cdl_component CYGPKG_REDBOOT_FLASH {
+    # This option is not active
+    # ActiveIf constraint: CYGHWR_IO_FLASH_DEVICE
+    #     CYGHWR_IO_FLASH_DEVICE (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGPRI_REDBOOT_ZLIB_FLASH
+    #     ActiveIf: CYGPKG_REDBOOT_FLASH
+};
+
+# >
+# Byte order used to store info in flash.
+# This option controls the byte ordering used to store
+# the FIS directory info and flash config info.
+#
+cdl_option CYGOPT_REDBOOT_FLASH_BYTEORDER {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value NATURAL
+    # value_source default
+    # Default value: NATURAL
+    # Legal values: "NATURAL" "MSBFIRST" "LSBFIRST" 
+};
+
+# RedBoot Flash Image System support
+# doc: ref/flash-image-system.html
+# This option enables the Flash Image System commands
+# and support within RedBoot.  If disabled, simple Flash
+# access commands such as "fis write" will still exist.
+# This option would be disabled for targets that need simple
+# FLASH manipulation, but do not have the need or space for
+# complete image management.
+#
+cdl_option CYGOPT_REDBOOT_FIS {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGPKG_REDBOOT_FIS_CONTENTS
+    #     ActiveIf: CYGOPT_REDBOOT_FIS
+    # option CYGSEM_REDBOOT_FLASH_COMBINED_FIS_AND_CONFIG
+    #     ActiveIf:  CYGOPT_REDBOOT_FIS && (CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == "FLASH") 
+    # component CYGOPT_REDBOOT_FIS_ZLIB_COMMON_BUFFER
+    #     ActiveIf:  CYGBLD_BUILD_REDBOOT_WITH_ZLIB &&  CYGOPT_REDBOOT_FIS 
+};
+
+# Max number of chunks of free space to manage
+# If this option is defined then "fis free" will rely on the
+# FIS directory to determine what space is free within the FLASH.
+# This option controls the maximum number of free segment which
+# can be handled (typically this number is small).  If this option
+# is not enabled, the the archaic behaviour of actually scanning
+# the FLASH for erased sectors (unreliable) will be used to 
+# determine what's free and what's not.
+#
+cdl_option CYGDAT_REDBOOT_FIS_MAX_FREE_CHUNKS {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 32
+    # value_source default
+    # Default value: 1 32
+};
+
+# Flash Image System default directory contents
+#
+cdl_component CYGPKG_REDBOOT_FIS_CONTENTS {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+    # ActiveIf constraint: CYGOPT_REDBOOT_FIS
+    #     CYGOPT_REDBOOT_FIS == 0
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# >
+# Flash block containing the Directory
+# Which block of flash should hold the directory 
+# information. Positive numbers are absolute block numbers. 
+# Negative block numbers count backwards from the last block.
+# eg 2 means block 2, -2 means the last but one block.
+#
+cdl_option CYGNUM_REDBOOT_FIS_DIRECTORY_BLOCK {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -1
+    # value_source default
+    # Default value: -1
+};
+
+# Pseudo-file to describe reserved area
+# If an area of FLASH is reserved, it is informative to
+# have a fis entry describing it.  This option controls
+# creation of such an entry by default in the fis init
+# command.
+#
+cdl_option CYGOPT_REDBOOT_FIS_RESERVED_BASE {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+    # ActiveIf constraint:  0 != CYGNUM_REDBOOT_FLASH_RESERVED_BASE 
+    #     CYGNUM_REDBOOT_FLASH_RESERVED_BASE == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# File to describe RedBoot boot image
+# Normally a ROM-startup RedBoot image is first in the
+# FLASH, and the system boots using that image.  This
+# option controls creation of an entry describing it in
+# the fis init command.  It might be disabled if a
+# platform has an immutable boot image of its own, where
+# we use a POST-startup RedBoot instead, which performs
+# less board initialization.
+#
+cdl_option CYGOPT_REDBOOT_FIS_REDBOOT {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # component CYGOPT_REDBOOT_FIS_REDBOOT_POST
+    #     DefaultValue: !CYGOPT_REDBOOT_FIS_REDBOOT
+    # option CYGBLD_REDBOOT_MIN_IMAGE_SIZE
+    #     DefaultValue:  CYGOPT_REDBOOT_FIS_REDBOOT ? 0x20000 : 0 
+};
+
+# File to describe RedBoot POST-compatible image
+# This option controls creation of an entry describing a
+# POST-startup RedBoot image in the fis init command.
+# Not all platforms support POST-startup.  A platform
+# might have both for testing purposes, where the
+# eventual user would substitute their own POST code for
+# the initial ROM-startup RedBoot, and then jump to the
+# POST-compatible RedBoot immediately following.
+#
+cdl_component CYGOPT_REDBOOT_FIS_REDBOOT_POST {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: !CYGOPT_REDBOOT_FIS_REDBOOT
+    #     CYGOPT_REDBOOT_FIS_REDBOOT == 0
+    #   --> 1
+};
+
+# >
+# Offset of POST image from FLASH start
+# This option specifies the offset for a POST image from
+# the start of FLASH.  If unset, then the fis entry
+# describing the POST image will be placed where
+# convenient.
+#
+cdl_option CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET {
+    # This option is not active
+    # The parent CYGOPT_REDBOOT_FIS_REDBOOT_POST is not active
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+    # Requires:  CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET >=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+    #     CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET == 0
+    #     CYGBLD_REDBOOT_FLASH_BOOT_OFFSET == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET
+    #     Requires:  CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET >=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+};
+
+# <
+# File to describe RedBoot backup image
+# This option controls creation of an entry describing a
+# backup RedBoot image in the fis init command.
+# Conventionally a RAM-startup RedBoot image is kept
+# under this name for use in updating the ROM-based
+# RedBoot that boots the board.
+#
+cdl_option CYGOPT_REDBOOT_FIS_REDBOOT_BACKUP {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Include ARM SIB ID in FIS
+# If set, this option will cause the last 5 words of
+# the FIS to include the special ID needed for the
+# flash to be recognized as a reserved area for RedBoot
+# by an ARM BootRom monitor.
+#
+cdl_option CYGOPT_REDBOOT_FIS_DIRECTORY_ARM_SIB_ID {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Size of FIS directory entry
+# The FIS directory is limited to one single flash
+# sector. If your flash has tiny sectors, you may wish
+# to reduce this value in order to get more slots in
+# the FIS directory.
+#
+cdl_option CYGNUM_REDBOOT_FIS_DIRECTORY_ENTRY_SIZE {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 256
+    # value_source default
+    # Default value: 256
+};
+
+# Number of FIS directory entries
+# The FIS directory normally occupies a single flash
+# sector. Adjusting this value can allow for more than
+# one flash sector to be used, which is useful if your
+# sectors are very small.
+#
+cdl_option CYGNUM_REDBOOT_FIS_DIRECTORY_ENTRY_COUNT {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+};
+
+# Maximum RedBoot image size
+# This option controls the maximum length reserved
+# for the RedBoot boot image in the FIS table.
+# This should be a multiple of the flash's erase
+# block size.
+#
+cdl_option CYGBLD_REDBOOT_MIN_IMAGE_SIZE {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGOPT_REDBOOT_FIS_REDBOOT ? 0x20000 : 0 
+    #     CYGOPT_REDBOOT_FIS_REDBOOT == 0
+    #   --> 0
+};
+
+# Offset from start of FLASH to RedBoot boot image
+# This option controls where the RedBoot boot image is located
+# relative to the start of FLASH.
+#
+cdl_option CYGBLD_REDBOOT_FLASH_BOOT_OFFSET {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGNUM_REDBOOT_FLASH_RESERVED_BASE
+    #     CYGNUM_REDBOOT_FLASH_RESERVED_BASE == 0
+    #   --> 0
+    # Requires:  CYGNUM_REDBOOT_FLASH_RESERVED_BASE <=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+    #     CYGNUM_REDBOOT_FLASH_RESERVED_BASE == 0
+    #     CYGBLD_REDBOOT_FLASH_BOOT_OFFSET == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET
+    #     Requires:  CYGNUM_REDBOOT_FIS_REDBOOT_POST_OFFSET >=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+    # option CYGBLD_REDBOOT_FLASH_BOOT_OFFSET
+    #     Requires:  CYGNUM_REDBOOT_FLASH_RESERVED_BASE <=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+};
+
+# Size of reserved area at start of FLASH
+# This option reserves an area at the start of FLASH where RedBoot
+# will never interfere; it is expected that this area contains
+# (non-RedBoot-based) POST code or some other boot monitor that
+# executes before RedBoot.
+#
+cdl_option CYGNUM_REDBOOT_FLASH_RESERVED_BASE {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FIS_CONTENTS is not active
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGOPT_REDBOOT_FIS_RESERVED_BASE
+    #     ActiveIf:  0 != CYGNUM_REDBOOT_FLASH_RESERVED_BASE 
+    # option CYGBLD_REDBOOT_FLASH_BOOT_OFFSET
+    #     DefaultValue: CYGNUM_REDBOOT_FLASH_RESERVED_BASE
+    # option CYGBLD_REDBOOT_FLASH_BOOT_OFFSET
+    #     Requires:  CYGNUM_REDBOOT_FLASH_RESERVED_BASE <=  CYGBLD_REDBOOT_FLASH_BOOT_OFFSET 
+};
+
+# <
+# Keep all RedBoot FLASH data blocks locked.
+# When this option is enabled, RedBoot will keep configuration
+# data and the FIS directory blocks implicitly locked.  While
+# this is somewhat safer, it does add overhead during updates.
+#
+cdl_option CYGSEM_REDBOOT_FLASH_LOCK_SPECIAL {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+    # ActiveIf constraint:  CYGHWR_IO_FLASH_BLOCK_LOCKING != 0 
+    #     CYGHWR_IO_FLASH_BLOCK_LOCKING (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use CRC checksums on FIS images.
+# When this option is enabled, RedBoot will use CRC checksums
+# when reading and writing flash images.
+#
+cdl_option CYGSEM_REDBOOT_FIS_CRC_CHECK {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# ARM FLASH drivers support SIB flash block structure
+# This interface is implemented by a flash driver
+# to indicate that it supports the ARM SIB flash
+# block structure
+#
+cdl_interface CYGINT_REDBOOT_ARM_FLASH_SIB_SUPPORTED {
+    # No options implement this inferface
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+    # ActiveIf constraint: CYGPKG_HAL_ARM
+    #     CYGPKG_HAL_ARM (unknown) == 0
+    #   --> 0
+
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGHWR_REDBOOT_ARM_FLASH_SIB
+    #     ActiveIf: CYGINT_REDBOOT_ARM_FLASH_SIB_SUPPORTED
+};
+
+# Use ARM SIB flash block structure
+# This option is used to interpret ARM Flash System information
+# blocks.
+#
+cdl_option CYGHWR_REDBOOT_ARM_FLASH_SIB {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FLASH is not active
+    # ActiveIf constraint: CYGINT_REDBOOT_ARM_FLASH_SIB_SUPPORTED
+    #     CYGINT_REDBOOT_ARM_FLASH_SIB_SUPPORTED == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Keep RedBoot configuration data in FLASH
+# When this option is enabled, RedBoot will keep configuration
+# data in a separate block of FLASH memory.  This data will
+# include such items as the node IP address or startup scripts.
+#
+cdl_component CYGSEM_REDBOOT_FLASH_CONFIG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  CYGPKG_IO_FLASH != 0 
+    #     CYGPKG_IO_FLASH (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGDAT_REDBOOT_DEFAULT_IP_ADDR
+    #     DefaultValue: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    # option CYGDAT_REDBOOT_DEFAULT_BOOTP_SERVER_IP_ADDR
+    #     DefaultValue: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    # component CYGDAT_REDBOOT_DEFAULT_GATEWAY_IP_ADDR
+    #     DefaultValue: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "0, 0, 0, 0" 
+    # component CYGDAT_REDBOOT_DEFAULT_IP_ADDR_MASK
+    #     DefaultValue: CYGSEM_REDBOOT_FLASH_CONFIG ? 0 :  "255, 255, 255, 0" 
+    # option CYGPKG_REDBOOT_NETWORKING_DNS_IP
+    #     ActiveIf: !CYGSEM_REDBOOT_FLASH_CONFIG
+    # option CYGNUM_REDBOOT_DEFAULT_NETWORK_DEVICE
+    #     ActiveIf:  !CYGSEM_REDBOOT_FLASH_CONFIG && CYGHWR_NET_DRIVERS > 1 
+    # option CYGFUN_REDBOOT_BOOT_SCRIPT
+    #     ActiveIf:  CYGDAT_REDBOOT_DEFAULT_BOOT_SCRIPT ||  CYGSEM_REDBOOT_FLASH_CONFIG 
+};
+
+# >
+# Length of configuration data in FLASH
+# This option is used to control the amount of memory and FLASH
+# to be used for configuration options (persistent storage).
+#
+cdl_option CYGNUM_REDBOOT_FLASH_CONFIG_SIZE {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 4096
+    # value_source default
+    # Default value: 4096
+};
+
+# Style of media used for persistent data storage
+# Persistent data storage can either be held in 'norma' FLASH
+# or some other device (represented by the 'EEPROM' choice).
+# The different styles utilize different access methods.
+#
+cdl_option CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value FLASH
+    # value_source default
+    # Default value: FLASH
+    # Legal values:  "FLASH" "EEPROM" 
+
+    # The following properties are affected by this value
+    # option CYGSEM_REDBOOT_FLASH_COMBINED_FIS_AND_CONFIG
+    #     ActiveIf:  CYGOPT_REDBOOT_FIS && (CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == "FLASH") 
+    # option CYGSEM_REDBOOT_FLASH_CONFIG_READONLY_FALLBACK
+    #     DefaultValue:  (CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == "FLASH") 
+};
+
+# Merged config data and FIS directory
+# If this option is set, then the FIS directory and FLASH 
+# configuration database will be stored in the same physical
+# FLASH block.
+#
+cdl_option CYGSEM_REDBOOT_FLASH_COMBINED_FIS_AND_CONFIG {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+    # ActiveIf constraint:  CYGOPT_REDBOOT_FIS && (CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == "FLASH") 
+    #     CYGOPT_REDBOOT_FIS == 0
+    #     CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Which block of flash to use
+# Which block of flash should hold the configuration 
+# information. Positive numbers are absolute block numbers. 
+# Negative block numbers count backwards from the last block.
+# eg 2 means block 2, -2 means the last but one block.
+#
+cdl_option CYGNUM_REDBOOT_FLASH_CONFIG_BLOCK {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -2
+    # value_source default
+    # Default value: -2
+};
+
+# Support simple macros/aliases in FLASH
+# This option is used to allow support for simple text-based
+# macros (aliases).  These aliases are kept in the FLASH
+# configuration data (persistent storage).
+#
+cdl_option CYGSEM_REDBOOT_FLASH_ALIASES {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Length of strings in FLASH configuration data
+# This option is used to control the amount of memory and FLASH
+# to be used for string configuration options (persistent storage).
+#
+cdl_option CYGNUM_REDBOOT_FLASH_STRING_SIZE {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 128
+    # value_source default
+    # Default value: 128
+};
+
+# Length of configuration script(s) in FLASH
+# This option is used to control the amount of memory and FLASH
+# to be used for configuration options (persistent storage).
+#
+cdl_option CYGNUM_REDBOOT_FLASH_SCRIPT_SIZE {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 512
+    # value_source default
+    # Default value: 512
+};
+
+# Fallback to read-only FLASH configuration
+# This option will cause the configuration information to
+# revert to the readonly information stored in the FLASH.
+# The option only takes effect after 
+# 1) the config_ok flag has been set to be true,
+# indicating that at one time the copy in RAM was valid;
+# and
+# 2) the information in RAM has been verified to be invalid
+#
+cdl_option CYGSEM_REDBOOT_FLASH_CONFIG_READONLY_FALLBACK {
+    # This option is not active
+    # The parent CYGSEM_REDBOOT_FLASH_CONFIG is disabled
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  (CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == "FLASH") 
+    #     CYGHWR_REDBOOT_FLASH_CONFIG_MEDIA == 0
+    #   --> 0
+};
+
+# <
+# Allow RedBoot to support fileio
+# If this option is enabled then RedBoot will provide commands
+# to load files from fileio file systems such as JFFS2.
+#
+cdl_component CYGPKG_REDBOOT_FILEIO {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_IO_FILEIO
+    #     CYGPKG_IO_FILEIO (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGNUM_REDBOOT_GETC_BUFFER
+    #     DefaultValue:  CYGPKG_REDBOOT_FILEIO ? 4096 : 256 
+};
+
+# >
+# Include an ls command
+# If this option is enabled a simple ls command will be
+# included in redboot so the contents of a directory
+# can be listed
+#
+cdl_option CYGBLD_REDBOOT_FILEIO_WITH_LS {
+    # This option is not active
+    # The parent CYGPKG_REDBOOT_FILEIO is not active
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Allow RedBoot to support disks
+# If this option is enabled then RedBoot will provide commands
+# to load disk files.
+#
+cdl_component CYGPKG_REDBOOT_DISK {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Include Redboot commands for disk access
+#
+cdl_option CYGSEM_REDBOOT_DISK {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  CYGINT_REDBOOT_DISK_DRIVERS != 0 
+    #     CYGINT_REDBOOT_DISK_DRIVERS == 1
+    #   --> 1
+};
+
+# Hardware drivers for disk-type devices
+#
+cdl_interface CYGINT_REDBOOT_DISK_DRIVERS {
+    # Implemented by CYGSEM_REDBOOT_DISK_IDE, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+
+    # The following properties are affected by this value
+    # option CYGSEM_REDBOOT_DISK
+    #     DefaultValue:  CYGINT_REDBOOT_DISK_DRIVERS != 0 
+};
+
+# Maximum number of supported disks
+# This option controls the number of disks supported by RedBoot.
+#
+cdl_option CYGNUM_REDBOOT_MAX_DISKS {
+    # Flavor: data
+    user_value 4
+    # value_source user
+    # Default value: 4
+};
+
+# Maximum number of partitions per disk
+# This option controls the maximum number of supported partitions per disk.
+#
+cdl_option CYGNUM_REDBOOT_MAX_PARTITIONS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 8
+    # value_source default
+    # Default value: 8
+};
+
+# Support IDE disks.
+# When this option is enabled, RedBoot will support IDE disks.
+#
+cdl_component CYGSEM_REDBOOT_DISK_IDE {
+    # ActiveIf constraint:  CYGINT_HAL_PLF_IF_IDE != 0 
+    #     CYGINT_HAL_PLF_IF_IDE == 1
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Work with VMware virtual disks
+# This option controls the disk driver beaviour at ide-init
+#
+cdl_option CYGSEM_REDBOOT_DISK_IDE_VMWARE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Support Linux second extended filesystems.
+# When this option is enabled, RedBoot will support IDE disks.
+#
+cdl_component CYGSEM_REDBOOT_DISK_EXT2FS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Support ISO9660 filesystems.
+# When this option is enabled, RedBoot will support ISO9660 filesystems.
+#
+cdl_component CYGSEM_REDBOOT_DISK_ISO9660 {
+    # Calculated value: 0
+    # Flavor: bool
+    # Current value: 0
+};
+
+# <
+# Boot scripting
+# doc: ref/persistent-state-flash.html
+# This contains options related to RedBoot's boot script
+# functionality.
+#
+cdl_component CYGPKG_REDBOOT_BOOT_SCRIPT {
+    # There is no associated value.
+};
+
+# >
+# Boot scripting enabled
+# This option controls whether RedBoot boot script
+# functionality is enabled.
+#
+cdl_option CYGFUN_REDBOOT_BOOT_SCRIPT {
+    # This option is not active
+    # ActiveIf constraint:  CYGDAT_REDBOOT_DEFAULT_BOOT_SCRIPT ||  CYGSEM_REDBOOT_FLASH_CONFIG 
+    #     CYGDAT_REDBOOT_DEFAULT_BOOT_SCRIPT == 0
+    #     CYGSEM_REDBOOT_FLASH_CONFIG == 0
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Use default RedBoot boot script
+# If enabled, this option will tell RedBoot to use the value of
+# this option as a default boot script.
+#
+cdl_option CYGDAT_REDBOOT_DEFAULT_BOOT_SCRIPT {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGFUN_REDBOOT_BOOT_SCRIPT
+    #     ActiveIf:  CYGDAT_REDBOOT_DEFAULT_BOOT_SCRIPT ||  CYGSEM_REDBOOT_FLASH_CONFIG 
+};
+
+# Resolution (in ms) for script timeout value.
+# This option controls the resolution of the script timeout.
+# The value is specified in milliseconds (ms), thus to have the
+# script timeout be defined in terms of tenths of seconds, use 100.
+#
+cdl_option CYGNUM_REDBOOT_BOOT_SCRIPT_TIMEOUT_RESOLUTION {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 1000
+    # value_source default
+    # Default value: 1000
+};
+
+# Script default timeout value
+# This option is used to set the default timeout for startup
+# scripts, when they are enabled.
+#
+cdl_option CYGNUM_REDBOOT_BOOT_SCRIPT_DEFAULT_TIMEOUT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 10
+    # value_source default
+    # Default value: 10
+};
+
+# <
+# Support RTC for time & date functions
+# When this option is enabled, RedBoot will support commands to
+# query and set the real time clock (time and date)
+#
+cdl_option CYGSEM_REDBOOT_RTC {
+    # This option is not active
+    # ActiveIf constraint:  CYGPKG_IO_WALLCLOCK 
+    #     CYGPKG_IO_WALLCLOCK (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Behave like a ROM monitor
+# Enabling this option will allow RedBoot to provide ROM monitor-style
+# services to programs which it executes.
+#
+cdl_option CYGPRI_REDBOOT_ROM_MONITOR {
+    # This option is not active
+    # ActiveIf constraint:  CYG_HAL_STARTUP == "ROM" || CYG_HAL_STARTUP == "ROMRAM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+    # Requires: CYGSEM_HAL_ROM_MONITOR
+    #     CYGSEM_HAL_ROM_MONITOR == 1
+    #   --> 1
+};
+
+# Allow RedBoot to handle GNUPro application 'syscalls'.
+# If this option is enabled then RedBoot will install a syscall handler
+# to support debugging of applications based on GNUPro newlib/bsp.
+#
+cdl_component CYGSEM_REDBOOT_BSP_SYSCALLS {
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_HAL_GDB_FILEIO
+    #     ActiveIf: CYGSEM_REDBOOT_BSP_SYSCALLS
+};
+
+# >
+# Support additional syscalls for 'gprof' profiling
+# Support additional syscalls to support a periodic callback
+# function for histogram-style profiling, and an enquire/set
+# of the tick rate.
+# The application must use the GNUPro newlib facilities
+# to set this up.
+#
+cdl_option CYGSEM_REDBOOT_BSP_SYSCALLS_GPROF {
+    # This option is not active
+    # ActiveIf constraint:  0 < CYGINT_REDBOOT_BSP_SYSCALLS_GPROF_SUPPORT 
+    #     CYGINT_REDBOOT_BSP_SYSCALLS_GPROF_SUPPORT == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Does the HAL support 'gprof' profiling?
+#
+cdl_interface CYGINT_REDBOOT_BSP_SYSCALLS_GPROF_SUPPORT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_REDBOOT_BSP_SYSCALLS_GPROF
+    #     ActiveIf:  0 < CYGINT_REDBOOT_BSP_SYSCALLS_GPROF_SUPPORT 
+};
+
+# Do not raise SIGTRAP when program exits
+# For some (single shot) newlib based programs,
+# exiting and returning a termination status may be
+# the normal expected behavior.
+#
+cdl_option CYGOPT_REDBOOT_BSP_SYSCALLS_EXIT_WITHOUT_TRAP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# <
+# Use a common buffer for Zlib and FIS
+# Use a common memory buffer for both the zlib workspace
+# and FIS directory operations. This can save a substantial
+# amount of RAM, especially when flash sectors are large.
+#
+cdl_component CYGOPT_REDBOOT_FIS_ZLIB_COMMON_BUFFER {
+    # This option is not active
+    # ActiveIf constraint:  CYGBLD_BUILD_REDBOOT_WITH_ZLIB &&  CYGOPT_REDBOOT_FIS 
+    #     CYGBLD_BUILD_REDBOOT_WITH_ZLIB == 1
+    #     CYGOPT_REDBOOT_FIS == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Size of Zlib/FIS common buffer
+# Size of common buffer to allocate. Must be at least the
+# size of one flash sector.
+#
+cdl_option CYGNUM_REDBOOT_FIS_ZLIB_COMMON_BUFFER_SIZE {
+    # This option is not active
+    # The parent CYGOPT_REDBOOT_FIS_ZLIB_COMMON_BUFFER is not active
+    # The parent CYGOPT_REDBOOT_FIS_ZLIB_COMMON_BUFFER is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x0000C000
+    # value_source default
+    # Default value: 0x0000C000
+    # Legal values: 0x4000 to 0x80000000
+};
+
+# <
+# Buffer size in getc when loading images
+# When loading images a buffer is used between redboot and the
+# underlying storage medium, eg a filesystem, or a socket etc.
+# The size of this buffer can have a big impart on load speed.
+#
+cdl_option CYGNUM_REDBOOT_GETC_BUFFER {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 256
+    # value_source default
+    # Default value:  CYGPKG_REDBOOT_FILEIO ? 4096 : 256 
+    #     CYGPKG_REDBOOT_FILEIO == 0
+    #   --> 256
+};
+
+# <
+# Redboot HAL options
+# This option lists the target's requirements for a valid Redboot
+# configuration.
+#
+cdl_component CYGPKG_REDBOOT_HAL_OPTIONS {
+    # ActiveIf constraint: CYGPKG_REDBOOT
+    #     CYGPKG_REDBOOT == current
+    #   --> 1
+
+    # There is no associated value.
+};
+
+# >
+# Provide the exec command in RedBoot
+# This option contains requirements for booting linux
+# from RedBoot. The component is enabled/disabled from
+# RedBoots CDL.
+#
+cdl_component CYGPKG_REDBOOT_I386_LINUX_EXEC {
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT_WITH_EXEC
+    #     CYGBLD_BUILD_REDBOOT_WITH_EXEC == 1
+    #   --> 1
+
+    # There is no associated value.
+};
+
+# >
+# Provide the trampoline address into Linux
+#
+cdl_option CYGHWR_REDBOOT_I386_TRAMPOLINE_ADDRESS {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 0x0007C000
+    # value_source default
+    # Default value: 0x0007C000
+    # Requires: CYGINT_HAL_I386_PCMB_SCREEN_SUPPORT
+    #     CYGINT_HAL_I386_PCMB_SCREEN_SUPPORT == 1
+    #   --> 1
+};
+
+# <
+# Build RedBoot binary image
+#
+cdl_component CYGBLD_BUILD_REDBOOT_BIN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Build Redboot FLOPPY binary image
+# This option enables the conversion of the Redboot 
+# ELF image to a binary image suitable for
+# copying to a floppy disk.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_BIN_FLOPPY {
+    # This option is not active
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT
+    #     CYGBLD_BUILD_REDBOOT == 1
+    #   --> 1
+    # ActiveIf constraint:  CYG_HAL_STARTUP == "FLOPPY" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# Build Redboot ROM binary image
+# This option enables the conversion of the Redboot
+# ELF image to a binary image suitable for ROM
+# programming.
+#
+cdl_option CYGBLD_BUILD_REDBOOT_BIN_ROM {
+    # This option is not active
+    # ActiveIf constraint: CYGBLD_BUILD_REDBOOT
+    #     CYGBLD_BUILD_REDBOOT == 1
+    #   --> 1
+    # ActiveIf constraint:  CYG_HAL_STARTUP == "ROM" 
+    #     CYG_HAL_STARTUP == GRUB
+    #   --> 0
+
+    # Calculated value: 1
+    # Flavor: bool
+    # Current value: 1
+};
+
+# <
+# <
+# <
+# ISO C and POSIX infrastructure
+# eCos supports implementations of ISO C libraries and POSIX
+# implementations. This package provides infrastructure used by
+# all such implementations.
+#
+cdl_package CYGPKG_ISOINFRA {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_LIBC_STRING
+    #     Requires: CYGPKG_ISOINFRA
+    # package CYGPKG_COMPRESS_ZLIB
+    #     Requires: CYGPKG_ISOINFRA
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY
+    #     Requires: CYGPKG_ISOINFRA
+    # option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY
+    #     DefaultValue:  0 != CYGPKG_ISOINFRA 
+    # component CYGPKG_MEMALLOC_MALLOC_ALLOCATORS
+    #     ActiveIf: CYGPKG_ISOINFRA
+};
+
+# >
+# Startup and termination
+#
+cdl_component CYGPKG_ISO_STARTUP {
+    # There is no associated value.
+};
+
+# >
+# main() startup implementations
+# Implementations of this interface arrange for a user-supplied
+# main() to be called in an ISO compatible environment.
+#
+cdl_interface CYGINT_ISO_MAIN_STARTUP {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_MAIN_STARTUP 
+    #     CYGINT_ISO_MAIN_STARTUP == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MAIN_STARTUP
+    #     Requires:  1 >= CYGINT_ISO_MAIN_STARTUP 
+};
+
+# environ implementations
+# Implementations of this interface provide the environ
+# variable required by POSIX.
+#
+cdl_interface CYGINT_ISO_ENVIRON {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_ENVIRON 
+    #     CYGINT_ISO_ENVIRON == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ENVIRON
+    #     Requires:  1 >= CYGINT_ISO_ENVIRON 
+};
+
+# <
+# ctype.h functions
+#
+cdl_component CYGPKG_ISO_CTYPE_H {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of ctype functions
+#
+cdl_interface CYGINT_ISO_CTYPE {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_CTYPE 
+    #     CYGINT_ISO_CTYPE == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_CTYPE
+    #     Requires:  1 >= CYGINT_ISO_CTYPE 
+    # option CYGFUN_LIBC_STRING_BSD_FUNCS
+    #     Requires: CYGINT_ISO_CTYPE
+    # option CYGPKG_NS_DNS_BUILD
+    #     Requires: CYGINT_ISO_CTYPE
+};
+
+# Ctype implementation header
+#
+cdl_option CYGBLD_ISO_CTYPE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Error handling
+#
+cdl_component CYGPKG_ISO_ERRNO {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of error codes
+#
+cdl_interface CYGINT_ISO_ERRNO_CODES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_ERRNO_CODES 
+    #     CYGINT_ISO_ERRNO_CODES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ERRNO_CODES
+    #     Requires:  1 >= CYGINT_ISO_ERRNO_CODES 
+};
+
+# Error codes implementation header
+#
+cdl_option CYGBLD_ISO_ERRNO_CODES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of errno variable
+#
+cdl_interface CYGINT_ISO_ERRNO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_ERRNO 
+    #     CYGINT_ISO_ERRNO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_ERRNO
+    #     Requires:  1 >= CYGINT_ISO_ERRNO 
+};
+
+# errno variable implementation header
+#
+cdl_option CYGBLD_ISO_ERRNO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Locale-related functions
+#
+cdl_component CYGPKG_ISO_LOCALE {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of locale functions
+#
+cdl_interface CYGINT_ISO_LOCALE {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_LOCALE 
+    #     CYGINT_ISO_LOCALE == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_LOCALE
+    #     Requires:  1 >= CYGINT_ISO_LOCALE 
+};
+
+# Locale implementation header
+#
+cdl_option CYGBLD_ISO_LOCALE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Standard I/O-related functionality
+#
+cdl_component CYGPKG_ISO_STDIO {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of stdio file types
+#
+cdl_interface CYGINT_ISO_STDIO_FILETYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILETYPES 
+    #     CYGINT_ISO_STDIO_FILETYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILETYPES
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILETYPES 
+};
+
+# Stdio file types implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FILETYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Stdio standard streams implementations
+#
+cdl_interface CYGINT_ISO_STDIO_STREAMS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_STREAMS 
+    #     CYGINT_ISO_STDIO_STREAMS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_STREAMS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_STREAMS 
+};
+
+# Stdio standard streams implementation header
+# This header file must define stdin, stdout
+# and stderr.
+#
+cdl_option CYGBLD_ISO_STDIO_STREAMS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio file operations
+#
+cdl_interface CYGINT_ISO_STDIO_FILEOPS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEOPS 
+    #     CYGINT_ISO_STDIO_FILEOPS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEOPS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEOPS 
+};
+
+# Stdio file operations implementation header
+# This header controls the file system operations on a file
+# such as remove(), rename(), tmpfile(), tmpnam() and associated
+# constants.
+#
+cdl_option CYGBLD_ISO_STDIO_FILEOPS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio file access  functionals
+#
+cdl_interface CYGINT_ISO_STDIO_FILEACCESS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEACCESS 
+    #     CYGINT_ISO_STDIO_FILEACCESS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEACCESS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEACCESS 
+};
+
+# Stdio file access implementation header
+# This header controls the file access operations
+# such as fclose(), fflush(), fopen(), freopen(), setbuf(),
+# setvbuf(), and associated constants.
+#
+cdl_option CYGBLD_ISO_STDIO_FILEACCESS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio formatted I/O
+#
+cdl_interface CYGINT_ISO_STDIO_FORMATTED_IO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_FORMATTED_IO 
+    #     CYGINT_ISO_STDIO_FORMATTED_IO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FORMATTED_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FORMATTED_IO 
+};
+
+# Stdio formatted I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FORMATTED_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio character I/O
+#
+cdl_interface CYGINT_ISO_STDIO_CHAR_IO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_CHAR_IO 
+    #     CYGINT_ISO_STDIO_CHAR_IO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_CHAR_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_CHAR_IO 
+};
+
+# Stdio character I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_CHAR_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio direct I/O
+#
+cdl_interface CYGINT_ISO_STDIO_DIRECT_IO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_DIRECT_IO 
+    #     CYGINT_ISO_STDIO_DIRECT_IO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_DIRECT_IO
+    #     Requires:  1 >= CYGINT_ISO_STDIO_DIRECT_IO 
+};
+
+# Stdio direct I/O implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_DIRECT_IO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio file positioning
+#
+cdl_interface CYGINT_ISO_STDIO_FILEPOS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_FILEPOS 
+    #     CYGINT_ISO_STDIO_FILEPOS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_FILEPOS
+    #     Requires:  1 >= CYGINT_ISO_STDIO_FILEPOS 
+};
+
+# Stdio file positioning implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_FILEPOS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of stdio error handling
+#
+cdl_interface CYGINT_ISO_STDIO_ERROR {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STDIO_ERROR 
+    #     CYGINT_ISO_STDIO_ERROR == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_ERROR
+    #     Requires:  1 >= CYGINT_ISO_STDIO_ERROR 
+};
+
+# Stdio error handling implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_ERROR_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX fd-related function implementations
+#
+cdl_interface CYGINT_ISO_STDIO_POSIX_FDFUNCS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >=  CYGINT_ISO_STDIO_POSIX_FDFUNCS 
+    #     CYGINT_ISO_STDIO_POSIX_FDFUNCS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDIO_POSIX_FDFUNCS
+    #     Requires:  1 >=  CYGINT_ISO_STDIO_POSIX_FDFUNCS 
+};
+
+# POSIX fd-related function implementation header
+#
+cdl_option CYGBLD_ISO_STDIO_POSIX_FDFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Standard general utility functions
+#
+cdl_component CYGPKG_ISO_STDLIB {
+    # There is no associated value.
+};
+
+# >
+# String conversion function implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_STRCONV {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV 
+    #     CYGINT_ISO_STDLIB_STRCONV == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_STRCONV
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV 
+};
+
+# String conversion function implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_STRCONV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# String to FP conversion function implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_STRCONV_FLOAT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+    #     CYGINT_ISO_STDLIB_STRCONV_FLOAT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_STRCONV_FLOAT
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_STRCONV_FLOAT 
+};
+
+# String to FP conversion function implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_STRCONV_FLOAT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Random number generator implementations
+#
+cdl_interface CYGINT_ISO_RAND {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_RAND 
+    #     CYGINT_ISO_RAND == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_RAND
+    #     Requires:  1 >= CYGINT_ISO_RAND 
+};
+
+# Random number generator implementation header
+#
+cdl_option CYGBLD_ISO_RAND_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Malloc implementations
+#
+cdl_interface CYGINT_ISO_MALLOC {
+    # Implemented by CYGPKG_MEMALLOC_MALLOC_ALLOCATORS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MALLOC 
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MALLOC
+    #     Requires:  1 >= CYGINT_ISO_MALLOC 
+    # option CYGFUN_LIBC_STRING_STRDUP
+    #     ActiveIf: CYGINT_ISO_MALLOC
+    # option CYGPKG_NS_DNS_BUILD
+    #     Requires: CYGINT_ISO_MALLOC
+};
+
+# Malloc implementation header
+#
+cdl_option CYGBLD_ISO_MALLOC_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Mallinfo() implementations
+#
+cdl_interface CYGINT_ISO_MALLINFO {
+    # Implemented by CYGPKG_MEMALLOC_MALLOC_ALLOCATORS, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  1 >= CYGINT_ISO_MALLINFO 
+    #     CYGINT_ISO_MALLINFO == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MALLINFO
+    #     Requires:  1 >= CYGINT_ISO_MALLINFO 
+};
+
+# Mallinfo() implementation header
+#
+cdl_option CYGBLD_ISO_MALLINFO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Program exit functionality implementations
+#
+cdl_interface CYGINT_ISO_EXIT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_EXIT 
+    #     CYGINT_ISO_EXIT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_EXIT
+    #     Requires:  1 >= CYGINT_ISO_EXIT 
+    # option CYGFUN_INFRA_DUMMY_ABORT
+    #     Requires: !CYGINT_ISO_EXIT
+    # option CYGFUN_INFRA_DUMMY_ABORT
+    #     DefaultValue:  CYGINT_ISO_EXIT == 0 
+};
+
+# Program exit functionality implementation header
+#
+cdl_option CYGBLD_ISO_EXIT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Program environment implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_ENVIRON {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_ENVIRON 
+    #     CYGINT_ISO_STDLIB_ENVIRON == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_ENVIRON
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_ENVIRON 
+};
+
+# Program environment implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_ENVIRON_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# system() implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_SYSTEM {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_SYSTEM 
+    #     CYGINT_ISO_STDLIB_SYSTEM == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_SYSTEM
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_SYSTEM 
+};
+
+# system() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_SYSTEM_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# bsearch() implementations
+#
+cdl_interface CYGINT_ISO_BSEARCH {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_BSEARCH 
+    #     CYGINT_ISO_BSEARCH == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_BSEARCH
+    #     Requires:  1 >= CYGINT_ISO_BSEARCH 
+};
+
+# bsearch() implementation header
+#
+cdl_option CYGBLD_ISO_BSEARCH_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# qsort() implementations
+#
+cdl_interface CYGINT_ISO_QSORT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_QSORT 
+    #     CYGINT_ISO_STDLIB_QSORT (unknown) == 0
+    #   --> 1
+};
+
+# qsort() implementation header
+#
+cdl_option CYGBLD_ISO_QSORT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# abs()/labs() implementations
+#
+cdl_interface CYGINT_ISO_ABS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_ABS 
+    #     CYGINT_ISO_STDLIB_ABS (unknown) == 0
+    #   --> 1
+};
+
+# abs()/labs() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_ABS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# div()/ldiv() implementations
+#
+cdl_interface CYGINT_ISO_DIV {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_DIV 
+    #     CYGINT_ISO_STDLIB_DIV (unknown) == 0
+    #   --> 1
+};
+
+# div()/ldiv() implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_DIV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Header defining the implementation's MB_CUR_MAX
+#
+cdl_option CYGBLD_ISO_STDLIB_MB_CUR_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Multibyte character implementations
+#
+cdl_interface CYGINT_ISO_STDLIB_MULTIBYTE {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_STDLIB_MULTIBYTE 
+    #     CYGINT_ISO_STDLIB_MULTIBYTE == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STDLIB_MULTIBYTE
+    #     Requires:  1 >= CYGINT_ISO_STDLIB_MULTIBYTE 
+};
+
+# Multibyte character implementation header
+#
+cdl_option CYGBLD_ISO_STDLIB_MULTIBYTE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# String functions
+#
+cdl_component CYGPKG_ISO_STRING {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of strerror() function
+#
+cdl_interface CYGINT_ISO_STRERROR {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STRERROR 
+    #     CYGINT_ISO_STRERROR == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRERROR
+    #     Requires:  1 >= CYGINT_ISO_STRERROR 
+};
+
+# strerror() implementation header
+#
+cdl_option CYGBLD_ISO_STRERROR_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# memcpy() implementation header
+#
+cdl_option CYGBLD_ISO_MEMCPY_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# memset() implementation header
+#
+cdl_option CYGBLD_ISO_MEMSET_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of strtok_r() function
+#
+cdl_interface CYGINT_ISO_STRTOK_R {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRTOK_R 
+    #     CYGINT_ISO_STRTOK_R == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRTOK_R
+    #     Requires:  1 >= CYGINT_ISO_STRTOK_R 
+};
+
+# strtok_r() implementation header
+#
+cdl_option CYGBLD_ISO_STRTOK_R_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRTOK_R_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of locale-specific string  functions
+# This covers locale-dependent string functions such as strcoll()
+# and strxfrm().
+#
+cdl_interface CYGINT_ISO_STRING_LOCALE_FUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_LOCALE_FUNCS 
+    #     CYGINT_ISO_STRING_LOCALE_FUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_LOCALE_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_LOCALE_FUNCS 
+};
+
+# Locale-specific string functions' implementation  header
+# This covers locale-dependent string functions such as strcoll()
+# and strxfrm().
+#
+cdl_option CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_LOCALE_FUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of BSD string functions
+#
+cdl_interface CYGINT_ISO_STRING_BSD_FUNCS {
+    # Implemented by CYGFUN_LIBC_STRING_BSD_FUNCS, active, disabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_STRING_BSD_FUNCS 
+    #     CYGINT_ISO_STRING_BSD_FUNCS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_BSD_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_BSD_FUNCS 
+};
+
+# BSD string functions' implementation header
+#
+cdl_option CYGBLD_ISO_STRING_BSD_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/bsdstring.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGFUN_LIBC_STRING_BSD_FUNCS
+    #     Requires:  CYGBLD_ISO_STRING_BSD_FUNCS_HEADER ==  "<cyg/libc/string/bsdstring.h>" 
+};
+
+# Number of implementations of other mem*() functions
+#
+cdl_interface CYGINT_ISO_STRING_MEMFUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_MEMFUNCS 
+    #     CYGINT_ISO_STRING_MEMFUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_MEMFUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_MEMFUNCS 
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGINT_ISO_STRING_MEMFUNCS
+    # component CYGPKG_IO_ETH_DRIVERS_STAND_ALONE
+    #     Requires: CYGINT_ISO_STRING_MEMFUNCS
+};
+
+# Other mem*() functions' implementation header
+#
+cdl_option CYGBLD_ISO_STRING_MEMFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_MEMFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# Number of implementations of other ISO C str*()  functions
+# This covers the other str*() functions defined by ISO C.
+#
+cdl_interface CYGINT_ISO_STRING_STRFUNCS {
+    # Implemented by CYGPKG_LIBC_STRING, active, enabled
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 1
+    # Requires:  1 >= CYGINT_ISO_STRING_STRFUNCS 
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_STRING_STRFUNCS
+    #     Requires:  1 >= CYGINT_ISO_STRING_STRFUNCS 
+    # option CYGFUN_INFRA_DUMMY_STRLEN
+    #     Requires: !CYGINT_ISO_STRING_STRFUNCS
+    # option CYGFUN_INFRA_DUMMY_STRLEN
+    #     DefaultValue:  CYGINT_ISO_STRING_STRFUNCS == 0 
+    # component CYGBLD_BUILD_REDBOOT
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # component CYGPKG_IO_ETH_DRIVERS_NET
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+    # option CYGPKG_NS_DNS_BUILD
+    #     Requires: CYGINT_ISO_STRING_STRFUNCS
+};
+
+# Other ISO C str*() functions' implementation  header
+# This covers the other str*() functions defined by ISO C.
+#
+cdl_option CYGBLD_ISO_STRING_STRFUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # The inferred value should not be edited directly.
+    inferred_value 1 <cyg/libc/string/string.h>
+    # value_source inferred
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # package CYGPKG_LIBC_STRING
+    #     Requires:  CYGBLD_ISO_STRING_STRFUNCS_HEADER ==  "<cyg/libc/string/string.h>" 
+};
+
+# <
+# Clock and time functionality
+#
+cdl_component CYGPKG_ISO_TIME {
+    # There is no associated value.
+};
+
+# >
+# time_t implementation header
+#
+cdl_option CYGBLD_ISO_TIME_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# clock_t implementation header
+#
+cdl_option CYGBLD_ISO_CLOCK_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# struct timeval implementation header
+#
+cdl_option CYGBLD_ISO_STRUCTTIMEVAL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of POSIX timer types
+#
+cdl_interface CYGINT_ISO_POSIX_TIMER_TYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMER_TYPES 
+    #     CYGINT_ISO_POSIX_TIMER_TYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMER_TYPES
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMER_TYPES 
+};
+
+# POSIX timer types implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMER_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of POSIX clock types
+#
+cdl_interface CYGINT_ISO_POSIX_CLOCK_TYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_CLOCK_TYPES 
+    #     CYGINT_ISO_POSIX_CLOCK_TYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_CLOCK_TYPES
+    #     Requires:  1 >= CYGINT_ISO_POSIX_CLOCK_TYPES 
+};
+
+# POSIX clock types implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_CLOCK_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of ISO C types
+#
+cdl_interface CYGINT_ISO_C_TIME_TYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_C_TIME_TYPES 
+    #     CYGINT_ISO_C_TIME_TYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_C_TIME_TYPES
+    #     Requires:  1 >= CYGINT_ISO_C_TIME_TYPES 
+};
+
+# ISO C time types implementation header
+#
+cdl_option CYGBLD_ISO_C_TIME_TYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of POSIX timers
+#
+cdl_interface CYGINT_ISO_POSIX_TIMERS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMERS 
+    #     CYGINT_ISO_POSIX_TIMERS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMERS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMERS 
+};
+
+# POSIX timer implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMERS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of POSIX clocks
+#
+cdl_interface CYGINT_ISO_POSIX_CLOCKS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_CLOCKS 
+    #     CYGINT_ISO_POSIX_CLOCKS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_CLOCKS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_CLOCKS 
+};
+
+# POSIX clocks implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_CLOCKS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of ISO C clock functions
+#
+cdl_interface CYGINT_ISO_C_CLOCK_FUNCS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_C_CLOCK_FUNCS 
+    #     CYGINT_ISO_C_CLOCK_FUNCS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_C_CLOCK_FUNCS
+    #     Requires:  1 >= CYGINT_ISO_C_CLOCK_FUNCS 
+};
+
+# ISO C clock functions' implementation header
+#
+cdl_option CYGBLD_ISO_C_CLOCK_FUNCS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of implementations of tzset() function
+#
+cdl_interface CYGINT_ISO_TZSET {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_TZSET 
+    #     CYGINT_ISO_TZSET == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_TZSET
+    #     Requires:  1 >= CYGINT_ISO_TZSET 
+};
+
+# tzset() implementation header
+#
+cdl_option CYGBLD_ISO_TZSET_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Signal functionality
+#
+cdl_component CYGPKG_ISO_SIGNAL {
+    # There is no associated value.
+};
+
+# >
+# Number of implementations of signal numbers
+#
+cdl_interface CYGINT_ISO_SIGNAL_NUMBERS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SIGNAL_NUMBERS 
+    #     CYGINT_ISO_SIGNAL_NUMBERS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGNAL_NUMBERS
+    #     Requires:  1 >= CYGINT_ISO_SIGNAL_NUMBERS 
+};
+
+# Signal numbering implementation header
+# This header provides the mapping of signal
+# names (e.g. SIGBUS) to numbers.
+#
+cdl_option CYGBLD_ISO_SIGNAL_NUMBERS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Number of signal implementations
+#
+cdl_interface CYGINT_ISO_SIGNAL_IMPL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SIGNAL_IMPL 
+    #     CYGINT_ISO_SIGNAL_IMPL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGNAL_IMPL
+    #     Requires:  1 >= CYGINT_ISO_SIGNAL_IMPL 
+};
+
+# Signals implementation header
+#
+cdl_option CYGBLD_ISO_SIGNAL_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX real time signals feature test macro
+# This defines the POSIX feature test macro
+# that indicates that the POSIX real time signals
+# are present.
+#
+cdl_interface CYGINT_POSIX_REALTIME_SIGNALS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_POSIX_REALTIME_SIGNALS 
+    #     CYGINT_POSIX_REALTIME_SIGNALS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_POSIX_REALTIME_SIGNALS
+    #     Requires:  1 >= CYGINT_POSIX_REALTIME_SIGNALS 
+};
+
+# <
+# Non-local jumps functionality
+#
+cdl_component CYGPKG_ISO_SETJMP {
+    # There is no associated value.
+};
+
+# >
+# setjmp() / longjmp() implementations
+#
+cdl_interface CYGINT_ISO_SETJMP {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SETJMP 
+    #     CYGINT_ISO_SETJMP == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SETJMP
+    #     Requires:  1 >= CYGINT_ISO_SETJMP 
+};
+
+# setjmp() / longjmp() implementation header
+#
+cdl_option CYGBLD_ISO_SETJMP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# sigsetjmp() / siglongjmp() implementations
+#
+cdl_interface CYGINT_ISO_SIGSETJMP {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SIGSETJMP 
+    #     CYGINT_ISO_SIGSETJMP == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SIGSETJMP
+    #     Requires:  1 >= CYGINT_ISO_SIGSETJMP 
+};
+
+# sigsetjmp() / siglongjmp() implementation header
+#
+cdl_option CYGBLD_ISO_SIGSETJMP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Assertions implementation header
+#
+cdl_option CYGBLD_ISO_ASSERT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX file control
+# This covers the POSIX file control definitions,
+# normally found in <fcntl.h>
+#
+cdl_component CYGPKG_ISO_POSIX_FCNTL {
+    # There is no associated value.
+};
+
+# >
+# POSIX open flags implementation header
+#
+cdl_option CYGBLD_ISO_OFLAG_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX fcntl() implementations
+#
+cdl_interface CYGINT_ISO_FCNTL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_FCNTL 
+    #     CYGINT_ISO_FCNTL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_FCNTL
+    #     Requires:  1 >= CYGINT_ISO_FCNTL 
+};
+
+# POSIX fcntl() implementation header
+#
+cdl_option CYGBLD_ISO_FCNTL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX file open implementations
+#
+cdl_interface CYGINT_ISO_OPEN {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_OPEN 
+    #     CYGINT_ISO_OPEN == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_OPEN
+    #     Requires:  1 >= CYGINT_ISO_OPEN 
+};
+
+# POSIX file open implementation header
+#
+cdl_option CYGBLD_ISO_OPEN_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# <sys/stat.h> definitions implementation header
+#
+cdl_option CYGBLD_ISO_STAT_DEFS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX directory reading implementation
+#
+cdl_interface CYGINT_ISO_DIRENT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_DIRENT 
+    #     CYGINT_ISO_DIRENT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DIRENT
+    #     Requires:  1 >= CYGINT_ISO_DIRENT 
+};
+
+# <dirent.h> definitions implementation header
+#
+cdl_option CYGBLD_ISO_DIRENT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX <sys/types.h> contents
+# This covers the types required by POSIX to be in
+# <sys/types.h>
+#
+cdl_component CYGPKG_ISO_POSIX_TYPES {
+    # There is no associated value.
+};
+
+# >
+# POSIX thread types implementations
+#
+cdl_interface CYGINT_ISO_PTHREADTYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    #     CYGINT_ISO_PTHREADTYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREADTYPES
+    #     Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    # interface CYGINT_ISO_PMUTEXTYPES
+    #     Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+};
+
+# POSIX thread types implementation header
+#
+cdl_option CYGBLD_ISO_PTHREADTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX mutex types implementations
+#
+cdl_interface CYGINT_ISO_PMUTEXTYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_PTHREADTYPES 
+    #     CYGINT_ISO_PTHREADTYPES == 0
+    #   --> 1
+};
+
+# POSIX mutex types implementation header
+#
+cdl_option CYGBLD_ISO_PMUTEXTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# ssize_t implementation header
+#
+cdl_option CYGBLD_ISO_SSIZE_T_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Filesystem types implementation header
+#
+cdl_option CYGBLD_ISO_FSTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# gid_t, pid_t, uid_t implementation header
+#
+cdl_option CYGBLD_ISO_SCHEDTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Non-POSIX <sys/types.h> contents
+# This covers the extra types required by non-POSIX
+# packages to be in <sys/types.h>. These would normally
+# only be visible if _POSIX_SOURCE is not defined.
+#
+cdl_component CYGPKG_ISO_EXTRA_TYPES {
+    # There is no associated value.
+};
+
+# >
+# BSD compatible types
+#
+cdl_interface CYGINT_ISO_BSDTYPES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_BSDTYPES 
+    #     CYGINT_ISO_BSDTYPES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_BSDTYPES
+    #     Requires:  1 >= CYGINT_ISO_BSDTYPES 
+};
+
+# BSD types header
+#
+cdl_option CYGBLD_ISO_BSDTYPES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Utsname structure
+#
+cdl_component CYGPKG_ISO_UTSNAME {
+    # There is no associated value.
+};
+
+# >
+# Utsname header
+#
+cdl_option CYGBLD_ISO_UTSNAME_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX scheduler
+#
+cdl_component CYGPKG_ISO_SCHED {
+    # There is no associated value.
+};
+
+# >
+# POSIX scheduler implementations
+#
+cdl_interface CYGINT_ISO_SCHED_IMPL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SCHED_IMPL 
+    #     CYGINT_ISO_SCHED_IMPL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SCHED_IMPL
+    #     Requires:  1 >= CYGINT_ISO_SCHED_IMPL 
+};
+
+# POSIX scheduler implementation header
+#
+cdl_option CYGBLD_ISO_SCHED_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX semaphores
+#
+cdl_component CYGPKG_ISO_SEMAPHORES {
+    # There is no associated value.
+};
+
+# >
+# POSIX semaphore implementations
+#
+cdl_interface CYGINT_ISO_SEMAPHORES {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_SEMAPHORES 
+    #     CYGINT_ISO_SEMAPHORES == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SEMAPHORES
+    #     Requires:  1 >= CYGINT_ISO_SEMAPHORES 
+};
+
+# POSIX semaphore implementation header
+#
+cdl_option CYGBLD_ISO_SEMAPHORES_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX message queues
+#
+cdl_component CYGPKG_ISO_MQUEUE {
+    # There is no associated value.
+};
+
+# >
+# Implementations
+#
+cdl_interface CYGINT_ISO_MQUEUE {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_MQUEUE 
+    #     CYGINT_ISO_MQUEUE == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_MQUEUE
+    #     Requires:  1 >= CYGINT_ISO_MQUEUE 
+    # option CYGNUM_ISO_MQUEUE_OPEN_MAX
+    #     ActiveIf: CYGINT_ISO_MQUEUE
+    # option CYGNUM_ISO_MQUEUE_PRIO_MAX
+    #     ActiveIf: CYGINT_ISO_MQUEUE
+};
+
+# Implementation header
+#
+cdl_option CYGBLD_ISO_MQUEUE_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Maximum number of open message queues
+#
+cdl_option CYGNUM_ISO_MQUEUE_OPEN_MAX {
+    # This option is not active
+    # ActiveIf constraint: CYGINT_ISO_MQUEUE
+    #     CYGINT_ISO_MQUEUE == 0
+    #   --> 0
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value:  CYGNUM_POSIX_MQUEUE_OPEN_MAX > 0 ? CYGNUM_POSIX_MQUEUE_OPEN_MAX : 0 
+    #     CYGNUM_POSIX_MQUEUE_OPEN_MAX (unknown) == 0
+    #     CYGNUM_POSIX_MQUEUE_OPEN_MAX (unknown) == 0
+    #   --> 0 0
+};
+
+# Maximum number of message priorities
+#
+cdl_option CYGNUM_ISO_MQUEUE_PRIO_MAX {
+    # This option is not active
+    # ActiveIf constraint: CYGINT_ISO_MQUEUE
+    #     CYGINT_ISO_MQUEUE == 0
+    #   --> 0
+
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 1 65535
+    # value_source default
+    # Default value: 1 65535
+};
+
+# <
+# POSIX threads
+#
+cdl_component CYGPKG_ISO_PTHREAD {
+    # There is no associated value.
+};
+
+# >
+# POSIX pthread implementations
+#
+cdl_interface CYGINT_ISO_PTHREAD_IMPL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_PTHREAD_IMPL 
+    #     CYGINT_ISO_PTHREAD_IMPL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREAD_IMPL
+    #     Requires:  1 >= CYGINT_ISO_PTHREAD_IMPL 
+};
+
+# POSIX pthread implementation header
+#
+cdl_option CYGBLD_ISO_PTHREAD_IMPL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX mutex/cond var implementations
+#
+cdl_interface CYGINT_ISO_PTHREAD_MUTEX {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_PTHREAD_MUTEX 
+    #     CYGINT_ISO_PTHREAD_MUTEX == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_PTHREAD_MUTEX
+    #     Requires:  1 >= CYGINT_ISO_PTHREAD_MUTEX 
+};
+
+# POSIX mutex/cond var implementation header
+#
+cdl_option CYGBLD_ISO_PTHREAD_MUTEX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Limits
+#
+cdl_component CYGPKG_ISO_LIMITS {
+    # There is no associated value.
+};
+
+# >
+# POSIX pthread limits implementations
+#
+cdl_interface CYGINT_ISO_POSIX_LIMITS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_LIMITS 
+    #     CYGINT_ISO_POSIX_LIMITS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_LIMITS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_LIMITS 
+};
+
+# POSIX pthread limits implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_LIMITS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# OPEN_MAX implementation header
+#
+cdl_option CYGBLD_ISO_OPEN_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# LINK_MAX implementation header
+#
+cdl_option CYGBLD_ISO_LINK_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# NAME_MAX implementation header
+#
+cdl_option CYGBLD_ISO_NAME_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# PATH_MAX implementation header
+#
+cdl_option CYGBLD_ISO_PATH_MAX_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# POSIX termios
+#
+cdl_component CYGPKG_ISO_TERMIOS {
+    # There is no associated value.
+};
+
+# >
+# POSIX termios implementations
+#
+cdl_interface CYGINT_ISO_TERMIOS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_TERMIOS 
+    #     CYGINT_ISO_TERMIOS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_TERMIOS
+    #     Requires:  1 >= CYGINT_ISO_TERMIOS 
+};
+
+# POSIX termios implementation header
+#
+cdl_option CYGBLD_ISO_TERMIOS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Dynamic load API
+#
+cdl_component CYGPKG_ISO_DLFCN {
+    # There is no associated value.
+};
+
+# >
+# Dynamic load implementations
+#
+cdl_interface CYGINT_ISO_DLFCN {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+    # Requires:  1 >= CYGINT_ISO_DLFCN 
+    #     CYGINT_ISO_DLFCN == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DLFCN
+    #     Requires:  1 >= CYGINT_ISO_DLFCN 
+};
+
+# Dynamic load implementation header
+#
+cdl_option CYGBLD_ISO_DLFCN_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# UNIX standard functions
+#
+cdl_component CYGPKG_ISO_UNISTD {
+    # There is no associated value.
+};
+
+# >
+# POSIX timer operations implementations
+#
+cdl_interface CYGINT_ISO_POSIX_TIMER_OPS {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_TIMER_OPS 
+    #     CYGINT_ISO_POSIX_TIMER_OPS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_TIMER_OPS
+    #     Requires:  1 >= CYGINT_ISO_POSIX_TIMER_OPS 
+};
+
+# POSIX timer operations implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_TIMER_OPS_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# POSIX sleep() implementations
+#
+cdl_interface CYGINT_ISO_POSIX_SLEEP {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POSIX_SLEEP 
+    #     CYGINT_ISO_POSIX_SLEEP == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POSIX_SLEEP
+    #     Requires:  1 >= CYGINT_ISO_POSIX_SLEEP 
+};
+
+# POSIX sleep() implementation header
+#
+cdl_option CYGBLD_ISO_POSIX_SLEEP_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# select()/poll() functions
+#
+cdl_component CYGPKG_ISO_SELECT {
+    # There is no associated value.
+};
+
+# >
+# select() implementations
+#
+cdl_interface CYGINT_ISO_SELECT {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_SELECT 
+    #     CYGINT_ISO_SELECT == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_SELECT
+    #     Requires:  1 >= CYGINT_ISO_SELECT 
+};
+
+# select() implementation header
+#
+cdl_option CYGBLD_ISO_SELECT_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# poll() implementations
+#
+cdl_interface CYGINT_ISO_POLL {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 0 0
+    # Requires:  1 >= CYGINT_ISO_POLL 
+    #     CYGINT_ISO_POLL == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_POLL
+    #     Requires:  1 >= CYGINT_ISO_POLL 
+};
+
+# poll() implementation header
+#
+cdl_option CYGBLD_ISO_POLL_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# NetDB utility functions
+#
+cdl_component CYGPKG_ISO_NETDB {
+    # There is no associated value.
+};
+
+# >
+# DNS implementations
+#
+cdl_interface CYGINT_ISO_DNS {
+    # Implemented by CYGPKG_NS_DNS_BUILD, active, disabled
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_DNS 
+    #     CYGINT_ISO_DNS == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_DNS
+    #     Requires:  1 >= CYGINT_ISO_DNS 
+};
+
+# DNS implementation header
+#
+cdl_option CYGBLD_ISO_DNS_HEADER {
+    # Flavor: booldata
+    user_value 1 <cyg/ns/dns/dns.h>
+    # value_source user
+    # Default value: 0 0
+
+    # The following properties are affected by this value
+    # option CYGPKG_NS_DNS_BUILD
+    #     Requires:  CYGBLD_ISO_DNS_HEADER == "<cyg/ns/dns/dns.h>" 
+};
+
+# Protocol network database implementations
+#
+cdl_interface CYGINT_ISO_NETDB_PROTO {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_NETDB_PROTO 
+    #     CYGINT_ISO_NETDB_PROTO == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_NETDB_PROTO
+    #     Requires:  1 >= CYGINT_ISO_NETDB_PROTO 
+};
+
+# Protocol network database implementation header
+#
+cdl_option CYGBLD_ISO_NETDB_PROTO_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# Services network database implementations
+#
+cdl_interface CYGINT_ISO_NETDB_SERV {
+    # No options implement this inferface
+    # This value cannot be modified here.
+    # Flavor: bool
+    # Current value: 0
+    # Requires:  1 >= CYGINT_ISO_NETDB_SERV 
+    #     CYGINT_ISO_NETDB_SERV == 0
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_ISO_NETDB_SERV
+    #     Requires:  1 >= CYGINT_ISO_NETDB_SERV 
+};
+
+# Services network database implementation header
+#
+cdl_option CYGBLD_ISO_NETDB_SERV_HEADER {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# <
+# Build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_ISOINFRA_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the ISO C and POSIX infrastructure package.
+# These flags are used in addition to the set of global flags.
+#
+cdl_option CYGPKG_ISOINFRA_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the ISO C and POSIX infrastructure package.
+# These flags are removed from the set of global flags
+# if present.
+#
+cdl_option CYGPKG_ISOINFRA_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# <
+# Compute CRCs
+# doc: ref/services-crc.html
+# This package provides support for CRC calculation. Currently 
+# this is the POSIX 1003 defined CRC algorithm, a 32 CRC by 
+# Gary S. Brown, and a 16 bit CRC.
+#
+cdl_package CYGPKG_CRC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # package CYGPKG_COMPRESS_ZLIB
+    #     Requires: CYGPKG_CRC
+};
+
+# >
+# POSIX CRC tests
+#
+cdl_option CYGPKG_CRC_TESTS {
+    # Calculated value:  "tests/crc_test" 
+    # Flavor: data
+    # Current_value: tests/crc_test
+};
+
+# <
+# Zlib compress and decompress package
+# This package provides support for compression and
+# decompression.
+#
+cdl_package CYGPKG_COMPRESS_ZLIB {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_CRC
+    #     CYGPKG_CRC == current
+    #   --> 1
+
+    # The following properties are affected by this value
+    # component CYGBLD_BUILD_REDBOOT_WITH_ZLIB
+    #     ActiveIf: CYGPKG_COMPRESS_ZLIB
+};
+
+# >
+# Override memory allocation routines.
+#
+cdl_interface CYGINT_COMPRESS_ZLIB_LOCAL_ALLOC {
+    # Implemented by CYGBLD_REDBOOT_ZLIB_LOCAL_ALLOC, inactive, disabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 0
+
+    # The following properties are affected by this value
+    # option CYGSEM_COMPRESS_ZLIB_NEEDS_MALLOC
+    #     ActiveIf:  CYGINT_COMPRESS_ZLIB_LOCAL_ALLOC == 0 
+};
+
+# Should deflate() produce 'gzip' compatible output?
+# If this option is set then the output of calling deflate()
+# will be wrapped up as a 'gzip' compatible file.
+#
+cdl_option CYGSEM_COMPRESS_ZLIB_DEFLATE_MAKES_GZIP {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Does this library need malloc?
+# This pseudo-option will force the memalloc library to be
+# required iff the application does not provide it's own
+# infrastructure.
+#
+cdl_option CYGSEM_COMPRESS_ZLIB_NEEDS_MALLOC {
+    # ActiveIf constraint:  CYGINT_COMPRESS_ZLIB_LOCAL_ALLOC == 0 
+    #     CYGINT_COMPRESS_ZLIB_LOCAL_ALLOC == 0
+    #   --> 1
+
+    # Flavor: bool
+    user_value 1
+    # value_source user
+    # Default value: 1
+    # Requires: CYGPKG_MEMALLOC
+    #     CYGPKG_MEMALLOC == current
+    #   --> 1
+};
+
+# Zlib compress and decompress package build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_COMPRESS_ZLIB_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_COMPRESS_ZLIB_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D__ECOS__ -DNO_ERRNO_H"
+    # value_source default
+    # Default value: "-D__ECOS__ -DNO_ERRNO_H"
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_COMPRESS_ZLIB_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value -Wstrict-prototypes
+    # value_source default
+    # Default value: -Wstrict-prototypes
+};
+
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_COMPRESS_ZLIB_LDFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_COMPRESS_ZLIB_LDFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# zlib tests
+#
+cdl_option CYGPKG_COMPRESS_ZLIB_TESTS {
+    # Calculated value:  "tests/zlib1.c tests/zlib2.c" 
+    # Flavor: data
+    # Current_value: tests/zlib1.c tests/zlib2.c
+};
+
+# <
+# DNS client
+# doc: ref/net-ns-dns.html
+#
+cdl_package CYGPKG_NS_DNS {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # component CYGPKG_REDBOOT_NETWORKING_DNS
+    #     ActiveIf: CYGPKG_NS_DNS
+};
+
+# >
+# Build DNS NS client package
+#
+cdl_option CYGPKG_NS_DNS_BUILD {
+    # Flavor: bool
+    user_value 0
+    # value_source user
+    # Default value: 1
+    # Requires:  CYGBLD_ISO_DNS_HEADER == "<cyg/ns/dns/dns.h>" 
+    #     CYGBLD_ISO_DNS_HEADER == <cyg/ns/dns/dns.h>
+    #   --> 1
+    # Requires: CYGPKG_NET
+    #     CYGPKG_NET (unknown) == 0
+    #   --> 0
+    # Requires: CYGINT_ISO_CTYPE
+    #     CYGINT_ISO_CTYPE == 0
+    #   --> 0
+    # Requires: CYGINT_ISO_MALLOC
+    #     CYGINT_ISO_MALLOC == 1
+    #   --> 1
+    # Requires: CYGINT_ISO_STRING_STRFUNCS
+    #     CYGINT_ISO_STRING_STRFUNCS == 1
+    #   --> 1
+    # Requires: CYGSEM_KERNEL_THREADS_DESTRUCTORS_PER_THREAD
+    #     CYGSEM_KERNEL_THREADS_DESTRUCTORS_PER_THREAD (unknown) == 0
+    #   --> 0
+
+    # The following properties are affected by this value
+    # component CYGPKG_NS_DNS_DEFAULT
+    #     ActiveIf: CYGPKG_NS_DNS_BUILD
+    # component CYGPKG_NS_DNS_DOMAINNAME
+    #     ActiveIf: CYGPKG_NS_DNS_BUILD
+    # option CYGPKG_NS_DNS_TESTS
+    #     ActiveIf: CYGPKG_NS_DNS_BUILD
+    # component CYGPKG_REDBOOT_NETWORKING_DNS
+    #     Requires: !CYGPKG_NS_DNS_BUILD
+};
+
+# Provide a hard coded default server address
+# This option controls the use of a default, hard coded DNS 
+# server. When this is enabled, the IPv4 or IPv6 address in 
+# the CDL option CYGDAT_NS_DNS_DEFAULT_SERVER is used in
+# init_all_network_interfaces() to start the resolver using 
+# the specified server. The DHCP client or user code may 
+# override this by restarting the resolver.
+#
+cdl_component CYGPKG_NS_DNS_DEFAULT {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NS_DNS_BUILD
+    #     CYGPKG_NS_DNS_BUILD == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# IP address of the default DNS server
+#
+cdl_option CYGDAT_NS_DNS_DEFAULT_SERVER {
+    # This option is not active
+    # The parent CYGPKG_NS_DNS_DEFAULT is not active
+    # The parent CYGPKG_NS_DNS_DEFAULT is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 192.168.1.1
+    # value_source default
+    # Default value: 192.168.1.1
+};
+
+# <
+# Provide a hard coded default domain name
+# This option controls the use of a default, hard coded
+# domain name to be used when querying a DNS server. When
+# this is enabled, the name in the CDL option
+# CYGDAT_NS_DNS_DOMAINNAME_NAME is used in
+# init_all_network_interfaces() to set the domain name as
+# accessed by getdomainname().
+#
+cdl_component CYGPKG_NS_DNS_DOMAINNAME {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NS_DNS_BUILD
+    #     CYGPKG_NS_DNS_BUILD == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# >
+# Domain name for this device
+#
+cdl_option CYGDAT_NS_DNS_DOMAINNAME_NAME {
+    # This option is not active
+    # The parent CYGPKG_NS_DNS_DOMAINNAME is not active
+    # The parent CYGPKG_NS_DNS_DOMAINNAME is disabled
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value default.domain.com
+    # value_source default
+    # Default value: default.domain.com
+};
+
+# <
+# Max number of results for getaddrinfo
+# This option controls the number of addresses the DNS client
+# can return to getaddrinfo and hence the size of the buffer
+# passed to the DNS client.
+#
+cdl_option CYGNUM_NS_DNS_GETADDRINFO_ADDRESSES {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 5
+    # value_source default
+    # Default value: 5
+};
+
+# AF_INET or AF_INET6 first in the getaddrinfo list
+# This option controls the order DNS results will appear in the 
+# information returned by getaddrinfo. This will in turn control 
+# the order in which network clients try talking to servers,
+# ie does it try IPv6 or IPv4 addresses first when it has both 
+# types of addresses.
+#
+cdl_option CYGOPT_NS_DNS_FIRST_FAMILY {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NET_INET6
+    #     CYGPKG_NET_INET6 (unknown) == 0
+    #   --> 0
+
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value AF_INET6
+    # value_source default
+    # Default value: AF_INET6
+    # Legal values: "AF_INET4" "AF_INET6"
+};
+
+# DNS support build options
+#
+cdl_component CYGPKG_NS_DNS_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building the DNS package.
+# These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_NS_DNS_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value "-D_KERNEL -D__ECOS"
+    # value_source default
+    # Default value: "-D_KERNEL -D__ECOS"
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building the DNS package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_NS_DNS_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# <
+# DNS test
+# This option specifies the set of tests for the DNS package.
+#
+cdl_option CYGPKG_NS_DNS_TESTS {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_NS_DNS_BUILD
+    #     CYGPKG_NS_DNS_BUILD == 0
+    #   --> 0
+
+    # Calculated value:  "tests/dns1" 
+    # Flavor: data
+    # Current_value: tests/dns1
+};
+
+# Use Andrew Lunn's DNS server for tests
+# Run the tests against Andrew Lunn's DNS server. Servers
+# come and go, IP addresses change, links are sometime down. 
+# So this may not work....
+#
+cdl_option CYGPKG_NS_DNS_TESTS_LUNN {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Iztok Zupet DNS server at Elsis for tests
+# Run the tests against Iztok Zupet DNS server at
+# Elsis. Servers come and go, IP addresses change, links are
+# sometime down.  So this may not work....
+#
+cdl_option CYGPKG_NS_DNS_TESTS_ELSIS {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Dynamic memory allocation
+# This package provides memory allocator infrastructure required for
+# dynamic memory allocators, including the ISO standard malloc
+# interface. It also contains some sample implementations.
+#
+cdl_package CYGPKG_MEMALLOC {
+    # Packages cannot be added or removed, nor can their version be changed,
+    # simply by editing their value. Instead the appropriate configuration
+    # should be used to perform these actions.
+
+    # This value cannot be modified here.
+    # Flavor: booldata
+    # Current value: 1 current
+
+    # The following properties are affected by this value
+    # option CYGBLD_REDBOOT_ZLIB_LOCAL_ALLOC
+    #     ActiveIf: !CYGPKG_MEMALLOC
+    # option CYGNUM_REDBOOT_MEMALLOC_POOL_SIZE
+    #     ActiveIf:  CYGPKG_MEMALLOC 
+    # option CYGSEM_COMPRESS_ZLIB_NEEDS_MALLOC
+    #     Requires: CYGPKG_MEMALLOC
+};
+
+# >
+# Memory allocator implementations
+# This component contains configuration options related to the 
+# various memory allocators available.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATORS {
+    # There is no associated value.
+};
+
+# >
+# Fixed block allocator
+# This component contains configuration options related to the 
+# fixed block memory allocator.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_FIXED {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_FIXED_THREADAWARE {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# Simple variable block allocator
+# This component contains configuration options related to the 
+# simple variable block memory allocator. This allocator is not
+# very fast, and in particular does not scale well with large
+# numbers of allocations. It is however very compact in terms of
+# code size and does not have very much overhead per allocation.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_VARIABLE {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are added that allow a thread to wait until memory
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_THREADAWARE {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Coalesce memory
+# The variable-block memory allocator can perform coalescing
+# of memory whenever the application code releases memory back
+# to the pool. This coalescing reduces the possibility of
+# memory fragmentation problems, but involves extra code and
+# processor cycles.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+
+    # The following properties are affected by this value
+    # option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE
+    #     Requires: CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE
+};
+
+# <
+# Doug Lea's malloc
+# This component contains configuration options related to the 
+# port of Doug Lea's memory allocator, normally known as
+# dlmalloc. dlmalloc has a reputation for being both fast
+# and space-conserving, as well as resisting fragmentation well.
+# It is a common choice for a general purpose allocator and
+# has been used in both newlib and Linux glibc.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_DLMALLOC {
+    # There is no associated value.
+};
+
+# >
+# Debug build
+# Doug Lea's malloc implementation has substantial amounts
+# of internal checking in order to verify the operation
+# and consistency of the allocator. However this imposes
+# substantial overhead on each operation. Therefore this
+# checking may be individually disabled.
+#
+cdl_option CYGDBG_MEMALLOC_ALLOCATOR_DLMALLOC_DEBUG {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value:  0 != CYGDBG_USE_ASSERTS 
+    #     CYGDBG_USE_ASSERTS == 0
+    #   --> 0
+    # Requires: CYGDBG_USE_ASSERTS
+    #     CYGDBG_USE_ASSERTS == 0
+    #   --> 0
+};
+
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_THREADAWARE {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+};
+
+# Support more than one instance
+# Having this option disabled allows important
+# implementation structures to be declared as a single
+# static instance, allowing faster access. However this
+# would fail if there is more than one instance of
+# the dlmalloc allocator class. Therefore this option can
+# be enabled if multiple instances are required. Note: as
+# a special case, if this allocator is used as the
+# implementation of malloc, and it can be determined there
+# is more than one malloc pool, then this option will be
+# silently enabled.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_SAFE_MULTIPLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# Use system memcpy() and memset()
+# This may be used to control whether memset() and memcpy()
+# are used within the implementation. The alternative is
+# to use some macro equivalents, which some people report
+# are faster in some circumstances.
+#
+cdl_option CYGIMP_MEMALLOC_ALLOCATOR_DLMALLOC_USE_MEMCPY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value:  0 != CYGPKG_ISOINFRA 
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+    # Requires: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+};
+
+# Minimum alignment of allocated blocks
+# This option controls the minimum alignment that the
+# allocated memory blocks are aligned on, specified as
+# 2^N. Note that using large mininum alignments can lead
+# to excessive memory wastage.
+#
+cdl_option CYGNUM_MEMALLOC_ALLOCATOR_DLMALLOC_ALIGNMENT {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 3
+    # value_source default
+    # Default value: 3
+    # Legal values: 3 to 10
+};
+
+# <
+# Variable block allocator with separate metadata
+# This component contains configuration options related to the 
+# variable block memory allocator with separate metadata.
+#
+cdl_component CYGPKG_MEMALLOC_ALLOCATOR_SEPMETA {
+    # There is no associated value.
+};
+
+# >
+# Make thread safe
+# With this option enabled, this allocator will be
+# made thread-safe. Additionally allocation functions
+# are made available that allow a thread to wait
+# until memory is available.
+#
+cdl_option CYGSEM_MEMALLOC_ALLOCATOR_SEPMETA_THREADAWARE {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# <
+# <
+# Kernel C API support for memory allocation
+# This option must be enabled to provide the extensions required
+# to support integration into the kernel C API.
+#
+cdl_option CYGFUN_MEMALLOC_KAPI {
+    # This option is not active
+    # ActiveIf constraint: CYGPKG_KERNEL
+    #     CYGPKG_KERNEL (unknown) == 0
+    #   --> 0
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: CYGFUN_KERNEL_API_C
+    #     CYGFUN_KERNEL_API_C (unknown) == 0
+    #   --> 0
+};
+
+# malloc(0) returns NULL
+# This option controls the behavior of malloc(0) ( or calloc with
+# either argument 0 ). It is permitted by the standard to return
+# either a NULL pointer or a unique pointer. Enabling this option
+# forces a NULL pointer to be returned.
+#
+cdl_option CYGSEM_MEMALLOC_MALLOC_ZERO_RETURNS_NULL {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# Breakpoint site when running out of memory
+# Whenever the system runs out of memory, it invokes this function
+# before either going to sleep waiting for memory to become 
+# available or returning failure.
+#
+cdl_option CYGSEM_MEMALLOC_INVOKE_OUT_OF_MEMORY {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+};
+
+# malloc() and supporting allocators
+# This component enables support for dynamic memory
+# allocation as supplied by the functions malloc(),
+# free(), calloc() and realloc(). As these
+# functions are often used, but can have quite an
+# overhead, disabling them here can ensure they
+# cannot even be used accidentally when static
+# allocation is preferred. Within this component are
+# various allocators that can be selected for use
+# as the underlying implementation of the dynamic
+# allocation functions.
+#
+cdl_component CYGPKG_MEMALLOC_MALLOC_ALLOCATORS {
+    # ActiveIf constraint: CYGPKG_ISOINFRA
+    #     CYGPKG_ISOINFRA == current
+    #   --> 1
+
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+};
+
+# >
+# Use external heap definition
+# This option allows other components in the
+# system to override the default system
+# provision of heap memory pools. This should
+# be set to a header which provides the equivalent
+# definitions to <pkgconf/heaps.hxx>.
+#
+cdl_component CYGBLD_MEMALLOC_MALLOC_EXTERNAL_HEAP_H {
+    # Flavor: booldata
+    # No user value, uncomment the following line to provide one.
+    # user_value 0 0
+    # value_source default
+    # Default value: 0 0
+};
+
+# malloc() allocator implementations
+#
+cdl_interface CYGINT_MEMALLOC_MALLOC_ALLOCATORS {
+    # Implemented by CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE, active, disabled
+    # Implemented by CYGIMP_MEMALLOC_MALLOC_DLMALLOC, active, enabled
+    # This value cannot be modified here.
+    # Flavor: data
+    # Current_value: 1
+    # Requires:  CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1 
+    #     CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1
+    #   --> 1
+
+    # The following properties are affected by this value
+    # interface CYGINT_MEMALLOC_MALLOC_ALLOCATORS
+    #     Requires:  CYGINT_MEMALLOC_MALLOC_ALLOCATORS == 1 
+};
+
+# malloc() implementation instantiation data
+# Memory allocator implementations that are capable of being
+# used underneath malloc() must be instantiated. The code
+# to do this is set in this option. It is only intended to
+# be set by the implementation, not the user.
+#
+cdl_option CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value <cyg/memalloc/dlmalloc.hxx>
+    # value_source default
+    # Default value: <cyg/memalloc/dlmalloc.hxx>
+
+    # The following properties are affected by this value
+    # option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE
+    #     Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/memvar.hxx>" 
+    # option CYGIMP_MEMALLOC_MALLOC_DLMALLOC
+    #     Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/dlmalloc.hxx>" 
+};
+
+# Simple variable block implementation
+# This causes malloc() to use the simple
+# variable block allocator.
+#
+cdl_option CYGIMP_MEMALLOC_MALLOC_VARIABLE_SIMPLE {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 0
+    # value_source default
+    # Default value: 0
+    # Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/memvar.hxx>" 
+    #     CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER == <cyg/memalloc/dlmalloc.hxx>
+    #   --> 0
+    # Requires: CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE
+    #     CYGSEM_MEMALLOC_ALLOCATOR_VARIABLE_COALESCE == 1
+    #   --> 1
+};
+
+# Doug Lea's malloc implementation
+# This causes malloc() to use a version of Doug Lea's
+# malloc (dlmalloc) as the underlying implementation.
+#
+cdl_option CYGIMP_MEMALLOC_MALLOC_DLMALLOC {
+    # Flavor: bool
+    # No user value, uncomment the following line to provide one.
+    # user_value 1
+    # value_source default
+    # Default value: 1
+    # Requires:  CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER ==  "<cyg/memalloc/dlmalloc.hxx>" 
+    #     CYGBLD_MEMALLOC_MALLOC_IMPLEMENTATION_HEADER == <cyg/memalloc/dlmalloc.hxx>
+    #   --> 1
+};
+
+# <
+# Size of the fallback dynamic memory pool in bytes
+# If *no* heaps are configured in your memory layout,
+# dynamic memory allocation by
+# malloc() and calloc() must be from a fixed-size,
+# contiguous memory pool (note here that it is the
+# pool that is of a fixed size, but malloc() is still
+# able to allocate variable sized chunks of memory
+# from it). This option is the size
+# of that pool, in bytes. Note that not all of
+# this is available for programs to
+# use - some is needed for internal information
+# about memory regions, and some may be lost to
+# ensure that memory allocation only returns
+# memory aligned on word (or double word)
+# boundaries - a very common architecture
+# constraint.
+#
+cdl_option CYGNUM_MEMALLOC_FALLBACK_MALLOC_POOL_SIZE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value 16384
+    # value_source default
+    # Default value: 16384
+    # Legal values: 32 to 0x7fffffff
+};
+
+# Common memory allocator package build options
+# Package specific build options including control over
+# compiler flags used only in building this package,
+# and details of which tests are built.
+#
+cdl_component CYGPKG_MEMALLOC_OPTIONS {
+    # There is no associated value.
+};
+
+# >
+# Additional compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are used in addition
+# to the set of global flags.
+#
+cdl_option CYGPKG_MEMALLOC_CFLAGS_ADD {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Suppressed compiler flags
+# This option modifies the set of compiler flags for
+# building this package. These flags are removed from
+# the set of global flags if present.
+#
+cdl_option CYGPKG_MEMALLOC_CFLAGS_REMOVE {
+    # Flavor: data
+    # No user value, uncomment the following line to provide one.
+    # user_value ""
+    # value_source default
+    # Default value: ""
+};
+
+# Tests
+# This option specifies the set of tests for this package.
+#
+cdl_option CYGPKG_MEMALLOC_TESTS {
+    # Calculated value:  "tests/dlmalloc1 tests/dlmalloc2 tests/heaptest tests/kmemfix1 tests/kmemvar1 tests/malloc1 tests/malloc2 tests/malloc3 tests/malloc4 tests/memfix1 tests/memfix2 tests/memvar1 tests/memvar2 tests/realloc tests/sepmeta1 tests/sepmeta2" 
+    # Flavor: data
+    # Current_value: tests/dlmalloc1 tests/dlmalloc2 tests/heaptest tests/kmemfix1 tests/kmemvar1 tests/malloc1 tests/malloc2 tests/malloc3 tests/malloc4 tests/memfix1 tests/memfix2 tests/memvar1 tests/memvar2 tests/realloc tests/sepmeta1 tests/sepmeta2
+};
+
+# <
+# <
+# <
+
diff --git a/tests/ecos/ethercat.cxx ./tests/ecos/ethercat.cxx
new file mode 100644
index 0000000..56f60a6
--- /dev/null
+++ ./tests/ecos/ethercat.cxx
@@ -0,0 +1,146 @@
+// $Id: ethercat.cxx,v 1.12 2006/02/23 09:32:27 kgad Exp $
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <stdio.h>
+#include <dll/ethercat_dll.h>
+#include <dll/ethercat_frame.h>
+#include <al/ethercat_master.h>
+#include <al/ethercat_slave_handler.h>
+
+// Generate some load (for latency testing)
+extern void cyg_load_init(void);
+// Generate process data
+extern void cyg_pd_init(void);
+
+// Initialize slave database
+void init_slave_db(void);
+
+int main()
+{
+  // DLL
+  // EtherCAT_DataLinkLayer * dll = EtherCAT_DataLinkLayer::instance();
+  
+  // Init slave db
+  init_slave_db();
+  
+  printf("Creating Master\n");
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  printf("Getting Slave Handler\n");
+  EtherCAT_SlaveHandler * sh = EM->get_slave_handler(0x03e9);
+  bool succeed = sh->to_state(EC_OP_STATE);
+  if (succeed) {
+    printf("EVA board now in OP state\n");
+    succeed = sh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+      // UNCOMMENT THE FOLLOWING LINE IF YOU WANT TO VERIFY THAT NO
+      // PROCESS DATA IS SENT IF THE BOARD IS NOT IN ITS OPERATIONAL
+      // STATE!! 
+      bool succeed = sh->to_state(EC_OP_STATE);
+      if (succeed) {
+	printf("And up and operational again\n");
+	printf("Sending PD, look at the lights...\n");
+	cyg_pd_init();
+      }
+    }
+  }
+
+  // For testing mbx functionality as much as possible...
+  /*
+  EtherCAT_SlaveHandler * csh = EM->get_slave_handler(0x03ea);
+  succeed = csh->to_state(EC_PREOP_STATE);
+  if (succeed) {
+    printf("Complex slave now in PREOP state\n");
+    succeed = csh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+        bool succeed = csh->to_state(EC_SAFEOP_STATE);
+	if (succeed) {
+	  printf("And to SAFEOP\n");
+	}
+    }
+  }
+  */
+
+  // GENERATE SOME LOAD FOR LATENCY TEST...
+  // cyg_load_init();
+
+  printf("Hello EtherCAT world\n");
+  return 0;
+}
+
+// Configuration data of EVA board
+EC_FMMU fmmu0(0x00010000,0x0002,0x00,0x07,0x1100,0x00,false,true,true);
+EC_FMMU fmmu1(0x00010000,0x0002,0x00,0x07,0x1000,0x00,true,false,true);
+EtherCAT_FMMU_Config fmmu_conf(2);
+EC_SyncMan SyncMan0(0x1100,0x0002,
+		    EC_BUFFERED,EC_WRITTEN_FROM_MASTER,false,true,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EC_SyncMan SyncMan1(0x1000,0x0002,
+		    EC_BUFFERED,EC_READ_FROM_MASTER,false,false,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EtherCAT_PD_Config pd_conf(2);
+
+EtherCAT_SlaveConfig EC_evaboard(0x26483052,0x000104b0,0x03e9,&fmmu_conf,&pd_conf);
+
+// Trying to create mbx for testing some of the mbx software... 
+/*
+EC_SyncMan SyncMan_mbx0(0x1400,0x0100,
+			   EC_QUEUED,EC_WRITTEN_FROM_MASTER,false,true,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EC_SyncMan SyncMan_mbx1(0x1500,0x0100,
+			   EC_QUEUED,EC_READ_FROM_MASTER,false,false,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EtherCAT_MbxConfig mbx_conf = { SyncMan_mbx0, SyncMan_mbx0 };
+EtherCAT_SlaveConfig EC_EL4102(0x10063052,0x270b0000,0x03ea,&fmmu_conf,&pd_conf,&mbx_conf);
+*/
+
+void init_slave_db(void)
+{
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(1);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  
+  // For testing mbx...
+  /*
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(2);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  slave_db->set_conf(&EC_EL4102,1);
+  */
+}
+
diff --git a/tests/ecos/src/generate_load.cxx ./tests/ecos/src/generate_load.cxx
new file mode 100644
index 0000000..05ebe5c
--- /dev/null
+++ ./tests/ecos/src/generate_load.cxx
@@ -0,0 +1,96 @@
+// $Id: generate_load.cxx,v 1.4 2006/02/23 09:32:57 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <pkgconf/net_ethercatmaster.h>
+#include <cyg/kernel/kapi.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#define CYGNUM_ETHERCATMASTER_LOAD_STACK_SIZE 16384
+#define CYGNUM_ETHERCATMASTER_LOAD_PRIORITY (CYGNUM_ETHERCATMASTER_DELIVERY_PRIORITY + 15)
+
+// Load thread data
+static cyg_handle_t h_load_thread;
+static cyg_thread     load_thread;
+static unsigned char  load_thread_stack[CYGNUM_ETHERCATMASTER_LOAD_STACK_SIZE];
+
+static void 
+ethercat_load(cyg_addrword_t)
+{
+  // Generate load here... by printf() statement and sleep for a
+  // random time...
+  unsigned int rnd = 0;
+  cyg_tick_count_t delay = 0;
+  char s[]="Random ";
+  unsigned int i;
+  
+  while (true)
+    {
+      // Get random value here...
+      // Rand goes from zero to RANDMAX...
+      rnd = rand()/10000000;
+      printf("Sleeping %d ticks\n",rnd);
+      delay = (cyg_tick_count_t) rnd;
+      // delay = 100;
+      cyg_thread_delay(delay);
+      for ( i = 0; i < rnd ; i++){
+	  printf("%s",s);
+      }
+    }
+}
+
+void 
+cyg_load_init(void)
+{
+  static int is_initialised = false;
+  if(is_initialised) return;
+
+  // KG Check what this does...
+  // cyg_do_net_init(); // Force linking in the initializing constructor
+  
+  // Start helper threads etc here
+  cyg_thread_create(CYGNUM_ETHERCATMASTER_LOAD_PRIORITY,
+                    ethercat_load, 0,
+                    "EtherCAT Master Load",
+                    load_thread_stack, 
+		    CYGNUM_ETHERCATMASTER_LOAD_STACK_SIZE,
+                    &h_load_thread, &load_thread);
+  cyg_thread_resume(h_load_thread);
+
+  // And bring up devices
+  // cyg_net_init_devs();
+
+  // Done
+  is_initialised = true;
+}
+
+
diff --git a/tests/ecos/src/process_data.cxx ./tests/ecos/src/process_data.cxx
new file mode 100644
index 0000000..0732ac9
--- /dev/null
+++ ./tests/ecos/src/process_data.cxx
@@ -0,0 +1,120 @@
+// $Id: process_data.cxx,v 1.7 2006/02/23 09:32:57 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <pkgconf/net_ethercatmaster.h>
+#include <ethercat/ethercat_defs.h>
+#include <al/ethercat_master.h>
+#include <cyg/kernel/kapi.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#define CYGNUM_ETHERCATMASTER_PD_STACK_SIZE 16384
+// Should be less important than the delivery thread (running the
+// DSR), but more important than the routing thread (and especially
+// more important than the load thread!
+#define CYGNUM_ETHERCATMASTER_PD_PRIORITY (CYGNUM_ETHERCATMASTER_DELIVERY_PRIORITY + 1)
+
+/* BIG FAT WARNING:  The following thread priority is not for PRODUCTION use.
+   Use it only to verify that the jitter does increase _tremendously_
+   when the priority of the router and load-generation thread are
+   higher than the priority of the PD thread!!
+*/
+// #define CYGNUM_ETHERCATMASTER_PD_PRIORITY 25
+
+// Process Data thread data
+static cyg_handle_t h_pd_thread;
+static cyg_thread     pd_thread;
+static unsigned char  pd_thread_stack[CYGNUM_ETHERCATMASTER_PD_STACK_SIZE];
+
+// Thread period in nanoseconds
+static const unsigned long long pd_thread_period_ns = 100000000;
+// Convert thread period from nanoseconds to kernel ticks
+static const cyg_tick_count_t pd_thread_period = (pd_thread_period_ns * CYGNUM_HAL_RTC_DENOMINATOR) / CYGNUM_HAL_RTC_NUMERATOR;
+
+static const unsigned char LOGICAL_MSG_LENGTH = 0x02;
+
+static void 
+ethercat_pd(cyg_addrword_t)
+{
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+
+  EC_UINT lights=0x0001;
+  unsigned int counter = 0;
+  while (true){
+    cyg_thread_delay(pd_thread_period);
+    if (counter < 0xf) {
+      lights = lights << 1;
+      counter++;}
+    else {
+      counter = 0;
+      lights = 0x0001;
+    }
+    logical_msg[0] = (unsigned char) (lights & 0x00ff);
+    logical_msg[1] = (unsigned char) ((lights & 0xff00) >> 8);
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+}
+
+static void 
+ethercat_pd_stresstest(cyg_addrword_t)
+{
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  while (true){
+    cyg_thread_delay(1);
+    // logical_msg[0] = 0xff;
+    // logical_msg[1] = 0xff;
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+}
+
+void 
+cyg_pd_init(void)
+{
+  static int is_initialised = false;
+  if(is_initialised) return;
+
+  // Start helper threads etc here
+  cyg_thread_create(CYGNUM_ETHERCATMASTER_PD_PRIORITY,
+                    ethercat_pd, 0,
+                    "EtherCAT Master Pd",
+                    pd_thread_stack, 
+		    CYGNUM_ETHERCATMASTER_PD_STACK_SIZE,
+                    &h_pd_thread, &pd_thread);
+  cyg_thread_resume(h_pd_thread);
+
+  // Done
+  is_initialised = true;
+}
+
+
diff --git a/tests/posix/CMakeLists.txt ./tests/posix/CMakeLists.txt
new file mode 100644
index 0000000..732ec1c
--- /dev/null
+++ ./tests/posix/CMakeLists.txt
@@ -0,0 +1,10 @@
+SET (CMAKE_C_FLAGS "${CMAKE_CFLAGS} ${XNPOSIX_USER_CFLAGS}")
+SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
+ADD_EXECUTABLE(master_test master_test.cpp)
+TARGET_LINK_LIBRARIES(master_test eml)
+# removed eval_test
+#ADD_EXECUTABLE(eval_test eval_test.cpp process_data.cpp)
+#TARGET_LINK_LIBRARIES(eval_test eml)
+TARGET_LINK_LIBRARIES(master_test pthread rt)
+SET_TARGET_PROPERTIES(master_test PROPERTIES LINK_FLAGS "${POSIX_USER_LDFLAGS}")
+ADD_DEPENDENCIES(master_test eml-dynamic)
diff --git a/tests/posix/eval_test.cpp ./tests/posix/eval_test.cpp
new file mode 100644
index 0000000..be78348
--- /dev/null
+++ ./tests/posix/eval_test.cpp
@@ -0,0 +1,200 @@
+// $Id: $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <posix/pthread.h>
+#include <native/task.h>
+#include <signal.h>
+#include <sys/mman.h>
+
+#include <ethercat/ethercat_xenomai_drv.h>
+#include <ethercat/netif.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dll/ethercat_dll.h>
+#include <unistd.h>
+#include <dll/ethercat_frame.h>
+#include <al/ethercat_master.h>
+#include <al/ethercat_slave_handler.h>
+
+struct netif *ni;
+
+// Generate process data
+extern void pd_init(long);
+extern void pd_cleanup();
+
+// Initialize slave database
+void init_slave_db(void);
+
+void* eval_master(void*);
+void catch_signal(int sig);
+
+int main(int argc, char** argv) {
+
+	signal(SIGTERM, catch_signal);
+	signal(SIGINT, catch_signal);
+	signal(SIGHUP, catch_signal);
+	mlockall(MCL_CURRENT|MCL_FUTURE);
+
+	if (argc < 3) {
+        printf("usage: %s <interface> <period (sec)>\n", argv[0]);
+        return 0;
+    }
+
+	pthread_t eval_thread;
+	pthread_attr_t eval_thread_attr;
+
+	//Set attributes of thread
+	pthread_attr_init (& eval_thread_attr);
+
+	if(pthread_create(&eval_thread, &eval_thread_attr, eval_master, argv) != 0) {
+		printf("Cannot create thread EtherCatThread.\n");
+		exit(1);
+	}
+  sleep(1000);
+  pthread_join( eval_thread, 0 );
+
+  // wait for master cleanup
+  pd_cleanup();
+	// cleanup socket
+  catch_signal(0);	
+	return 0;
+}
+
+void* eval_master(void* arg) {
+	ni = init_ec(((char**)arg)[1]);
+  init_slave_db();
+
+	printf("Attach netif \n\n");
+	EtherCAT_DataLinkLayer::instance()->attach(ni);  
+  printf("Creating Master\n");
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  printf("Getting Slave Handler\n");
+  EtherCAT_SlaveHandler * sh = EM->get_slave_handler(0x03e9);
+  bool succeed = sh->to_state(EC_OP_STATE);
+  if (succeed) {
+    printf("EVA board now in OP state\n");
+    succeed = sh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+      // UNCOMMENT THE FOLLOWING LINE IF YOU WANT TO VERIFY THAT NO
+      // PROCESS DATA IS SENT IF THE BOARD IS NOT IN ITS OPERATIONAL
+      // STATE!! 
+      bool succeed = sh->to_state(EC_OP_STATE);
+      if (succeed) {
+	printf("And up and operational again\n");
+	printf("Sending PD, look at the lights...\n");
+	float period_f = atof(((char**)arg)[2]);
+	int long period =(int long) (period_f*1000*1000*1000); 
+	//printf("period: %d\n",period);
+	pd_init(period);
+      }
+    }
+  }
+
+  printf("Hello EtherCAT world\n");
+  return 0;
+
+  // For testing mbx functionality as much as possible...
+  /*
+  EtherCAT_SlaveHandler * csh = EM->get_slave_handler(0x03ea);
+  succeed = csh->to_state(EC_PREOP_STATE);
+  if (succeed) {
+    printf("Complex slave now in PREOP state\n");
+    succeed = csh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+        bool succeed = csh->to_state(EC_SAFEOP_STATE);
+	if (succeed) {
+	  printf("And to SAFEOP\n");
+	}
+    }
+  }
+  */
+
+}
+
+// Configuration data of EVA board
+EC_FMMU fmmu0(0x00010000,0x0002,0x00,0x07,0x1100,0x00,false,true,true);
+EC_FMMU fmmu1(0x00010000,0x0002,0x00,0x07,0x1000,0x00,true,false,true);
+EtherCAT_FMMU_Config fmmu_conf(2);
+EC_SyncMan SyncMan0(0x1100,0x0002,
+		    EC_BUFFERED,EC_WRITTEN_FROM_MASTER,false,true,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EC_SyncMan SyncMan1(0x1000,0x0002,
+		    EC_BUFFERED,EC_READ_FROM_MASTER,false,false,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EtherCAT_PD_Config pd_conf(2);
+
+EtherCAT_SlaveConfig EC_evaboard(0x26483052,0x000104b0,0x03e9,&fmmu_conf,&pd_conf);
+
+// Trying to create mbx for testing some of the mbx software... 
+/*
+EC_SyncMan SyncMan_mbx0(0x1400,0x0100,
+			   EC_QUEUED,EC_WRITTEN_FROM_MASTER,false,true,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EC_SyncMan SyncMan_mbx1(0x1500,0x0100,
+			   EC_QUEUED,EC_READ_FROM_MASTER,false,false,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EtherCAT_MbxConfig mbx_conf = { SyncMan_mbx0, SyncMan_mbx0 };
+EtherCAT_SlaveConfig EC_EL4102(0x10063052,0x270b0000,0x03ea,&fmmu_conf,&pd_conf,&mbx_conf);
+*/
+
+void init_slave_db(void)
+{
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(1);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  
+  // For testing mbx...
+  /*
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(2);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  slave_db->set_conf(&EC_EL4102,1);
+  */
+}
+
+void catch_signal(int sig) {
+    if(ni != 0) {
+		while ((close_socket(ni) < 0) && (errno == EAGAIN)) {
+        	printf("socket busy - waiting...\n");
+        	sleep(1);
+    	}
+	}
+	exit(1);
+}
diff --git a/tests/posix/master_test.cpp ./tests/posix/master_test.cpp
new file mode 100644
index 0000000..a29c4b2
--- /dev/null
+++ ./tests/posix/master_test.cpp
@@ -0,0 +1,162 @@
+// $Id: $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+
+#include <pthread.h>
+#include <signal.h>
+#include <sys/mman.h>
+
+#include <al/ethercat_master.h>
+#include <al/ethercat_AL.h>
+#include <al/ethercat_process_data.h>
+#include <ethercat/ethercat_xenomai_drv.h>
+#include <ethercat/netif.h>
+#include <dll/ethercat_dll.h>
+#include <dll/ethercat_frame.h>
+#include <dll/ethercat_slave_memory.h>
+#include <al/ethercat_slave_conf.h>
+#include <al/ethercat_slave_handler.h>
+
+struct netif *ni;
+
+///SlaveConfig EK1100
+EtherCAT_FMMU_Config fmmu_config_EK1100(0);
+EtherCAT_PD_Config pd_config_EK1100(0);
+EtherCAT_SlaveConfig EC_EK1100(0x044c2c52,0x00010000,0x03e9,&fmmu_config_EK1100,&pd_config_EK1100);
+
+///SlaveConfig EL4102
+EtherCAT_FMMU_Config fmmu_config_EL4102(2);
+EC_FMMU fmmu0_EL4102(0x00080000,0x0001,0x00,0x00,0x080D,0x00,true,false,true);
+EC_FMMU fmmu1_EL4102(0x00010000,0x0004,0x00,0x07,0x1000,0x00,false,true,true);
+
+EC_SyncMan syncman_mbx0_EL4102(0x1800,246,EC_QUEUED,EC_WRITTEN_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EC_SyncMan syncman_mbx1_EL4102(0x18f6,246,EC_QUEUED,EC_READ_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EtherCAT_MbxConfig mbx_conf_EL4102 = {syncman_mbx0_EL4102, syncman_mbx1_EL4102};
+
+EtherCAT_PD_Config pd_config_EL4102(2);
+EC_SyncMan
+ syncman0_EL4102(0x1000,4,EC_BUFFERED,EC_WRITTEN_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EC_SyncMan
+ syncman1_EL4102(0x1100,0,EC_BUFFERED,EC_READ_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EtherCAT_SlaveConfig EC_EL4102(0x10063052,0x00000000,0x03ea,&fmmu_config_EL4102,&pd_config_EL4102,&mbx_conf_EL4102);
+
+
+static void init_slave_db() {
+	EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(2);
+	fmmu_config_EL4102[0] = fmmu0_EL4102;
+	fmmu_config_EL4102[1] = fmmu1_EL4102;
+	pd_config_EL4102[0] = syncman0_EL4102;
+	pd_config_EL4102[1] = syncman1_EL4102;
+	slave_db->set_conf(&EC_EL4102,0);
+	slave_db->set_conf(&EC_EK1100,1);
+	
+}
+
+static void* run_master(void * arg) {
+	
+	ni = init_ec((char*)arg);
+	init_slave_db();
+	if(ni != 0) {
+		printf("Attach netif \n\n");
+		EtherCAT_DataLinkLayer::instance()->attach(ni);
+		printf("Master initializing \n\n");
+		EtherCAT_Master * EM = EtherCAT_Master::instance();
+		printf("Getting slave handler\n");
+		EtherCAT_SlaveHandler * sh_ek1100 = EM->get_slave_handler(0x03e9);
+		//sleep(1);
+		printf("Setting EK1100 to OP STATE\n");
+		if(sh_ek1100->to_state(EC_OP_STATE))
+			printf("EK1100 succesfully set in OP STATE\n");
+		else
+			printf("\nfailed to set EK1100 in OP STATE\n");
+		printf("Getting slave handler\n");
+		EtherCAT_SlaveHandler * sh_el4102 = EM->get_slave_handler(0x03ea);
+		printf("Setting EL4102 to OP STATE\n");
+		if(sh_el4102->to_state(EC_OP_STATE))
+			printf("EL4102 succesfully set in OP STATE\n");
+		else
+			printf("\nfailed to set EL4102 in OP STATE!!\n");
+		
+		printf("AL initializing \n\n");
+		EtherCAT_AL * AL = EtherCAT_AL::instance();
+		
+		///Set Channel 1 to 5V
+		unsigned char msg[2] = {0xff, 0x3f};
+		if(AL->isReady()) {
+			printf("Test: Set Channel 1 to 5V: \n\n");
+			int count = 0;
+			while(count<100000) {
+				EM->txandrx_PD(sizeof(msg),msg);
+				count++;
+			}
+			printf("Test done.\n");
+		}
+		
+		close_socket(ni);
+		
+	}
+}
+
+void catch_signal(int sig)
+{
+   if(ni != 0)
+		close_socket(ni);
+	exit(1);
+}
+
+int main(int argc, char** argv)
+{
+
+	signal(SIGTERM, catch_signal);
+   signal(SIGINT, catch_signal);
+   signal(SIGHUP, catch_signal);
+	mlockall(MCL_CURRENT|MCL_FUTURE);
+
+	if (argc < 2) {
+        printf("usage: %s <interface>\n", argv[0]);
+        return 0;
+    }
+
+	pthread_t xenothread;
+	pthread_attr_t xenothread_attr;
+
+	//Set attributes of thread
+	pthread_attr_init (& xenothread_attr);
+
+	//Start thread
+	if(pthread_create(&xenothread, &xenothread_attr, run_master, argv[1]) != 0) {
+		printf("Cannot create thread EtherCatThread.\n");
+		exit(1);
+	}
+   pthread_join( xenothread, 0 );
+	return 0;
+}
diff --git a/tests/posix/process_data.cpp ./tests/posix/process_data.cpp
new file mode 100644
index 0000000..af2f188
--- /dev/null
+++ ./tests/posix/process_data.cpp
@@ -0,0 +1,113 @@
+// $Id: process_data.cxx,v 1.7 2006/02/23 09:32:57 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <ethercat/ethercat_defs.h>
+#include <al/ethercat_master.h>
+#include <posix/time.h>
+#include <posix/pthread.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+// Process Data thread data
+static pthread_t pd_thread;
+static pthread_attr_t pd_thread_attr;
+
+// Thread period in nanoseconds
+static const long int pd_thread_period_ns = 1000*1000*50*1;
+static int pd_stop_flag = 0;
+
+static const unsigned char LOGICAL_MSG_LENGTH = 0x02;
+
+static void * ethercat_pd(void*) {
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+
+  EC_UINT lights=0x0001;
+  unsigned int counter = 0;
+  while (pd_stop_flag == 0){
+		unsigned long overrun = 0;
+    int ret = pthread_wait_np(&overrun);
+    if ( ret < 0 || overrun != 0 ) {
+			printf("ret: %d overrun: %d", ret, overrun );
+			return (void *) ret;
+			}
+    if (counter < 0xf) {
+      lights = lights << 1;
+      counter++;}
+    else {
+      counter = 0;
+      lights = 0x0001;
+    }
+    logical_msg[0] = (unsigned char) (lights & 0x00ff);
+    logical_msg[1] = (unsigned char) ((lights & 0xff00) >> 8);
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+  return 0;
+}
+
+static void ethercat_pd_stresstest(void) {
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  while (true){
+    // logical_msg[0] = 0xff;
+    // logical_msg[1] = 0xff;
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+}
+
+void pd_init(long int myperiod) {
+  static int is_initialised = false;
+  if(is_initialised) return;
+
+  // Start helper threads etc here
+ pthread_create(&pd_thread,&pd_thread_attr,ethercat_pd,0);
+ struct timespec period;
+ period.tv_sec = 1;
+ period.tv_nsec = pd_thread_period_ns;
+ struct timespec now;
+ clock_gettime(CLOCK_REALTIME,&now);
+ now.tv_sec += 1;
+ int ret = pthread_make_periodic_np(pd_thread, &now, &period);
+ if (ret != 0)
+   printf("pthread_make_periodic_np:  %d\n", ret);
+  // Done
+  is_initialised = true;
+}
+
+void pd_cleanup()
+{
+	pd_stop_flag = 1;
+	void * ret;
+	pthread_join(pd_thread, &ret);
+}
+
+
diff --git a/tests/rtnet/CMakeLists.txt ./tests/rtnet/CMakeLists.txt
new file mode 100644
index 0000000..633aa46
--- /dev/null
+++ ./tests/rtnet/CMakeLists.txt
@@ -0,0 +1,7 @@
+SET (CMAKE_C_FLAGS "${CMAKE_CFLAGS} ${XNPOSIX_USER_CFLAGS}")
+SET (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
+ADD_EXECUTABLE(master_test master_test.cpp)
+TARGET_LINK_LIBRARIES(master_test eml)
+ADD_EXECUTABLE(eval_test eval_test.cpp process_data.cpp)
+TARGET_LINK_LIBRARIES(eval_test eml)
+SET_TARGET_PROPERTIES(master_test eval_test PROPERTIES LINK_FLAGS "${XNPOSIX_USER_LDFLAGS}")
diff --git a/tests/rtnet/eval_test.cpp ./tests/rtnet/eval_test.cpp
new file mode 100644
index 0000000..be78348
--- /dev/null
+++ ./tests/rtnet/eval_test.cpp
@@ -0,0 +1,200 @@
+// $Id: $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <posix/pthread.h>
+#include <native/task.h>
+#include <signal.h>
+#include <sys/mman.h>
+
+#include <ethercat/ethercat_xenomai_drv.h>
+#include <ethercat/netif.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <dll/ethercat_dll.h>
+#include <unistd.h>
+#include <dll/ethercat_frame.h>
+#include <al/ethercat_master.h>
+#include <al/ethercat_slave_handler.h>
+
+struct netif *ni;
+
+// Generate process data
+extern void pd_init(long);
+extern void pd_cleanup();
+
+// Initialize slave database
+void init_slave_db(void);
+
+void* eval_master(void*);
+void catch_signal(int sig);
+
+int main(int argc, char** argv) {
+
+	signal(SIGTERM, catch_signal);
+	signal(SIGINT, catch_signal);
+	signal(SIGHUP, catch_signal);
+	mlockall(MCL_CURRENT|MCL_FUTURE);
+
+	if (argc < 3) {
+        printf("usage: %s <interface> <period (sec)>\n", argv[0]);
+        return 0;
+    }
+
+	pthread_t eval_thread;
+	pthread_attr_t eval_thread_attr;
+
+	//Set attributes of thread
+	pthread_attr_init (& eval_thread_attr);
+
+	if(pthread_create(&eval_thread, &eval_thread_attr, eval_master, argv) != 0) {
+		printf("Cannot create thread EtherCatThread.\n");
+		exit(1);
+	}
+  sleep(1000);
+  pthread_join( eval_thread, 0 );
+
+  // wait for master cleanup
+  pd_cleanup();
+	// cleanup socket
+  catch_signal(0);	
+	return 0;
+}
+
+void* eval_master(void* arg) {
+	ni = init_ec(((char**)arg)[1]);
+  init_slave_db();
+
+	printf("Attach netif \n\n");
+	EtherCAT_DataLinkLayer::instance()->attach(ni);  
+  printf("Creating Master\n");
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  printf("Getting Slave Handler\n");
+  EtherCAT_SlaveHandler * sh = EM->get_slave_handler(0x03e9);
+  bool succeed = sh->to_state(EC_OP_STATE);
+  if (succeed) {
+    printf("EVA board now in OP state\n");
+    succeed = sh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+      // UNCOMMENT THE FOLLOWING LINE IF YOU WANT TO VERIFY THAT NO
+      // PROCESS DATA IS SENT IF THE BOARD IS NOT IN ITS OPERATIONAL
+      // STATE!! 
+      bool succeed = sh->to_state(EC_OP_STATE);
+      if (succeed) {
+	printf("And up and operational again\n");
+	printf("Sending PD, look at the lights...\n");
+	float period_f = atof(((char**)arg)[2]);
+	int long period =(int long) (period_f*1000*1000*1000); 
+	//printf("period: %d\n",period);
+	pd_init(period);
+      }
+    }
+  }
+
+  printf("Hello EtherCAT world\n");
+  return 0;
+
+  // For testing mbx functionality as much as possible...
+  /*
+  EtherCAT_SlaveHandler * csh = EM->get_slave_handler(0x03ea);
+  succeed = csh->to_state(EC_PREOP_STATE);
+  if (succeed) {
+    printf("Complex slave now in PREOP state\n");
+    succeed = csh->to_state(EC_INIT_STATE);
+    if (succeed) {
+      printf("And now back in INIT state\n");
+        bool succeed = csh->to_state(EC_SAFEOP_STATE);
+	if (succeed) {
+	  printf("And to SAFEOP\n");
+	}
+    }
+  }
+  */
+
+}
+
+// Configuration data of EVA board
+EC_FMMU fmmu0(0x00010000,0x0002,0x00,0x07,0x1100,0x00,false,true,true);
+EC_FMMU fmmu1(0x00010000,0x0002,0x00,0x07,0x1000,0x00,true,false,true);
+EtherCAT_FMMU_Config fmmu_conf(2);
+EC_SyncMan SyncMan0(0x1100,0x0002,
+		    EC_BUFFERED,EC_WRITTEN_FROM_MASTER,false,true,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EC_SyncMan SyncMan1(0x1000,0x0002,
+		    EC_BUFFERED,EC_READ_FROM_MASTER,false,false,
+		    false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+		    true);
+EtherCAT_PD_Config pd_conf(2);
+
+EtherCAT_SlaveConfig EC_evaboard(0x26483052,0x000104b0,0x03e9,&fmmu_conf,&pd_conf);
+
+// Trying to create mbx for testing some of the mbx software... 
+/*
+EC_SyncMan SyncMan_mbx0(0x1400,0x0100,
+			   EC_QUEUED,EC_WRITTEN_FROM_MASTER,false,true,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EC_SyncMan SyncMan_mbx1(0x1500,0x0100,
+			   EC_QUEUED,EC_READ_FROM_MASTER,false,false,
+			   false,false,false,EC_QUEUED_STATE_READ,EC_FIRST_BUFFER,
+			   true);
+EtherCAT_MbxConfig mbx_conf = { SyncMan_mbx0, SyncMan_mbx0 };
+EtherCAT_SlaveConfig EC_EL4102(0x10063052,0x270b0000,0x03ea,&fmmu_conf,&pd_conf,&mbx_conf);
+*/
+
+void init_slave_db(void)
+{
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(1);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  
+  // For testing mbx...
+  /*
+  EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(2);
+  fmmu_conf[0] = fmmu0; fmmu_conf[1] = fmmu1;
+  pd_conf[0] = SyncMan0; pd_conf[1] = SyncMan1;
+  slave_db->set_conf(&EC_evaboard,0);
+  slave_db->set_conf(&EC_EL4102,1);
+  */
+}
+
+void catch_signal(int sig) {
+    if(ni != 0) {
+		while ((close_socket(ni) < 0) && (errno == EAGAIN)) {
+        	printf("socket busy - waiting...\n");
+        	sleep(1);
+    	}
+	}
+	exit(1);
+}
diff --git a/tests/rtnet/master_test.cpp ./tests/rtnet/master_test.cpp
new file mode 100644
index 0000000..1978c2c
--- /dev/null
+++ ./tests/rtnet/master_test.cpp
@@ -0,0 +1,163 @@
+// $Id: $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+
+// FIXME KGAD: Shouldn't this be solved by using the xenomai wrappers?
+#include <posix/pthread.h>
+#include <signal.h>
+#include <sys/mman.h>
+
+#include <al/ethercat_master.h>
+#include <al/ethercat_AL.h>
+#include <al/ethercat_process_data.h>
+#include <ethercat/ethercat_xenomai_drv.h>
+#include <ethercat/netif.h>
+#include <dll/ethercat_dll.h>
+#include <dll/ethercat_frame.h>
+#include <dll/ethercat_slave_memory.h>
+#include <al/ethercat_slave_conf.h>
+#include <al/ethercat_slave_handler.h>
+
+struct netif *ni;
+
+///SlaveConfig EK1100
+EtherCAT_FMMU_Config fmmu_config_EK1100(0);
+EtherCAT_PD_Config pd_config_EK1100(0);
+EtherCAT_SlaveConfig EC_EK1100(0x044c2c52,0x00010000,0x03e9,&fmmu_config_EK1100,&pd_config_EK1100);
+
+///SlaveConfig EL4102
+EtherCAT_FMMU_Config fmmu_config_EL4102(2);
+EC_FMMU fmmu0_EL4102(0x00080000,0x0001,0x00,0x00,0x080D,0x00,true,false,true);
+EC_FMMU fmmu1_EL4102(0x00010000,0x0004,0x00,0x07,0x1000,0x00,false,true,true);
+
+EC_SyncMan syncman_mbx0_EL4102(0x1800,246,EC_QUEUED,EC_WRITTEN_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EC_SyncMan syncman_mbx1_EL4102(0x18f6,246,EC_QUEUED,EC_READ_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EtherCAT_MbxConfig mbx_conf_EL4102 = {syncman_mbx0_EL4102, syncman_mbx1_EL4102};
+
+EtherCAT_PD_Config pd_config_EL4102(2);
+EC_SyncMan
+ syncman0_EL4102(0x1000,4,EC_BUFFERED,EC_WRITTEN_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EC_SyncMan
+ syncman1_EL4102(0x1100,0,EC_BUFFERED,EC_READ_FROM_MASTER,true,false,false,false,false,false,EC_FIRST_BUFFER,true);
+EtherCAT_SlaveConfig EC_EL4102(0x10063052,0x00000000,0x03ea,&fmmu_config_EL4102,&pd_config_EL4102,&mbx_conf_EL4102);
+
+
+static void init_slave_db() {
+	EtherCAT_SlaveDb * slave_db = EtherCAT_SlaveDb::instance(2);
+	fmmu_config_EL4102[0] = fmmu0_EL4102;
+	fmmu_config_EL4102[1] = fmmu1_EL4102;
+	pd_config_EL4102[0] = syncman0_EL4102;
+	pd_config_EL4102[1] = syncman1_EL4102;
+	slave_db->set_conf(&EC_EL4102,0);
+	slave_db->set_conf(&EC_EK1100,1);
+	
+}
+
+static void* run_master(void * arg) {
+	
+	ni = init_ec((char*)arg);
+	init_slave_db();
+	if(ni != 0) {
+		printf("Attach netif \n\n");
+		EtherCAT_DataLinkLayer::instance()->attach(ni);
+		printf("Master initializing \n\n");
+		EtherCAT_Master * EM = EtherCAT_Master::instance();
+		printf("Getting slave handler\n");
+		EtherCAT_SlaveHandler * sh_ek1100 = EM->get_slave_handler(0x03e9);
+		//sleep(1);
+		printf("Setting EK1100 to OP STATE\n");
+		if(sh_ek1100->to_state(EC_OP_STATE))
+			printf("EK1100 succesfully set in OP STATE\n");
+		else
+			printf("\nfailed to set EK1100 in OP STATE\n");
+		printf("Getting slave handler\n");
+		EtherCAT_SlaveHandler * sh_el4102 = EM->get_slave_handler(0x03ea);
+		printf("Setting EL4102 to OP STATE\n");
+		if(sh_el4102->to_state(EC_OP_STATE))
+			printf("EL4102 succesfully set in OP STATE\n");
+		else
+			printf("\nfailed to set EL4102 in OP STATE!!\n");
+		
+		printf("AL initializing \n\n");
+		EtherCAT_AL * AL = EtherCAT_AL::instance();
+		
+		///Set Channel 1 to 5V
+		unsigned char msg[2] = {0xff, 0x3f};
+		if(AL->isReady()) {
+			printf("Test: Set Channel 1 to 5V: \n\n");
+			int count = 0;
+			while(count<100000) {
+				EM->txandrx_PD(sizeof(msg),msg);
+				count++;
+			}
+			printf("Test done.\n");
+		}
+		
+		close_socket(ni);
+		
+	}
+}
+
+void catch_signal(int sig)
+{
+   if(ni != 0)
+		close_socket(ni);
+	exit(1);
+}
+
+int main(int argc, char** argv)
+{
+
+	signal(SIGTERM, catch_signal);
+   signal(SIGINT, catch_signal);
+   signal(SIGHUP, catch_signal);
+	mlockall(MCL_CURRENT|MCL_FUTURE);
+
+	if (argc < 2) {
+        printf("usage: %s <interface>\n", argv[0]);
+        return 0;
+    }
+
+	pthread_t xenothread;
+	pthread_attr_t xenothread_attr;
+
+	//Set attributes of thread
+	pthread_attr_init (& xenothread_attr);
+
+	//Start thread
+	if(pthread_create(&xenothread, &xenothread_attr, run_master, argv[1]) != 0) {
+		printf("Cannot create thread EtherCatThread.\n");
+		exit(1);
+	}
+   pthread_join( xenothread, 0 );
+	return 0;
+}
diff --git a/tests/rtnet/process_data.cpp ./tests/rtnet/process_data.cpp
new file mode 100644
index 0000000..af2f188
--- /dev/null
+++ ./tests/rtnet/process_data.cpp
@@ -0,0 +1,113 @@
+// $Id: process_data.cxx,v 1.7 2006/02/23 09:32:57 kgad Exp $
+//===========================================================================
+//	This file is part of "EtherCAT Master Library".
+//	Copyright (C) 2005 FMTC vzw, Diamant Building, A. Reyerslaan 80,
+//	B-1030 Brussels, Belgium.
+//
+//	EtherCAT Master Library is free software; you can redistribute it
+//	and/or modify it under the terms of the GNU General Public License
+//	as published by the Free Software Foundation; either version 2 or
+//	(at your option) any later version.
+//
+//	EtherCAT Master Code is distributed in the hope that it will be
+//	useful, but WITHOUT ANY WARRANTY; without even the implied
+//	warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+//	PURPOSE. See the GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with the EtherCAT Master Library; if not, write to the Free
+//	Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+//	02111-1307 USA.
+//
+//	EtherCAT, the EtherCAT trade name and logo are the intellectual
+//	property of, and protected by Beckhoff. You can use "EtherCAT
+//	Master Library" for creating and/or selling or otherwise
+//	distributing an EtherCAT network master under the terms of the
+//	EtherCAT Master License.
+//
+//	You should have received a copy of the EtherCAT Master License
+//	along with the EtherCAT Master Library; if not, write to Beckhoff
+//	Automation GmbH, Eiserstrasse 5, D-33415 Verl, Germany.
+//===========================================================================
+
+#include <ethercat/ethercat_defs.h>
+#include <al/ethercat_master.h>
+#include <posix/time.h>
+#include <posix/pthread.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+// Process Data thread data
+static pthread_t pd_thread;
+static pthread_attr_t pd_thread_attr;
+
+// Thread period in nanoseconds
+static const long int pd_thread_period_ns = 1000*1000*50*1;
+static int pd_stop_flag = 0;
+
+static const unsigned char LOGICAL_MSG_LENGTH = 0x02;
+
+static void * ethercat_pd(void*) {
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+
+  EC_UINT lights=0x0001;
+  unsigned int counter = 0;
+  while (pd_stop_flag == 0){
+		unsigned long overrun = 0;
+    int ret = pthread_wait_np(&overrun);
+    if ( ret < 0 || overrun != 0 ) {
+			printf("ret: %d overrun: %d", ret, overrun );
+			return (void *) ret;
+			}
+    if (counter < 0xf) {
+      lights = lights << 1;
+      counter++;}
+    else {
+      counter = 0;
+      lights = 0x0001;
+    }
+    logical_msg[0] = (unsigned char) (lights & 0x00ff);
+    logical_msg[1] = (unsigned char) ((lights & 0xff00) >> 8);
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+  return 0;
+}
+
+static void ethercat_pd_stresstest(void) {
+  unsigned char logical_msg[LOGICAL_MSG_LENGTH] = {0xff, 0xff};
+  EtherCAT_Master * EM = EtherCAT_Master::instance();
+  while (true){
+    // logical_msg[0] = 0xff;
+    // logical_msg[1] = 0xff;
+    EM->txandrx_PD(0x02,logical_msg);
+  }
+}
+
+void pd_init(long int myperiod) {
+  static int is_initialised = false;
+  if(is_initialised) return;
+
+  // Start helper threads etc here
+ pthread_create(&pd_thread,&pd_thread_attr,ethercat_pd,0);
+ struct timespec period;
+ period.tv_sec = 1;
+ period.tv_nsec = pd_thread_period_ns;
+ struct timespec now;
+ clock_gettime(CLOCK_REALTIME,&now);
+ now.tv_sec += 1;
+ int ret = pthread_make_periodic_np(pd_thread, &now, &period);
+ if (ret != 0)
+   printf("pthread_make_periodic_np:  %d\n", ret);
+  // Done
+  is_initialised = true;
+}
+
+void pd_cleanup()
+{
+	pd_stop_flag = 1;
+	void * ret;
+	pthread_join(pd_thread, &ret);
+}
+
+
