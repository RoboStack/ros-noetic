diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6070e14d1..54e5f3218 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -51,8 +51,14 @@ else()
 endif()
 
 find_package(octomap REQUIRED)
+
 find_package(ruckig REQUIRED)
+# work around catkin_package not fetching the interface includes from the target
+# to forward to downstream dependencies. The includes do not need to be added
+# in include_directories below because the target is correctly imported here.
+get_target_property(ruckig_INCLUDE_DIRS ruckig::ruckig INTERFACE_INCLUDE_DIRECTORIES)
 set(ruckig_LIBRARIES "ruckig::ruckig")
+
 find_package(urdfdom REQUIRED)
 find_package(urdfdom_headers REQUIRED)
 
diff --git a/cmake/moveit.cmake b/cmake/moveit.cmake
index 134412ab3..83163d534 100644
--- a/cmake/moveit.cmake
+++ b/cmake/moveit.cmake
@@ -1,8 +1,9 @@
 macro(moveit_build_options)
-  # for Bionic
-  if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "9")
+  # for Ubuntu bionic/focal
+  if((CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "11") OR
+     (CMAKE_CXX_COMPILER_ID STREQUAL "Clang" AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "16"))
     if(NOT "${CMAKE_CXX_STANDARD}")
-      set(CMAKE_CXX_STANDARD 14)
+      set(CMAKE_CXX_STANDARD 17)
     endif()
     set(CMAKE_CXX_STANDARD_REQUIRED ON)
     set(CMAKE_CXX_EXTENSIONS OFF)
diff --git a/collision_detection/include/moveit/collision_detection/collision_detector_allocator.h b/collision_detection/include/moveit/collision_detection/collision_detector_allocator.h
index 936989bba..8aaf8ce74 100644
--- a/collision_detection/include/moveit/collision_detection/collision_detector_allocator.h
+++ b/collision_detection/include/moveit/collision_detection/collision_detector_allocator.h
@@ -59,7 +59,7 @@ public:
                                       const moveit::core::RobotModelConstPtr& robot_model) const = 0;
 
   /** create a new CollisionWorld by copying an existing CollisionWorld of the same type.s
-   * The world must be either the same world as used by \orig or a copy of that world which has not yet been modified.
+   * The world must be either the same world as used by \e orig or a copy of that world which has not yet been modified.
    */
   virtual CollisionEnvPtr allocateEnv(const CollisionEnvConstPtr& orig, const WorldPtr& world) const = 0;
 
diff --git a/collision_detection/include/moveit/collision_detection/collision_env.h b/collision_detection/include/moveit/collision_detection/collision_env.h
index 9177fae30..77343c191 100644
--- a/collision_detection/include/moveit/collision_detection/collision_env.h
+++ b/collision_detection/include/moveit/collision_detection/collision_env.h
@@ -56,14 +56,14 @@ public:
   /** @brief Constructor
    *  @param model A robot model to construct the collision robot from
    *  @param padding The padding to use for all objects/links on the robot
-   *  @scale scale A common scaling to use for all objects/links on the robot
+   *  @param scale A common scaling to use for all objects/links on the robot
    */
   CollisionEnv(const moveit::core::RobotModelConstPtr& model, double padding = 0.0, double scale = 1.0);
 
   /** @brief Constructor
    *  @param model A robot model to construct the collision robot from
    *  @param padding The padding to use for all objects/links on the robot
-   *  @scale scale A common scaling to use for all objects/links on the robot
+   *  @param scale A common scaling to use for all objects/links on the robot
    */
   CollisionEnv(const moveit::core::RobotModelConstPtr& model, const WorldPtr& world, double padding = 0.0,
                double scale = 1.0);
@@ -114,7 +114,7 @@ public:
    *  and the world are considered. Self collisions are not checked.
    *  @param req A CollisionRequest object that encapsulates the collision request
    *  @param res A CollisionResult object that encapsulates the collision result
-   *  @robot robot The collision model for the robot
+   *  @param robot The collision model for the robot
    *  @param state The kinematic state for which checks are being made
    */
   virtual void checkRobotCollision(const CollisionRequest& req, CollisionResult& res,
@@ -124,7 +124,7 @@ public:
    *  Allowed collisions are ignored. Self collisions are not checked.
    *  @param req A CollisionRequest object that encapsulates the collision request
    *  @param res A CollisionResult object that encapsulates the collision result
-   *  @robot robot The collision model for the robot
+   *  @param robot The collision model for the robot
    *  @param state The kinematic state for which checks are being made
    *  @param acm The allowed collision matrix.*/
   virtual void checkRobotCollision(const CollisionRequest& req, CollisionResult& res,
@@ -135,7 +135,6 @@ public:
    *  Allowed collisions are ignored. Self collisions are not checked.
    *  @param req A CollisionRequest object that encapsulates the collision request
    *  @param res A CollisionResult object that encapsulates the collision result
-   *  @robot robot The collision model for the robot
    *  @param state1 The kinematic state at the start of the segment for which checks are being made
    *  @param state2 The kinematic state at the end of the segment for which checks are being made
    *  @param acm The allowed collision matrix.*/
@@ -148,10 +147,9 @@ public:
    *  Allowed collisions are ignored. Self collisions are not checked.
    *  @param req A CollisionRequest object that encapsulates the collision request
    *  @param res A CollisionResult object that encapsulates the collision result
-   *  @robot robot The collision model for the robot
    *  @param state1 The kinematic state at the start of the segment for which checks are being made
    *  @param state2 The kinematic state at the end of the segment for which checks are being made
-   *  @param acm The allowed collision matrix.*/
+   */
   virtual void checkRobotCollision(const CollisionRequest& req, CollisionResult& res,
                                    const moveit::core::RobotState& state1,
                                    const moveit::core::RobotState& state2) const = 0;
@@ -175,7 +173,7 @@ public:
   }
 
   /** \brief The distance to self-collision given the robot is at state \e state, ignoring
-      the distances between links that are allowed to always collide (as specified by \e acm) */
+      the distances between links that are allowed to always collide (as specified by \param acm) */
   inline double distanceSelf(const moveit::core::RobotState& state, const AllowedCollisionMatrix& acm) const
   {
     DistanceRequest req;
@@ -190,13 +188,11 @@ public:
   /** \brief Compute the distance between a robot and the world
    *  @param req A DistanceRequest object that encapsulates the distance request
    *  @param res A DistanceResult object that encapsulates the distance result
-   *  @param robot The robot to check distance for
    *  @param state The state for the robot to check distances from */
   virtual void distanceRobot(const DistanceRequest& req, DistanceResult& res,
                              const moveit::core::RobotState& state) const = 0;
 
   /** \brief Compute the shortest distance between a robot and the world
-   *  @param robot The robot to check distance for
    *  @param state The state for the robot to check distances from
    *  @param verbose Output debug information about distance checks */
   inline double distanceRobot(const moveit::core::RobotState& state, bool verbose = false) const
@@ -212,7 +208,6 @@ public:
   }
 
   /** \brief Compute the shortest distance between a robot and the world
-   *  @param robot The robot to check distance for
    *  @param state The state for the robot to check distances from
    *  @param acm Using an allowed collision matrix has the effect of ignoring distances from links that are always
    * allowed to be in collision.
diff --git a/collision_detection/include/moveit/collision_detection/collision_matrix.h b/collision_detection/include/moveit/collision_detection/collision_matrix.h
index b754a5bb4..b56ad4210 100644
--- a/collision_detection/include/moveit/collision_detection/collision_matrix.h
+++ b/collision_detection/include/moveit/collision_detection/collision_matrix.h
@@ -73,10 +73,10 @@ using DecideContactFn = boost::function<bool(collision_detection::Contact&)>;
 
 MOVEIT_CLASS_FORWARD(AllowedCollisionMatrix);  // Defines AllowedCollisionMatrixPtr, ConstPtr, WeakPtr... etc
 
-/** @class AllowedCollisionMatrix
- *  @brief Definition of a structure for the allowed collision matrix. All elements in the collision world are referred
- * to by their names.
- *   This class represents which collisions are allowed to happen and which are not. */
+/** @brief Definition of a structure for the allowed collision matrix.
+ *
+ *  All elements in the collision world are referred to by their names.
+ *  This class represents which collisions are allowed to happen and which are not. */
 class AllowedCollisionMatrix
 {
 public:
diff --git a/collision_detection/include/moveit/collision_detection/collision_octomap_filter.h b/collision_detection/include/moveit/collision_detection/collision_octomap_filter.h
index 36069f95a..74a50f3cb 100644
--- a/collision_detection/include/moveit/collision_detection/collision_octomap_filter.h
+++ b/collision_detection/include/moveit/collision_detection/collision_octomap_filter.h
@@ -49,13 +49,14 @@ namespace collision_detection
  *  Surfaces for Constraint-Based Haptic Rendering. ICRA, May 2012, St Paul, MN.
  *  http://adamleeper.com/research/papers/2012_ICRA_leeper-chan-salisbury.pdf
  *
- *  @param The octomap originally used for collision detection.
- *  @param The collision result (which will get its normals updated)
- *  @param The distance, as a multiple of the octomap cell size, from which to include neighboring cells.
- *  @param The minimum angle change required for a normal to be over-written
- *  @param Whether to request a depth estimate from the algorithm (experimental...)
- *  @param The iso-surface threshold value (0.5 is a reasonable default).
- *  @param The metaball radius, as a multiple of the octomap cell size (1.5 is a reasonable default)
+ *  @param object The octomap originally used for collision detection.
+ *  @param res    The collision result (which will get its normals updated)
+ *  @param cell_bbx_search_distance The distance, as a multiple of the octomap cell size,
+ *                                  from which to include neighboring cells.
+ *  @param allowed_angle_divergence The minimum angle change required for a normal to be over-written
+ *  @param estimate_depth           Whether to request a depth estimate from the algorithm (experimental...)
+ *  @param iso_value                The iso-surface threshold value (0.5 is a reasonable default).
+ *  @param metaball_radius_multiple The metaball radius, as a multiple of the octomap cell size (1.5 is a reasonable default)
  */
 int refineContactNormals(const World::ObjectConstPtr& object, CollisionResult& res,
                          double cell_bbx_search_distance = 1.0, double allowed_angle_divergence = 0.0,
diff --git a/collision_detection_bullet/include/moveit/collision_detection_bullet/bullet_integration/bullet_bvh_manager.h b/collision_detection_bullet/include/moveit/collision_detection_bullet/bullet_integration/bullet_bvh_manager.h
index 25f82387e..e16aaa0dd 100644
--- a/collision_detection_bullet/include/moveit/collision_detection_bullet/bullet_integration/bullet_bvh_manager.h
+++ b/collision_detection_bullet/include/moveit/collision_detection_bullet/bullet_integration/bullet_bvh_manager.h
@@ -110,20 +110,8 @@ public:
 
   /**@brief Add a collision object to the checker
    *
-   * All objects are added should initially be added as static objects. Use the setContactRequest method of defining
-   * which collision objects are moving.
-   *
-   * @param name            The name of the object, must be unique.
-   * @param mask_id         User defined id which gets stored in the results structure.
-   * @param shapes          A vector of shapes that make up the collision object.
-   * @param shape_poses     A vector of poses for each shape, must be same length as shapes
-   * @param shape_types     A vector of shape types for encode the collision object. If the vector is of length 1 it is
-   * used for all shapes.
-   * @param collision_object_types A int identifying a conversion mode for the object. (ex. convert meshes to convex
-   * hulls)
-   * @param enabled         Indicate if the object is enabled for collision checking.
-   * @return true if successfully added, otherwise false. */
-  /**@brief Add a tesseract collision object to the manager
+   * All objects are added as static objects initially.
+   * Use the setContactRequest method for defining which collision objects are moving.
    * @param cow The tesseract bullet collision object */
   virtual void addCollisionObject(const CollisionObjectWrapperPtr& cow) = 0;
 
diff --git a/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_common.h b/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_common.h
index 15403391d..ce90e0078 100644
--- a/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_common.h
+++ b/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_common.h
@@ -273,7 +273,7 @@ struct FCLManager
  *
  *   \param o1 First FCL collision object
  *   \param o2 Second FCL collision object
- *   \data General pointer to arbitrary data which is used during the callback
+ *   \param data General pointer to arbitrary data which is used during the callback
  *   \return True terminates the collision check, false continues it to the next pair of objects */
 bool collisionCallback(fcl::CollisionObjectd* o1, fcl::CollisionObjectd* o2, void* data);
 
@@ -282,7 +282,7 @@ bool collisionCallback(fcl::CollisionObjectd* o1, fcl::CollisionObjectd* o2, voi
  *
  *   \param o1 First FCL collision object
  *   \param o2 Second FCL collision object
- *   \data General pointer to arbitrary data which is used during the callback
+ *   \param data General pointer to arbitrary data which is used during the callback
  *   \return True terminates the distance check, false continues it to the next pair of objects */
 bool distanceCallback(fcl::CollisionObjectd* o1, fcl::CollisionObjectd* o2, void* data, double& min_dist);
 
diff --git a/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_env_fcl.h b/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_env_fcl.h
index c3e81354c..8ff0a926f 100644
--- a/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_env_fcl.h
+++ b/collision_detection_fcl/include/moveit/collision_detection_fcl/collision_env_fcl.h
@@ -111,9 +111,9 @@ protected:
   /** \brief Construct an FCL collision object from MoveIt's World::Object. */
   void constructFCLObjectWorld(const World::Object* obj, FCLObject& fcl_obj) const;
 
-  /** \brief Updates the specified object in \m fcl_objs_ and in the manager from new data available in the World.
+  /** \brief Updates the specified object in \c fcl_objs_ and in the manager from new data available in the World.
    *
-   *  If it does not exist in world, it is deleted. If it's not existing in \m fcl_objs_ yet, it's added there. */
+   *  If it does not exist in world, it is deleted. If it's not existing in \c fcl_objs_ yet, it's added there. */
   void updateFCLObject(const std::string& id);
 
   /** \brief Out of the current robot state and its attached bodies construct an FCLObject which can then be used to
diff --git a/collision_detection_fcl/src/collision_common.cpp b/collision_detection_fcl/src/collision_common.cpp
index 94fcb6c28..9a3bbb880 100644
--- a/collision_detection_fcl/src/collision_common.cpp
+++ b/collision_detection_fcl/src/collision_common.cpp
@@ -404,7 +404,7 @@ struct FCLShapeCache
   /** \brief Map of weak pointers to the FCLGeometry. */
   ShapeMap map_;
 
-  /** \brief Counts cache usage and triggers clearing of cache when \m MAX_CLEAN_COUNT is exceeded. */
+  /** \brief Counts cache usage and triggers clearing of cache when \c MAX_CLEAN_COUNT is exceeded. */
   unsigned int clean_count_;
 };
 
diff --git a/collision_detector_bullet_description.xml b/collision_detector_bullet_description.xml
index 6d90496ea..b7f688682 100644
--- a/collision_detector_bullet_description.xml
+++ b/collision_detector_bullet_description.xml
@@ -1,4 +1,4 @@
-<library path="lib/libcollision_detector_bullet_plugin">
+<library path="libcollision_detector_bullet_plugin">
   <class name="Bullet" type="collision_detection::CollisionDetectorBtPluginLoader"
   base_class_type="collision_detection::CollisionPlugin">
     <description>
diff --git a/collision_detector_fcl_description.xml b/collision_detector_fcl_description.xml
index f96b06c05..794b8ea2a 100644
--- a/collision_detector_fcl_description.xml
+++ b/collision_detector_fcl_description.xml
@@ -1,4 +1,4 @@
-<library path="lib/libcollision_detector_fcl_plugin">
+<library path="libcollision_detector_fcl_plugin">
   <class name="FCL" type="collision_detection::CollisionDetectorFCLPluginLoader"
   base_class_type="collision_detection::CollisionPlugin">
     <description>
diff --git a/constraint_samplers/include/moveit/constraint_samplers/constraint_sampler_manager.h b/constraint_samplers/include/moveit/constraint_samplers/constraint_sampler_manager.h
index 24f433441..0431c1c83 100644
--- a/constraint_samplers/include/moveit/constraint_samplers/constraint_sampler_manager.h
+++ b/constraint_samplers/include/moveit/constraint_samplers/constraint_sampler_manager.h
@@ -124,15 +124,14 @@ public:
    *subgroup IKSolvers, the function will attempt to generate a sampler from the various subgroup solvers.
    *   - It will attempt to determine which constraints act on the IK link for the sub-group IK solvers, and attempts to
    *create ConstraintSampler functions by recursively calling \ref selectDefaultSampler for the sub-group.
-   *   - If any samplers are valid, it adds them to a vector of type \ref ConstraintSamplerPtr.
+   *   - If any samplers are valid, it adds them to a vector of type ConstraintSamplerPtr.
    *   - Once it has iterated through each sub-group, if any samplers are valid, they are returned in a
    *UnionConstraintSampler, along with a JointConstraintSampler if one exists.
    * @param scene The planning scene that will be used to create the ConstraintSampler
    * @param group_name The group name for which to create a sampler
    * @param constr The set of constraints for which to create a sampler
    *
-   * @return A valid \ref ConstraintSamplerPtr if one could be allocated, and otherwise an empty \ref
-   *ConstraintSamplerPtr
+   * @return A valid ConstraintSamplerPtr if one could be allocated, otherwise an empty ConstraintSamplerPtr.
    */
   static ConstraintSamplerPtr selectDefaultSampler(const planning_scene::PlanningSceneConstPtr& scene,
                                                    const std::string& group_name,
diff --git a/constraint_samplers/include/moveit/constraint_samplers/union_constraint_sampler.h b/constraint_samplers/include/moveit/constraint_samplers/union_constraint_sampler.h
index 46626c1e7..37ed4d092 100644
--- a/constraint_samplers/include/moveit/constraint_samplers/union_constraint_sampler.h
+++ b/constraint_samplers/include/moveit/constraint_samplers/union_constraint_sampler.h
@@ -112,24 +112,26 @@ public:
    * \brief No-op, as the union constraint sampler is for already
    * configured samplers
    *
-   * @param [in] constr Constraint message
+   * @param [in] constraint Constraint message
    *
    * @return Always true
    */
-  bool configure(const moveit_msgs::Constraints& /*constr*/) override
+  bool configure(const moveit_msgs::Constraints& constraint) override
   {
+    (void)constraint;
     return true;
   }
 
   /**
    * \brief No-op, as the union constraint sampler can act on anything
    *
-   * @param [in] constr Constraint message
+   * @param [in] constraint Constraint message
    *
    * @return Always true
    */
-  virtual bool canService(const moveit_msgs::Constraints& /*constr*/) const
+  virtual bool canService(const moveit_msgs::Constraints& constraint) const
   {
+    (void)constraint;
     return true;
   }
 
diff --git a/constraint_samplers/test/pr2_arm_ik.h b/constraint_samplers/test/pr2_arm_ik.h
index e27552a09..6b1c3aee6 100644
--- a/constraint_samplers/test/pr2_arm_ik.h
+++ b/constraint_samplers/test/pr2_arm_ik.h
@@ -117,8 +117,7 @@ inline bool solveCosineEqn(const double& a, const double& b, const double& c, do
 class PR2ArmIK
 {
 public:
-  /** @class
-   *  @brief Inverse kinematics for the PR2 arm.
+  /** @brief Inverse kinematics for the PR2 arm.
    *  @author Sachin Chitta <sachinc@willowgarage.com>
    *
    */
@@ -127,35 +126,33 @@ public:
 
   /**
       @brief Initialize the solver by providing a urdf::Model and a root and tip name.
-      @param A urdf::Model representation of the PR2 robot model
-      @param The root joint name of the arm
-      @param The tip joint name of the arm
+      @param robot_model  A urdf::Model representation of the PR2 robot model
+      @param root_name    The root joint name of the arm
+      @param tip_name     The tip joint name of the arm
       @return true if initialization was successful, false otherwise.
   */
   bool init(const urdf::ModelInterface& robot_model, const std::string& root_name, const std::string& tip_name);
 
   /**
      @brief compute IK based on an initial guess for the shoulder pan angle.
-     @param Input pose for end-effector
-     @param Initial guess for shoulder pan angle
+     @param g_in                       Input pose for end-effector
+     @param shoulder_pan_initial_guess Initial guess for shoulder pan angle
   */
   void computeIKShoulderPan(const Eigen::Isometry3f& g_in, const double& shoulder_pan_initial_guess,
                             std::vector<std::vector<double> >& solution) const;
 
   /**
      @brief compute IK based on an initial guess for the shoulder roll angle.
-     h       @param Input pose for end-effector
-     @param Initial guess for shoulder roll angle
+     @param g_in                        Input pose for end-effector
+     @param shoulder_roll_initial_guess Initial guess for shoulder roll angle
   */
   void computeIKShoulderRoll(const Eigen::Isometry3f& g_in, const double& shoulder_roll_initial_guess,
                              std::vector<std::vector<double> >& solution) const;
 
-  //  std::vector<std::vector<double> > solution_ik_;/// a vector of ik solutions
-
   /**
      @brief get chain information about the arm. This populates the IK query response, filling in joint level
      information including names and joint limits.
-     @param The response structure to be filled in.
+     @param info The response structure to be filled in.
   */
   void getSolverInfo(moveit_msgs::KinematicSolverInfo& info);
 
diff --git a/constraint_samplers/test/pr2_arm_kinematics_plugin.h b/constraint_samplers/test/pr2_arm_kinematics_plugin.h
index 8255cfbd1..2e63ce1cf 100644
--- a/constraint_samplers/test/pr2_arm_kinematics_plugin.h
+++ b/constraint_samplers/test/pr2_arm_kinematics_plugin.h
@@ -71,8 +71,7 @@ class PR2ArmIKSolver : public KDL::ChainIkSolverPos
 public:
   EIGEN_MAKE_ALIGNED_OPERATOR_NEW
 
-  /** @class
-   *  @brief ROS/KDL based interface for the inverse kinematics of the PR2 arm
+  /** @brief ROS/KDL based interface for the inverse kinematics of the PR2 arm
    *  @author Sachin Chitta <sachinc@willowgarage.com>
    *
    *  This class provides a KDL based interface to the inverse kinematics of the PR2 arm.
@@ -131,9 +130,7 @@ MOVEIT_CLASS_FORWARD(PR2ArmKinematicsPlugin);
 class PR2ArmKinematicsPlugin : public kinematics::KinematicsBase
 {
 public:
-  /** @class
-   *  @brief Plugin-able interface to the PR2 arm kinematics
-   */
+  /** @brief Plugin-able interface to the PR2 arm kinematics */
   PR2ArmKinematicsPlugin();
 
   /**
@@ -144,7 +141,6 @@ public:
 
   /**
    * @brief Given a desired pose of the end-effector, compute the joint angles to reach it
-   * @param ik_link_name - the name of the link for which IK is being computed
    * @param ik_pose the desired pose of the link
    * @param ik_seed_state an initial guess solution for the inverse kinematics
    * @return True if a valid solution was found, false otherwise
@@ -177,7 +173,7 @@ public:
    */
   bool searchPositionIK(
       const geometry_msgs::Pose& ik_pose, const std::vector<double>& ik_seed_state, double timeout,
-      const std::vector<double>& consistency_limits, std::vector<double>& solution,
+      const std::vector<double>& consistency_limit, std::vector<double>& solution,
       moveit_msgs::MoveItErrorCodes& error_code,
       const kinematics::KinematicsQueryOptions& options = kinematics::KinematicsQueryOptions()) const override;
 
@@ -206,15 +202,12 @@ public:
    */
   bool searchPositionIK(
       const geometry_msgs::Pose& ik_pose, const std::vector<double>& ik_seed_state, double timeout,
-      const std::vector<double>& consistency_limits, std::vector<double>& solution,
+      const std::vector<double>& consistency_limit, std::vector<double>& solution,
       const IKCallbackFn& solution_callback, moveit_msgs::MoveItErrorCodes& error_code,
       const kinematics::KinematicsQueryOptions& options = kinematics::KinematicsQueryOptions()) const override;
 
   /**
    * @brief Given a set of joint angles and a set of links, compute their pose
-   * @param request  - the request contains the joint angles, set of links for which poses are to be computed and a
-   * timeout
-   * @param response - the response contains stamped pose information for all the requested links
    * @return True if a valid solution was found, false otherwise
    */
   bool getPositionFK(const std::vector<std::string>& link_names, const std::vector<double>& joint_angles,
diff --git a/kinematic_constraints/include/moveit/kinematic_constraints/kinematic_constraint.h b/kinematic_constraints/include/moveit/kinematic_constraints/kinematic_constraint.h
index 51dfd6f76..d76d93900 100644
--- a/kinematic_constraints/include/moveit/kinematic_constraints/kinematic_constraint.h
+++ b/kinematic_constraints/include/moveit/kinematic_constraints/kinematic_constraint.h
@@ -144,8 +144,9 @@ public:
    *
    * @param [in] out The file descriptor for printing
    */
-  virtual void print(std::ostream& /*unused*/ = std::cout) const
+  virtual void print(std::ostream& out = std::cout) const
   {
+    (void)out;
   }
 
   /**
diff --git a/kinematic_constraints/src/utils.cpp b/kinematic_constraints/src/utils.cpp
index cc10209ba..8c7fff5ea 100644
--- a/kinematic_constraints/src/utils.cpp
+++ b/kinematic_constraints/src/utils.cpp
@@ -528,10 +528,8 @@ bool constructConstraints(XmlRpc::XmlRpcValue& params, moveit_msgs::Constraints&
   constraints.name = static_cast<std::string>(params["name"]);
   return collectConstraints(params["constraints"], constraints);
 }
-}  // namespace kinematic_constraints
 
-bool kinematic_constraints::resolveConstraintFrames(const moveit::core::RobotState& state,
-                                                    moveit_msgs::Constraints& constraints)
+bool resolveConstraintFrames(const moveit::core::RobotState& state, moveit_msgs::Constraints& constraints)
 {
   for (auto& c : constraints.position_constraints)
   {
@@ -577,3 +575,4 @@ bool kinematic_constraints::resolveConstraintFrames(const moveit::core::RobotSta
   }
   return true;
 }
+}  // namespace kinematic_constraints
diff --git a/kinematics_base/include/moveit/kinematics_base/kinematics_base.h b/kinematics_base/include/moveit/kinematics_base/kinematics_base.h
index 398d6fa92..04b5340e0 100644
--- a/kinematics_base/include/moveit/kinematics_base/kinematics_base.h
+++ b/kinematics_base/include/moveit/kinematics_base/kinematics_base.h
@@ -140,7 +140,6 @@ struct KinematicsResult
 MOVEIT_CLASS_FORWARD(KinematicsBase);  // Defines KinematicsBasePtr, ConstPtr, WeakPtr... etc
 
 /**
- * @class KinematicsBase
  * @brief Provides an interface for kinematics solvers.
  */
 class KinematicsBase
@@ -607,10 +606,10 @@ protected:
    * for the private namespace and inside 'robot_description_kinematics'.
    * Parameters are searched in the following locations and order
    *
-   * ~/<group_name>/<param>
-   * ~/<param>
-   * robot_description_kinematics/<group_name>/<param>
-   * robot_description_kinematics/<param>
+   * - `~/<group_name>/<param>`
+   * - `~/<param>`
+   * - `robot_description_kinematics/<group_name>/<param>`
+   * - `robot_description_kinematics/<param>`
    *
    * This order maintains default behavior by keeping the private namespace
    * as the predominant configuration but also allows groupwise specifications.
diff --git a/macros/include/moveit/macros/declare_ptr.h b/macros/include/moveit/macros/declare_ptr.h
index 649af4987..ff3b315ff 100644
--- a/macros/include/moveit/macros/declare_ptr.h
+++ b/macros/include/moveit/macros/declare_ptr.h
@@ -37,7 +37,7 @@
 #include <memory>
 
 /**
- * \def MOVEIT_DELCARE_PTR
+ * \def MOVEIT_DECLARE_PTR
  * Macro that given a Name and a Type declares the following types:
  * - ${Name}Ptr            = shared_ptr<${Type}>
  * - ${Name}ConstPtr       = shared_ptr<const ${Type}>
@@ -60,7 +60,7 @@
   typedef std::unique_ptr<const Type> Name##ConstUniquePtr
 
 /**
- * \def MOVEIT_DELCARE_PTR_MEMBER
+ * \def MOVEIT_DECLARE_PTR_MEMBER
  * The macro defines the same typedefs as MOVEIT_DECLARE_PTR, but shortens the new names to their suffix.
  *
  * This can be used to create `Classname::Ptr` style names, but in most situations in MoveIt's codebase,
diff --git a/planning_scene/include/moveit/planning_scene/planning_scene.h b/planning_scene/include/moveit/planning_scene/planning_scene.h
index 28192910d..745284fc4 100644
--- a/planning_scene/include/moveit/planning_scene/planning_scene.h
+++ b/planning_scene/include/moveit/planning_scene/planning_scene.h
@@ -59,7 +59,87 @@
 // Import/export for windows dll's and visibility for gcc shared libraries.
 #include <moveit/moveit_planning_scene_export.h>
 
-/** \brief This namespace includes the central class for representing planning contexts */
+/**
+\section scene-file-format Format of .scene files
+
+It is possible to read/write a PlanningScene's collision objects from a simple text file (`.scene`).
+The file format is defined as follows:
+\verbatim
+  <FILE>:
+      <ID>  # scene id
+      <OBJECT_DESCRIPTION>*
+      . # single dot indicates end of file
+
+  <OBJECT_DESCRIPTION>:
+      * <ID>  # object id
+      <POSE>   # object pose
+      <NUMBER> # number of shapes in object
+      <SHAPE_DESCRIPTION>*
+      <NUMBER> # number of sub frames
+      <SUBFRAME_DESCRIPTION>*
+
+  <SHAPE_DESCRIPTION>:
+      <BOX> | <CONE> | <CYLINDER> | <SPHERE> | <PLANE> | <MESH>
+      <POSE>   # shape pose w.r.t. object's pose
+      <COLOR>  # common color for all shapes
+
+  <SUBFRAME_DESCRIPTION>:
+      <ID>  # sub frame id
+      <POSE>
+
+  <BOX>:
+      box
+      <FLOAT> <FLOAT> <FLOAT>  # box dimensions: x y z
+
+  <CONE>:
+      cone
+      <FLOAT> <FLOAT>  # radius height
+
+  <CYLINDER>:
+      cylinder
+      <FLOAT> <FLOAT>  # radius height
+
+  <SPHERE>:
+      sphere
+      <FLOAT>  # radius
+
+  <PLANE>:
+      plane
+      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # plane parameters: a b c d for a*x + b*y +c*z = d
+
+  <ID>: any text
+
+  <POSE>:
+      <FLOAT> <FLOAT> <FLOAT>  # position: x y z
+      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # quaternion: x y z w
+
+  <COLOR>:
+      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # R G B A
+\endverbatim
+
+   Here is an example:
+\verbatim
+My PlanningScene
+* object
+0 1.0 0
+0 0 0 1
+2
+box
+0.1 0.2 0.3
+0 1.0 0
+0 0 0 1
+1 0 0 0.5
+cylinder
+0.1 0.5
+0.5 0 0
+0 0 0 1
+0 0 1 0.5
+0
+.
+\endverbatim
+*/
+
+/** \brief This namespace includes the central class for representing planning scenes */
 namespace planning_scene
 {
 MOVEIT_CLASS_FORWARD(PlanningScene);  // Defines PlanningScenePtr, ConstPtr, WeakPtr... etc
@@ -678,81 +758,7 @@ public:
 
   /** \brief Save the geometry of the planning scene to a stream, as plain text
 
-   The .scene file format allows simple saving/loading of PlanningScene collisionn objects.
-   The file format is defined as follows:
-\verbatim
-  <FILE>:
-      <ID>  # scene id
-      <OBJECT_DESCRIPTION>*
-      . # single dot indicates end of file
-
-  <OBJECT_DESCRIPTION>:
-      * <ID>  # object id
-      <POSE>   # object pose
-      <NUMBER> # number of shapes in object
-      <SHAPE_DESCRIPTION>*
-      <NUMBER> # number of sub frames
-      <SUBFRAME_DESCRIPTION>*
-
-  <SHAPE_DESCRIPTION>:
-      <BOX> | <CONE> | <CYLINDER> | <SPHERE> | <PLANE> | <MESH>
-      <POSE>   # shape pose w.r.t. object's pose
-      <COLOR>  # common color for all shapes
-
-  <SUBFRAME_DESCRIPTION>:
-      <ID>  # sub frame id
-      <POSE>
-
-  <BOX>:
-      box
-      <FLOAT> <FLOAT> <FLOAT>  # box dimensions: x y z
-
-  <CONE>:
-      cone
-      <FLOAT> <FLOAT>  # radius height
-
-  <CYLINDER>:
-      cylinder
-      <FLOAT> <FLOAT>  # radius height
-
-  <SPHERE>:
-      sphere
-      <FLOAT>  # radius
-
-  <PLANE>:
-      plane
-      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # plane parameters: a b c d for a*x + b*y +c*z = d
-
-  <ID>: any text
-
-  <POSE>:
-      <FLOAT> <FLOAT> <FLOAT>  # position: x y z
-      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # quaternion: x y z w
-
-  <COLOR>:
-      <FLOAT> <FLOAT> <FLOAT> <FLOAT>  # R G B A
-\endverbatim
-
-   Here is an example:
-\verbatim
-My PlanningScene
-* object
-0 1.0 0
-0 0 0 1
-2
-box
-0.1 0.2 0.3
-0 1.0 0
-0 0 0 1
-1 0 0 0.5
-cylinder
-0.1 0.5
-0.5 0 0
-0 0 0 1
-0 0 1 0.5
-0
-.
-\endvarbatim
+   The .scene file format allows simple saving/loading of PlanningScene collision objects (see \ref scene-file-format)
   */
   void saveGeometryToStream(std::ostream& out) const;
 
diff --git a/robot_state/include/moveit/robot_state/attached_body.h b/robot_state/include/moveit/robot_state/attached_body.h
index dec578efc..0ed787dd9 100644
--- a/robot_state/include/moveit/robot_state/attached_body.h
+++ b/robot_state/include/moveit/robot_state/attached_body.h
@@ -188,7 +188,7 @@ public:
    * The returned transform is guaranteed to be a valid isometry. */
   const Eigen::Isometry3d& getGlobalSubframeTransform(const std::string& frame_name, bool* found = nullptr) const;
 
-  /** \brief Check whether a subframe of given @frame_name is present in this object.
+  /** \brief Check whether a subframe of given \param frame_name is present in this object.
    *
    * The frame_name needs to have the object's name prepended (e.g. "screwdriver/tip" returns true if the object's
    * name is "screwdriver"). */
diff --git a/robot_state/include/moveit/robot_state/robot_state.h b/robot_state/include/moveit/robot_state/robot_state.h
index 675d7bcb0..7bb01dcd3 100644
--- a/robot_state/include/moveit/robot_state/robot_state.h
+++ b/robot_state/include/moveit/robot_state/robot_state.h
@@ -1109,7 +1109,6 @@ public:
    * @param twist a Cartesian velocity on the 'tip' frame
    * @param tip the frame for which the twist is given
    * @param dt a time interval (seconds)
-   * @param st a secondary task computation function
    */
   bool setFromDiffIK(const JointModelGroup* group, const Eigen::VectorXd& twist, const std::string& tip, double dt,
                      const GroupStateValidityCallbackFn& constraint = GroupStateValidityCallbackFn());
@@ -1119,7 +1118,6 @@ public:
    * @param twist a Cartesian velocity on the 'tip' frame
    * @param tip the frame for which the twist is given
    * @param dt a time interval (seconds)
-   * @param st a secondary task computation function
    */
   bool setFromDiffIK(const JointModelGroup* group, const geometry_msgs::Twist& twist, const std::string& tip, double dt,
                      const GroupStateValidityCallbackFn& constraint = GroupStateValidityCallbackFn());
@@ -1310,14 +1308,14 @@ public:
 
   /** \brief Set all joints in \e group to random values near the value in \e seed.
    *  \e distance is the maximum amount each joint value will vary from the
-   *  corresponding value in \e seed.  \distance represents meters for
+   *  corresponding value in \e seed.  \e distance represents meters for
    *  prismatic/postitional joints and radians for revolute/orientation joints.
    *  Resulting values are clamped within default bounds. */
   void setToRandomPositionsNearBy(const JointModelGroup* group, const RobotState& seed, double distance);
 
   /** \brief Set all joints in \e group to random values near the value in \e seed, using a specified random number generator.
    *  \e distance is the maximum amount each joint value will vary from the
-   *  corresponding value in \e seed.  \distance represents meters for
+   *  corresponding value in \e seed.  \e distance represents meters for
    *  prismatic/postitional joints and radians for revolute/orientation joints.
    *  Resulting values are clamped within default bounds. */
   void setToRandomPositionsNearBy(const JointModelGroup* group, const RobotState& seed, double distance,
@@ -1327,7 +1325,7 @@ public:
    *  \e distances \b MUST have the same size as \c
    *  group.getActiveJointModels().  Each value in \e distances is the maximum
    *  amount the corresponding active joint in \e group will vary from the
-   *  corresponding value in \e seed.  \distance represents meters for
+   *  corresponding value in \e seed.  \e distance represents meters for
    *  prismatic/postitional joints and radians for revolute/orientation joints.
    *  Resulting values are clamped within default bounds. */
   void setToRandomPositionsNearBy(const JointModelGroup* group, const RobotState& seed,
@@ -1337,7 +1335,7 @@ public:
    *  \e distances \b MUST have the same size as \c
    *  group.getActiveJointModels().  Each value in \e distances is the maximum
    *  amount the corresponding active joint in \e group will vary from the
-   *  corresponding value in \e seed.  \distance represents meters for
+   *  corresponding value in \e seed.  \e distance represents meters for
    *  prismatic/postitional joints and radians for revolute/orientation joints.
    *  Resulting values are clamped within default bounds. */
   void setToRandomPositionsNearBy(const JointModelGroup* group, const RobotState& seed,
diff --git a/robot_trajectory/include/moveit/robot_trajectory/robot_trajectory.h b/robot_trajectory/include/moveit/robot_trajectory/robot_trajectory.h
index b324d8e3d..3a780981f 100644
--- a/robot_trajectory/include/moveit/robot_trajectory/robot_trajectory.h
+++ b/robot_trajectory/include/moveit/robot_trajectory/robot_trajectory.h
@@ -137,7 +137,7 @@ public:
   }
 
   /** @brief  Returns the duration after start that a waypoint will be reached.
-   *  @param  The waypoint index.
+   *  @param index The waypoint index.
    *  @return The duration from start; returns overall duration if index is out of range.
    */
   double getWayPointDurationFromStart(std::size_t index) const;
@@ -278,18 +278,18 @@ public:
   RobotTrajectory& unwind(const moveit::core::RobotState& state);
 
   /** @brief Finds the waypoint indicies before and after a duration from start.
-   *  @param The duration from start.
-   *  @param The waypoint index before the supplied duration.
-   *  @param The waypoint index after (or equal to) the supplied duration.
-   *  @param The progress (0 to 1) between the two waypoints, based on time (not based on joint distances).
+   *  @param duration The duration from start.
+   *  @param before   The waypoint index before the supplied duration.
+   *  @param after    The waypoint index after (or equal to) the supplied duration.
+   *  @param blend    The progress (0 to 1) between the two waypoints, based on time (not based on joint distances).
    */
   void findWayPointIndicesForDurationAfterStart(const double& duration, int& before, int& after, double& blend) const;
 
   // TODO support visitor function for interpolation, or at least different types.
   /** @brief Gets a robot state corresponding to a supplied duration from start for the trajectory, using linear time
    * interpolation.
-   *  @param The duration from start.
-   *  @param The resulting robot state.
+   *  @param request_duration The duration from start.
+   *  @param output_state The resulting robot state.
    *  @return True if state is valid, false otherwise (trajectory is empty).
    */
   bool getStateAtDurationFromStart(const double request_duration, moveit::core::RobotStatePtr& output_state) const;
diff --git a/trajectory_processing/CMakeLists.txt b/trajectory_processing/CMakeLists.txt
index 740e25ae2..f37e8531b 100644
--- a/trajectory_processing/CMakeLists.txt
+++ b/trajectory_processing/CMakeLists.txt
@@ -28,7 +28,6 @@ if(CATKIN_ENABLE_TESTING)
   catkin_add_gtest(test_limit_cartesian_speed test/test_limit_cartesian_speed.cpp)
   target_link_libraries(test_limit_cartesian_speed moveit_test_utils ${catkin_LIBRARIES} ${urdfdom_LIBRARIES} ${urdfdom_headers_LIBRARIES} ${MOVEIT_LIB_NAME})
 
-  # These tests are flaky: https://github.com/ros-planning/moveit/actions/runs/3747836136/jobs/6366564878
-  #catkin_add_gtest(test_ruckig_traj_smoothing test/test_ruckig_traj_smoothing.cpp)
-  #target_link_libraries(test_ruckig_traj_smoothing ${MOVEIT_LIB_NAME} moveit_test_utils)
+  catkin_add_gtest(test_ruckig_traj_smoothing test/test_ruckig_traj_smoothing.cpp)
+  target_link_libraries(test_ruckig_traj_smoothing ${MOVEIT_LIB_NAME} moveit_test_utils)
 endif()
diff --git a/trajectory_processing/include/moveit/trajectory_processing/ruckig_traj_smoothing.h b/trajectory_processing/include/moveit/trajectory_processing/ruckig_traj_smoothing.h
index 4671db898..d79b2645e 100644
--- a/trajectory_processing/include/moveit/trajectory_processing/ruckig_traj_smoothing.h
+++ b/trajectory_processing/include/moveit/trajectory_processing/ruckig_traj_smoothing.h
@@ -37,6 +37,7 @@
 
 #include <Eigen/Core>
 #include <list>
+#include <unordered_map>
 #include <moveit/robot_trajectory/robot_trajectory.h>
 #include <ruckig/ruckig.hpp>
 
@@ -89,8 +90,8 @@ private:
    * \brief Initialize Ruckig position/vel/accel. This initializes ruckig_input and ruckig_output to the same values
    * \param first_waypoint  The Ruckig input/output parameters are initialized to the values at this waypoint
    * \param joint_group     The MoveIt JointModelGroup of interest
-   * \param[out] rucking_input   Input parameters to Ruckig. Initialized here.
-   * \param[out] ruckig_output   Output from the Ruckig algorithm. Initialized here.
+   * \param[out] ruckig_input   Input parameters to Ruckig. Initialized here.
+   * \param[out] ruckig_output  Output from the Ruckig algorithm. Initialized here.
    */
   static void initializeRuckigState(const moveit::core::RobotState& first_waypoint,
                                     const moveit::core::JointModelGroup* joint_group,
@@ -107,9 +108,10 @@ private:
    * There is a trade-off between time-optimality of the output trajectory and runtime of the smoothing algorithm.
    * \param[in, out] trajectory      Trajectory to smooth.
    * \param[in, out] ruckig_input    Necessary input for Ruckig smoothing. Contains kinematic limits (vel, accel, jerk)
+   * \param[in]      batch_size      Minimum number of waypoints to include within a batch
    */
   static std::optional<robot_trajectory::RobotTrajectory>
-  runRuckigInBatches(const size_t num_waypoints, const robot_trajectory::RobotTrajectory& trajectory,
+  runRuckigInBatches(const robot_trajectory::RobotTrajectory& trajectory,
                      ruckig::InputParameter<ruckig::DynamicDOFs>& ruckig_input, size_t batch_size = 100);
 
   /**
diff --git a/trajectory_processing/src/ruckig_traj_smoothing.cpp b/trajectory_processing/src/ruckig_traj_smoothing.cpp
index 0f8dd615b..bdbddb4cd 100644
--- a/trajectory_processing/src/ruckig_traj_smoothing.cpp
+++ b/trajectory_processing/src/ruckig_traj_smoothing.cpp
@@ -48,7 +48,7 @@ const std::string LOGNAME = "moveit_trajectory_processing.ruckig_traj_smoothing"
 constexpr double DEFAULT_MAX_VELOCITY = 5;       // rad/s
 constexpr double DEFAULT_MAX_ACCELERATION = 10;  // rad/s^2
 constexpr double DEFAULT_MAX_JERK = 100;         // rad/s^3
-constexpr double MAX_DURATION_EXTENSION_FACTOR = 10.0;
+constexpr double MAX_DURATION_EXTENSION_FACTOR = 50.0;
 constexpr double DURATION_EXTENSION_FRACTION = 1.1;
 }  // namespace
 
@@ -79,7 +79,7 @@ bool RuckigSmoothing::applySmoothing(robot_trajectory::RobotTrajectory& trajecto
     return false;
   }
 
-  auto ruckig_result = runRuckigInBatches(num_waypoints, trajectory, ruckig_input);
+  auto ruckig_result = runRuckigInBatches(trajectory, ruckig_input);
   if (ruckig_result.has_value())
   {
     trajectory = ruckig_result.value();
@@ -142,7 +142,7 @@ bool RuckigSmoothing::applySmoothing(robot_trajectory::RobotTrajectory& trajecto
     }
   }
 
-  auto ruckig_result = runRuckigInBatches(num_waypoints, trajectory, ruckig_input);
+  auto ruckig_result = runRuckigInBatches(trajectory, ruckig_input);
   if (ruckig_result.has_value())
   {
     trajectory = ruckig_result.value();
@@ -151,17 +151,17 @@ bool RuckigSmoothing::applySmoothing(robot_trajectory::RobotTrajectory& trajecto
 }
 
 std::optional<robot_trajectory::RobotTrajectory>
-RuckigSmoothing::runRuckigInBatches(const size_t num_waypoints, const robot_trajectory::RobotTrajectory& trajectory,
+RuckigSmoothing::runRuckigInBatches(const robot_trajectory::RobotTrajectory& trajectory,
                                     ruckig::InputParameter<ruckig::DynamicDOFs>& ruckig_input, size_t batch_size)
 {
-  // We take the batch size as the lesser of 0.1*num_waypoints or batch_size, to keep a balance between run time and
-  // time-optimality.
+  // We take the batch size as the lesser of 0.1*num_waypoints or batch_size,
+  // to keep a balance between run time and time-optimality.
   // TODO(andyz): parameterize as MIN_BATCH_SIZE and BATCH_SCALING_FACTOR or something like that
-  batch_size = [num_waypoints]() {
-    const size_t temp_batch_size = std::min(size_t(0.1 * num_waypoints), size_t(100));
-    // We need at least 2 waypoints
-    return std::max(size_t(2), temp_batch_size);
-  }();
+  const size_t num_waypoints = trajectory.getWayPointCount();
+  const size_t temp_batch_size = std::min(size_t(0.1 * num_waypoints), size_t(100));
+  // We need at least 2 waypoints
+  batch_size = std::max(size_t(2), temp_batch_size);
+
   size_t batch_start_idx = 0;
   size_t batch_end_idx = batch_size - 1;
   const size_t full_traj_final_idx = num_waypoints - 1;
@@ -295,7 +295,7 @@ bool RuckigSmoothing::runRuckig(robot_trajectory::RobotTrajectory& trajectory,
   ruckig::Result ruckig_result;
   double duration_extension_factor = 1;
   bool smoothing_complete = false;
-  while ((duration_extension_factor < MAX_DURATION_EXTENSION_FACTOR) && !smoothing_complete)
+  while ((duration_extension_factor <= MAX_DURATION_EXTENSION_FACTOR) && !smoothing_complete)
   {
     for (size_t waypoint_idx = 0; waypoint_idx < num_waypoints - 1; ++waypoint_idx)
     {
@@ -347,6 +347,12 @@ bool RuckigSmoothing::runRuckig(robot_trajectory::RobotTrajectory& trajectory,
     }
   }
 
+  if (duration_extension_factor > MAX_DURATION_EXTENSION_FACTOR)
+  {
+    ROS_ERROR_STREAM_NAMED(LOGNAME,
+                           "Ruckig extended the trajectory duration to its maximum and still did not find a solution");
+  }
+
   if (ruckig_result != ruckig::Result::Finished)
   {
     ROS_ERROR_STREAM_NAMED(LOGNAME, "Ruckig trajectory smoothing failed. Ruckig error: " << ruckig_result);
diff --git a/transforms/include/moveit/transforms/transforms.h b/transforms/include/moveit/transforms/transforms.h
index e5a26c4c5..5388a5ef2 100644
--- a/transforms/include/moveit/transforms/transforms.h
+++ b/transforms/include/moveit/transforms/transforms.h
@@ -110,7 +110,7 @@ public:
 
   /**
    * @brief Set a transform in the transform tree (adding it if necessary)
-   * @param transform The input transforms (the frame_id must match the target frame)
+   * @param transforms The input transforms (the frame_id must match the target frame)
    */
   void setTransforms(const std::vector<geometry_msgs::TransformStamped>& transforms);
 
@@ -143,8 +143,8 @@ public:
   /**
    * @brief Transform a quaternion in from_frame to the target_frame
    * @param from_frame The frame in which the input quaternion is specified
-   * @param v_in The input quaternion (in from_frame). Make sure the quaternion is normalized.
-   * @param v_out The resultant (transformed) quaternion. It is guaranteed to be a valid and normalized quaternion.
+   * @param q_in The input quaternion (in from_frame). Make sure the quaternion is normalized.
+   * @param q_out The resultant (transformed) quaternion. It is guaranteed to be a valid and normalized quaternion.
    */
   void transformQuaternion(const std::string& from_frame, const Eigen::Quaterniond& q_in,
                            Eigen::Quaterniond& q_out) const
diff --git a/utils/include/moveit/utils/message_checks.h b/utils/include/moveit/utils/message_checks.h
index 3b9bf9b6d..bedcc0fe8 100644
--- a/utils/include/moveit/utils/message_checks.h
+++ b/utils/include/moveit/utils/message_checks.h
@@ -36,10 +36,7 @@
 
 #pragma once
 
-/** \file empty_msgs.h
- *  \brief Checks for empty MoveIt-related messages
- *
- */
+/** \brief Checks for empty MoveIt-related messages */
 
 #include <moveit_msgs/PlanningScene.h>
 #include <moveit_msgs/PlanningSceneWorld.h>
diff --git a/utils/include/moveit/utils/robot_model_test_utils.h b/utils/include/moveit/utils/robot_model_test_utils.h
index 0ecd26342..6c6788ac2 100644
--- a/utils/include/moveit/utils/robot_model_test_utils.h
+++ b/utils/include/moveit/utils/robot_model_test_utils.h
@@ -124,16 +124,17 @@ public:
    *  \param[in] origin The origin pose of this collision mesh relative to the link origin
    */
   void addCollisionMesh(const std::string& link_name, const std::string& filename, geometry_msgs::Pose origin);
+
   /** \brief Adds a collision box to a specific link.
    *  \param[in] link_name The name of the link to which the box will be added. Must already be in the builder.
-   *  \param[in] size The dimensions of the box
+   *  \param[in] dims   The dimensions of the box
    *  \param[in] origin The origin pose of this collision box relative to the link origin
    */
   void addCollisionBox(const std::string& link_name, const std::vector<double>& dims, geometry_msgs::Pose origin);
 
   /** \brief Adds a visual box to a specific link.
    *  \param[in] link_name The name of the link to which the box will be added. Must already be in the builder.
-   *  \param[in] size The dimensions of the box
+   *  \param[in] size   The dimensions of the box
    *  \param[in] origin The origin pose of this visual box relative to the link origin
    */
   void addVisualBox(const std::string& link_name, const std::vector<double>& size, geometry_msgs::Pose origin);
